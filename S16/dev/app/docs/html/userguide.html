<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>User Guidefoobar!</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="docstyle.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">User Guide</h1>
</header>
Version 3.0.33
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#tutorials">Tutorials</a><ul>
<li><a href="#hello-world">Hello, world!</a></li>
<li><a href="#registers-and-arithmetic">Registers and arithmetic</a></li>
<li><a href="#accessing-memory">Accessing memory</a></li>
<li><a href="#comparisons-and-jumps">Comparisons and jumps</a></li>
<li><a href="#instruction-control">Instruction control</a></li>
<li><a href="#effective-addresses-and-arrays">Effective addresses and arrays</a></li>
<li><a href="#further-topics">Further topics</a></li>
</ul></li>
<li><a href="#architecture">Architecture</a><ul>
<li><a href="#data-representation">Data representation</a></li>
<li><a href="#register-file">Register file</a><ul>
<li><a href="#r0-holds-the-constant-0">R0 holds the constant 0</a></li>
<li><a href="#r15-is-the-condition-code-register">R15 is the condition code register</a></li>
</ul></li>
<li><a href="#memory">Memory</a><ul>
<li><a href="#effective-address">Effective address</a></li>
</ul></li>
<li><a href="#instruction-control-registers">Instruction control registers</a><ul>
<li><a href="#status-register-flags">Status register flags</a></li>
</ul></li>
<li><a href="#interrupts-and-exceptions">Interrupts and exceptions</a><ul>
<li><a href="#mask-and-request-flags">Mask and request flags</a></li>
</ul></li>
<li><a href="#instruction-representation">Instruction representation</a><ul>
<li><a href="#rrr-format">RRR format</a></li>
<li><a href="#rx-format">RX format</a></li>
<li><a href="#exp-format">EXP format</a></li>
</ul></li>
<li><a href="#summary-of-notation">Summary of notation</a></li>
</ul></li>
<li><a href="#instruction-set">Instruction set</a><ul>
<li><a href="#arithmetic-instructions">Arithmetic instructions</a><ul>
<li><a href="#add">add</a></li>
<li><a href="#pop">pop</a></li>
<li><a href="#top">top</a></li>
</ul></li>
<li><a href="#comparisons">Comparisons</a><ul>
<li><a href="#condition-codes-and-booleans">Condition codes and booleans</a></li>
<li><a href="#cmplt">cmplt</a></li>
<li><a href="#cmpeq">cmpeq</a></li>
<li><a href="#cmpgt">cmpgt</a></li>
<li><a href="#cmp">cmp</a></li>
</ul></li>
<li><a href="#jumps">Jumps</a><ul>
<li><a href="#jump">jump</a></li>
<li><a href="#jumpf">jumpf</a></li>
<li><a href="#jumpt">jumpt</a></li>
<li><a href="#jumpc0">jumpc0</a></li>
<li><a href="#jumpc1">jumpc1</a></li>
<li><a href="#jal">jal</a></li>
<li><a href="#aliases-for-conditional-jumps">Aliases for conditional jumps</a></li>
</ul></li>
<li><a href="#bits-and-booleans">Bits and Booleans</a><ul>
<li><a href="#inv">inv</a></li>
<li><a href="#and">and</a></li>
<li><a href="#or">or</a></li>
<li><a href="#xor">xor</a></li>
<li><a href="#shiftl">shiftl</a></li>
<li><a href="#shiftr">shiftr</a></li>
<li><a href="#getbit">getbit</a></li>
<li><a href="#getbitinv">getbitinv</a></li>
<li><a href="#putbit">putbit</a></li>
<li><a href="#putbitinv">putbitinv</a></li>
<li><a href="#extract">extract</a></li>
<li><a href="#execute">execute</a></li>
</ul></li>
<li><a href="#system-control">System control</a><ul>
<li><a href="#trap">trap</a></li>
<li><a href="#getctl">getctl</a></li>
<li><a href="#putctl">putctl</a></li>
<li><a href="#rfi">rfi</a></li>
</ul></li>
<li><a href="#summary-of-the-instruction-set">Summary of the instruction set</a></li>
</ul></li>
<li><a href="#assembly-language">Assembly Language</a><ul>
<li><a href="#notation">Notation</a></li>
<li><a href="#statement-formats">Statement formats</a></li>
<li><a href="#instructions">Instructions</a></li>
<li><a href="#directives">Directives</a><ul>
<li><a href="#expressions">Expressions</a></li>
<li><a href="#module">module</a></li>
<li><a href="#org">org</a></li>
<li><a href="#import">import</a></li>
<li><a href="#export">export</a></li>
<li><a href="#equ">equ</a></li>
</ul></li>
<li><a href="#assembly-listing">Assembly listing</a></li>
</ul></li>
<li><a href="#linker">Linker</a><ul>
<li><a href="#object-code">Object code</a><ul>
<li><a href="#module-statement">module statement</a></li>
<li><a href="#org-statement">org statement</a></li>
<li><a href="#data-statement">data statement</a></li>
<li><a href="#import-statment">import statment</a></li>
<li><a href="#export-statement">export statement</a></li>
<li><a href="#relocate-statement">relocate statement</a></li>
</ul></li>
<li><a href="#executable-code">Executable code</a></li>
<li><a href="#programs-modules-and-files">Programs, modules, and files</a></li>
<li><a href="#simple-standalone-programs">Simple standalone programs</a></li>
<li><a href="#programs-with-multiple-modules">Programs with multiple modules</a></li>
</ul></li>
<li><a href="#programming">Programming</a><ul>
<li><a href="#computer-architecture">Computer Architecture</a><ul>
<li><a href="#machine-language-and-instructions">Machine language and instructions</a></li>
<li><a href="#why-use-sigma16">Why use Sigma16?</a></li>
<li><a href="#structure-of-a-computer">Structure of a computer</a></li>
<li><a href="#instructions-1">Instructions}</a></li>
<li><a href="#the-rtm-instructions">The RTM instructions</a></li>
<li><a href="#the-add-instruction">The add instruction}</a></li>
<li><a href="#registers-can-hold-variables">Registers can hold variables}</a></li>
<li><a href="#notation-and-terminology">Notation and terminology}</a></li>
<li><a href="#a-simple-program">A simple program}</a></li>
<li><a href="#more-arithmetic-instructions">More arithmetic instructions}</a></li>
<li><a href="#example">Example}</a></li>
<li><a href="#general-form-of-arithmetic-instruction">General form of arithmetic instruction}</a></li>
<li><a href="#register-r0-and-r15-are-special">Register R0 and R15 are special!}</a></li>
<li><a href="#memory-1">Memory</a></li>
<li><a href="#limitation-of-register-file-its-small">Limitation of register file: it’s small}</a></li>
<li><a href="#memory-2">Memory}</a></li>
<li><a href="#registers-and-memory">Registers and memory</a></li>
<li><a href="#copying-a-word-between-memory-and-register">Copying a word between memory and register</a></li>
<li><a href="#an-assignment-statement-in-machine-langauge">An assignment statement in machine langauge</a></li>
<li><a href="#why-do-we-have-registers-and-memory">Why do we have registers and memory</a></li>
<li><a href="#constants-the-lea-instruction">Constants: the lea instruction</a></li>
<li><a href="#example-using-lea">Example using lea</a></li>
<li><a href="#stopping-the-program">Stopping the program</a></li>
<li><a href="#defining-variables">Defining variables</a></li>
<li><a href="#a-complete-example-program">A complete example program</a></li>
<li><a href="#programming-languages-and-compiling">Programming languages and Compiling</a></li>
<li><a href="#compiling">Compiling</a><ul>
<li><a href="#high-level-constructs">High level constructs</a></li>
</ul></li>
<li><a href="#statements">Statements</a></li>
<li><a href="#high-level-control-structures">High level control structures</a><ul>
<li><a href="#low-level-constructs">Low level constructs</a></li>
</ul></li>
<li><a href="#low-level-constructs-1">Low level constructs</a></li>
<li><a href="#the-goto-statement">The Goto statement</a></li>
<li><a href="#using-the-goto-statement">Using the goto statement</a></li>
<li><a href="#the-conditional-goto-statement">The conditional goto statement</a></li>
<li><a href="#jumping-and-comparing">Jumping and comparing</a><ul>
<li><a href="#unconditional-jump">Unconditional jump</a></li>
</ul></li>
<li><a href="#jumping">Jumping</a><ul>
<li><a href="#comparison-instructions">Comparison instructions</a></li>
</ul></li>
<li><a href="#comparison-instruction-boolean-form">Comparison instruction: Boolean form</a><ul>
<li><a href="#conditional-jumps">Conditional jumps</a></li>
</ul></li>
<li><a href="#conditional-jumps-boolean-decision">Conditional jumps: Boolean decision</a></li>
<li><a href="#compilation-patterns">Compilation patterns</a></li>
<li><a href="#compilation-patterns-1">Compilation patterns</a></li>
<li><a href="#compiling-an-assignment-statement">Compiling an assignment statement</a><ul>
<li><a href="#if-bexp-then-s">if bexp then S</a></li>
</ul></li>
<li><a href="#if-bexp-then-s-1">if bexp then S</a></li>
<li><a href="#example-code-with-if-then">Example: code with if-then</a></li>
<li><a href="#example-translating-if-then">Example: translating if-then</a><ul>
<li><a href="#if-bexp-then-s1-else-s2">if bexp then S1 else S2</a></li>
</ul></li>
<li><a href="#if-bexp-then-s1-else-s2-1">if bexp then S1 else S2</a><ul>
<li><a href="#while-bexp-do-s">while bexp do S</a></li>
</ul></li>
<li><a href="#while-b-do-s">while b do S</a></li>
<li><a href="#infinite-loops">Infinite loops</a><ul>
<li><a href="#nested-statements">Nested statements</a></li>
</ul></li>
<li><a href="#nested-statements-1">Nested statements</a></li>
<li><a href="#how-to-compile-nested-statements">How to compile nested statements</a></li>
<li><a href="#programming-technique">Programming technique</a></li>
<li><a href="#programming-technique-1">Programming technique</a></li>
<li><a href="#examples-of-the-two-styles">Examples of the two styles</a><ul>
<li><a href="#statement-by-statement-style">Statement-by-statement style</a></li>
</ul></li>
<li><a href="#example-of-statement-by-statement-style">Example of statement-by-statement style</a><ul>
<li><a href="#register-variable-style">Register-variable style}</a></li>
</ul></li>
<li><a href="#example-of-register-variable-style">Example of register-variable style</a><ul>
<li><a href="#comparison-of-the-styles">Comparison of the styles</a></li>
</ul></li>
<li><a href="#comparison-of-the-two-styles">Comparison of the two styles</a></li>
</ul></li>
<li><a href="#machine-language">Machine language</a><ul>
<li><a href="#machine-language-representing-instructions-in-memory">Machine language: representing instructions in memory</a></li>
<li><a href="#whats-in-the-memory">What’s in the memory?</a></li>
<li><a href="#instruction-formats-different-types-of-instruction">Instruction formats: different types of instruction</a></li>
<li><a href="#instruction-formats-representing-instructions">Instruction formats: representing instructions</a></li>
<li><a href="#fields-of-an-instruction-word">Fields of an instruction word</a><ul>
<li><a href="#rrr-instructions">RRR instructions</a></li>
</ul></li>
<li><a href="#rrr-instructions-1">RRR instructions</a></li>
<li><a href="#representing-rrr">Representing RRR</a></li>
<li><a href="#some-rrr-instructions">Some RRR instructions</a></li>
<li><a href="#a-few-rrr-operation-codes">A few RRR operation codes</a></li>
<li><a href="#example-of-rrr">Example of RRR</a><ul>
<li><a href="#rx-instructions">RX instructions</a></li>
</ul></li>
<li><a href="#rx-instructions-1">RX instructions</a></li>
<li><a href="#rx-instructions-2">RX instructions</a></li>
<li><a href="#format-of-rx-instruction">Format of RX instruction</a></li>
<li><a href="#operation-codes-for-rx-instructions">Operation codes for RX instructions</a></li>
<li><a href="#the-assembler">The assembler</a></li>
<li><a href="#assembly-language-1">Assembly language</a></li>
<li><a href="#the-assembler-1">The assembler</a></li>
<li><a href="#assembly-language-2">Assembly language</a></li>
<li><a href="#a-sequence-of-rrr-instructions">A sequence of RRR instructions</a></li>
<li><a href="#variable-names-and-addresses">Variable names and addresses</a></li>
<li><a href="#instructions-in-assembly-language">Instructions in assembly language</a></li>
<li><a href="#how-the-assembler-allocates-memory">How the assembler allocates memory</a></li>
<li><a href="#how-the-assembler-allocates-memory-1">How the assembler allocates memory}</a></li>
<li><a href="#program-structure">Program structure</a></li>
<li><a href="#example-program-add">Example program Add</a></li>
<li><a href="#snapshot-of-memory-example-program-add">Snapshot of memory: example program Add</a></li>
<li><a href="#control-registers">Control registers</a></li>
<li><a href="#boot-reading-in-the-program">Boot: reading in the program</a></li>
<li><a href="#control-registers-1">Control registers</a></li>
<li><a href="#keeping-track-of-where-you-are">Keeping track of where you are</a></li>
<li><a href="#following-pc-and-ir-control-registers">Following PC and IR control registers</a></li>
<li><a href="#assembly-language-syntax">Assembly language syntax</a></li>
<li><a href="#assembly-language-syntax-1">Assembly language syntax</a></li>
<li><a href="#fields-separated-by-spaces">Fields separated by spaces</a></li>
<li><a href="#correct-form-of-operand-field">Correct form of operand field</a></li>
<li><a href="#each-of-these-statements-is-wrong">Each of these statements is wrong!</a></li>
<li><a href="#writing-constants">Writing constants</a></li>
<li><a href="#good-style">Good style</a></li>
<li><a href="#comments">Comments</a></li>
<li><a href="#indent-your-code-consistently">Indent your code consistently</a></li>
<li><a href="#use-spaces-not-tabs">Use spaces, not tabs</a></li>
<li><a href="#address-arithmetic">Address arithmetic</a></li>
<li><a href="#why-r0">Why [R0]?</a></li>
<li><a href="#address-arithmetic-1">Address arithmetic</a></li>
<li><a href="#what-can-you-do-with-address-arithmetic">What can you do with address arithmetic?</a></li>
</ul></li>
<li><a href="#arrays">Arrays</a><ul>
<li><a href="#data-structures">Data structures</a></li>
<li><a href="#arrays-1">Arrays</a></li>
<li><a href="#representing-an-array">Representing an array</a></li>
<li><a href="#allocating-an-array">Allocating an array</a></li>
<li><a href="#example-of-array-allocation">Example of array allocation</a></li>
<li><a href="#what-about-big-arrays">What about big arrays?</a></li>
<li><a href="#indexed-addressing">Indexed addressing</a></li>
<li><a href="#accessing-an-element-of-an-array">Accessing an element of an array</a></li>
<li><a href="#effective-address-1">Effective address</a></li>
<li><a href="#using-the-effective-address">Using the effective address</a></li>
<li><a href="#addressing-modes">Addressing modes</a></li>
<li><a href="#using-effective-address-for-an-array">Using effective address for an array</a></li>
<li><a href="#array-traversal-and-for-loops">Array traversal and for loops</a></li>
<li><a href="#array-traversal">Array traversal</a></li>
<li><a href="#for-loops">For loops</a></li>
<li><a href="#array-traversal-with-while-and-for">Array traversal with while and for</a></li>
<li><a href="#translating-the-for-loop-to-low-level">Translating the for loop to low level</a></li>
<li><a href="#alternative-syntax-for-for-loops">Alternative syntax for for loops</a></li>
<li><a href="#example-program-arraymax">Example program ArrayMax</a></li>
<li><a href="#state-what-the-program-does">State what the program does</a></li>
<li><a href="#high-level-algorithm">High level algorithm}</a></li>
<li><a href="#translate-high-level-code-to-low-level-goto-form">Translate high level code to low level ``goto form’’</a></li>
<li><a href="#specify-how-the-registers-are-used">Specify how the registers are used</a></li>
<li><a href="#block-of-statements-to-initialise-registers">Block of statements to initialise registers</a></li>
<li><a href="#beginning-of-loop">Beginning of loop</a></li>
<li><a href="#body-of-loop-if-then">Body of loop: if-then</a></li>
<li><a href="#end-of-loop">End of loop</a></li>
<li><a href="#finish">Finish</a></li>
<li><a href="#data-definitions">Data definitions</a></li>
</ul></li>
<li><a href="#programming-tips">Programming tips</a><ul>
<li><a href="#a-useful-convention">A useful convention</a></li>
<li><a href="#programming-tip-copying-one-register-to-another">Programming tip: Copying one register to another</a></li>
<li><a href="#using-load-and-store">Using load and store</a></li>
<li><a href="#compilation-patterns-2">Compilation patterns</a></li>
<li><a href="#follow-the-patterns">Follow the patterns!</a></li>
<li><a href="#how-can-you-tell-if-youre-using-the-pattern">How can you tell if you’re using the pattern?</a></li>
<li><a href="#are-you-using-the-pattern">Are you using the pattern?</a></li>
<li><a href="#can-you-gain-efficiency-by-violating-the-pattern">Can you gain efficiency by violating the pattern?</a></li>
<li><a href="#comments-1">Comments</a></li>
<li><a href="#write-the-comments-first">Write the comments first!</a></li>
<li><a href="#why-is-goto-controversial">Why is goto controversial?</a></li>
<li><a href="#goto-considered-harmful-3-march-1968">Goto considered harmful:  (3), March 1968}</a></li>
<li><a href="#what-happened-next">What happened next?</a></li>
</ul></li>
<li><a href="#records">Records</a><ul>
<li><a href="#records-1">Records}</a></li>
<li><a href="#defining-some-records">Defining some records</a></li>
<li><a href="#naming-each-field-explicitly">Naming each field explicitly</a></li>
<li><a href="#pointers">Pointers</a></li>
<li><a href="#expressions-using-pointers">Expressions using pointers</a></li>
<li><a href="#the-operator-requires-only-one-instruction-lea">The &amp; operator requires only one instruction: lea!</a></li>
<li><a href="#the-operator-requires-only-one-instruction-load">The * operator requires only one instruction: load!</a></li>
<li><a href="#flexibility-of-load-and-lea">Flexibility of load and lea</a></li>
<li><a href="#following-a-pointer-to-the-address-of-x-gives-x">Following a pointer to the address of x gives x}</a></li>
<li><a href="#review-accessing-a-variable-the-ordinary-way">Review: accessing a variable the ordinary way</a></li>
<li><a href="#accessing-a-variable-through-a-pointer">Accessing a variable through a pointer</a></li>
<li><a href="#why-is-the-pointer-helpful">Why is the pointer helpful?</a></li>
<li><a href="#access-a-record-using-a-pointer">Access a record using a pointer</a></li>
</ul></li>
<li><a href="#requests-to-the-operating-system">Requests to the Operating System</a><ul>
<li><a href="#typical-os-requests">Typical OS requests</a></li>
<li><a href="#termination">Termination</a></li>
<li><a href="#character-strings-pointer-to-array-of-characters">Character strings: pointer to array of characters</a></li>
<li><a href="#write-operation-on-sigma16">Write operation on Sigma16}</a></li>
<li><a href="#writing-a-string">Writing a string}</a></li>
</ul></li>
<li><a href="#procedures">Procedures</a><ul>
<li><a href="#call-and-return">Call and return</a></li>
<li><a href="#returning-to-the-instruction-after-the-call">Returning to the instruction after the call</a></li>
<li><a href="#calling-and-returning">Calling and returning</a></li>
<li><a href="#the-jump-and-link-instruction-jal">The jump-and-link instruction: jal</a></li>
<li><a href="#jumping-1">Jumping</a></li>
<li><a href="#implementing-call-and-return">Implementing call and return</a></li>
<li><a href="#calling-with-jal-and-returning-with-jump">Calling with jal and returning with jump</a></li>
<li><a href="#parameter-passage">Parameter passage</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#example-passing-argument-and-result-in-r1">Example: Passing argument and result in R1</a></li>
<li><a href="#procedure-calls-another-procedure">Procedure calls another procedure</a></li>
<li><a href="#what-if-a-procedure-calls-another-procedure">What if a procedure calls another procedure?</a></li>
<li><a href="#limitations-of-basic-call">Limitations of basic call</a></li>
<li><a href="#r13-overwritten-proc1-returns-to-the-wrong-place">R13 overwritten: proc1 returns to the wrong place!</a></li>
<li><a href="#saving-state">Saving state</a></li>
<li><a href="#the-wrong-way-to-save-state">The wrong way to save state</a></li>
<li><a href="#saving-registers">Saving registers</a></li>
<li><a href="#where-can-the-registers-be-saved">Where can the registers be saved?</a></li>
<li><a href="#who-saves-the-state-the-caller-or-the-procedure">Who saves the state: the caller or the procedure?</a></li>
<li><a href="#stack-of-return-addresses">Stack of return addresses</a></li>
</ul></li>
<li><a href="#stacks">Stacks</a><ul>
<li><a href="#initially-the-stack-is-empty">Initially the stack is empty}</a></li>
<li><a href="#call-procedure-push-return-address-a">Call procedure, push return address <span class="math inline"><em>a</em></span></a></li>
<li><a href="#call-another-procedure-push-return-address-b">Call another procedure, push return address <span class="math inline"><em>b</em></span></a></li>
<li><a href="#return-pop-produces-return-address-b">Return: pop produces return address <span class="math inline"><em>b</em></span></a></li>
<li><a href="#call-some-procedure-push-return-address-c">Call some procedure, push return address <span class="math inline"><em>c</em></span></a></li>
<li><a href="#call-a-procedure-push-return-address-d">Call a procedure, push return address <span class="math inline"><em>d</em></span></a></li>
<li><a href="#the-call-stack">The call stack</a></li>
<li><a href="#stack-frames">Stack frames</a></li>
<li><a href="#implementing-the-call-stack">Implementing the call stack</a></li>
</ul></li>
<li><a href="#retrospective">Retrospective</a><ul>
<li><a href="#what-is-a-computer-program">What is a computer program?</a></li>
<li><a href="#what-is-a-variable">What is a variable?</a></li>
<li><a href="#review-of-procedures-call-with-jal-return-with-jump">Review of procedures: Call with jal, return with jump</a></li>
<li><a href="#review-basic-calls-with-jal">Review: Basic calls with jal</a></li>
<li><a href="#review-activation-records-a.k.a.-stack-frames">Review: Activation records, a.k.a. stack frames</a></li>
<li><a href="#review-sequence-of-stack-operations">Review: Sequence of stack operations</a></li>
<li><a href="#variables">Variables</a></li>
<li><a href="#access-to-variables">Access to variables</a></li>
<li><a href="#three-classes-of-variable">Three classes of variable</a></li>
<li><a href="#static-variables">Static variables</a></li>
<li><a href="#combining-static-variables-with-code">Combining static variables with code</a></li>
<li><a href="#disadvantages-of-combining-variables-and-code">Disadvantages of combining variables and code</a></li>
<li><a href="#local-variables">Local variables</a></li>
<li><a href="#accessing-local-variables">Accessing local variables</a></li>
<li><a href="#dynamic-variables">Dynamic variables</a></li>
<li><a href="#the-heap">The Heap</a></li>
<li><a href="#the-call-stack-1">The call stack</a></li>
<li><a href="#simplest-stack-return-addresses">Simplest stack: return addresses</a></li>
<li><a href="#saved-registers">Saved registers</a></li>
<li><a href="#dynamic-links">Dynamic links</a></li>
<li><a href="#local-variables-1">Local variables</a></li>
<li><a href="#static-links-for-scoped-variables">Static links for scoped variables</a></li>
<li><a href="#accessing-a-word-in-the-stack-frame">Accessing a word in the stack frame</a></li>
<li><a href="#example-from-factorial-program-see-below">Example from factorial program (see below)</a></li>
<li><a href="#recursive-factorial">Recursive factorial</a></li>
<li><a href="#about-the-factorial-program">About the factorial program</a></li>
<li><a href="#statement-of-problem-and-register-usage">Statement of problem, and register usage</a></li>
<li><a href="#format-of-main-program-stack-frame">Format of main program stack frame</a></li>
<li><a href="#main-program-initialisation">Main program initialisation</a></li>
<li><a href="#main-program-calls-factorial">Main program calls factorial</a></li>
<li><a href="#main-program-finishes">Main program finishes</a></li>
<li><a href="#description-of-factorial-function">Description of factorial function</a></li>
<li><a href="#format-of-stack-frame-for-factorial">Format of stack frame for factorial</a></li>
<li><a href="#factorial-build-stack-frame">Factorial: build stack frame</a></li>
<li><a href="#factorial-check-for-base-or-recursion-case">Factorial: check for base or recursion case</a></li>
<li><a href="#factorial-base-case">Factorial: base case</a></li>
<li><a href="#factorial-recursion-case">Factorial: recursion case</a></li>
<li><a href="#factorial-restore-registers-and-return">Factorial: restore registers and return</a></li>
<li><a href="#static-data-area">Static data area</a></li>
<li><a href="#summary">Summary</a></li>
</ul></li>
<li><a href="#linked-lists">Linked lists</a><ul>
<li><a href="#review-of-pointers">Review of pointers</a></li>
<li><a href="#nodes">Nodes</a></li>
<li><a href="#accessing-the-fields-of-a-node">Accessing the fields of a node</a></li>
<li><a href="#representing-a-linked-list">Representing a linked list</a></li>
<li><a href="#basic-operations-on-lists">Basic operations on lists</a></li>
<li><a href="#is-list-p-empty">Is list p empty?</a></li>
<li><a href="#get-value-in-node-that-p-points-at-x-p.value">Get value in node that p points at: x := *p.value</a></li>
<li><a href="#get-pointer-to-next-node-in-a-list-q-p.next">Get pointer to next node in a list: q := *p.next</a></li>
<li><a href="#traversing-a-list">Traversing a list</a></li>
<li><a href="#search-a-list-p-for-a-value-x">Search a list p for a value x</a></li>
<li><a href="#cons-constructing-a-list-be-consing-a-value-to-the-front">cons — constructing a list be consing a value to the front</a></li>
<li><a href="#implementing-cons">Implementing cons</a></li>
<li><a href="#getting-a-new-node-from-avail-list">Getting a new node from avail list</a></li>
<li><a href="#inserting-a-node-with-x-where-p-points">Inserting a node with x where p points</a></li>
<li><a href="#list-header">List header</a></li>
<li><a href="#deleting-a-node">Deleting a node</a></li>
<li><a href="#code-for-deleting-a-node">Code for deleting a node</a></li>
<li><a href="#space-leaks">Space leaks</a></li>
<li><a href="#memory-management">Memory management</a></li>
<li><a href="#sharing-and-side-effects">Sharing and side effects</a></li>
</ul></li>
<li><a href="#comparing-lists-and-arrays">Comparing lists and arrays}</a><ul>
<li><a href="#accessing-elements">Accessing elements</a></li>
<li><a href="#usage-of-memory">Usage of memory</a></li>
<li><a href="#more-general-data-structures">More general data structures</a></li>
</ul></li>
<li><a href="#abstract-data-type">Abstract data type}</a><ul>
<li><a href="#linked-list-implementation-of-stack">Linked list implementation of stack</a></li>
<li><a href="#array-implementation-of-stack">Array implementation of stack</a></li>
<li><a href="#relationship-between-arrays-and-stacks">Relationship between arrays and stacks</a></li>
<li><a href="#pushing-x-onto-a-stack">Pushing x onto a stack</a></li>
<li><a href="#pop-a-stack-returning-x">Pop a stack, returning x</a></li>
<li><a href="#error-checking">Error checking</a></li>
<li><a href="#issues-with-simplest-implementation">Issues with simplest implementation}</a></li>
<li><a href="#robust-software">Robust software</a></li>
<li><a href="#error-checking-and-error-handling">Error checking and error handling</a></li>
<li><a href="#error-checking-push">Error checking: push</a></li>
<li><a href="#error-checking-pop">Error checking: pop</a></li>
</ul></li>
<li><a href="#programming-techniques">Programming techniques</a><ul>
<li><a href="#compound-boolean-expressions">Compound Boolean expressions</a></li>
<li><a href="#short-circuit-expressions">``Short circuit’’ expressions</a></li>
<li><a href="#implementing-a-compound-boolean-expression">Implementing a compound boolean expression</a></li>
<li><a href="#condition-code">Condition code</a><ul>
<li><a href="#repeat-until-loop">Repeat-until loop</a></li>
</ul></li>
<li><a href="#inputoutput">Input/Output</a></li>
<li><a href="#converting-a-number-to-a-string">Converting a number to a string</a></li>
<li><a href="#arrays-and-pointers">Arrays and pointers</a></li>
<li><a href="#sum-of-an-array-x-using-index-high-level">Sum of an array x using index: high level</a></li>
<li><a href="#arrays-and-pointers-1">Arrays and pointers</a></li>
<li><a href="#accessing-an-array-element-using-a-pointer">Accessing an array element using a pointer</a></li>
<li><a href="#sum-of-an-array-x-using-pointers-high-level">Sum of an array x using pointers: high level</a></li>
<li><a href="#sum-of-an-array-x-using-pointers-assembly-language">Sum of an array x using pointers: assembly language</a></li>
<li><a href="#comparing-the-two-approaches">Comparing the two approaches</a></li>
<li><a href="#records-2">Records</a></li>
<li><a href="#traverse-array-of-records-with-indexing">Traverse array of records with indexing</a></li>
<li><a href="#traverse-array-of-records-with-pointers-high-level">Traverse array of records with pointers: high level</a></li>
<li><a href="#traverse-array-of-records-with-pointers-low-level">Traverse array of records with pointers: low level</a></li>
<li><a href="#traverse-array-of-records-with-pointers-assembly-language">Traverse array of records with pointers: assembly language</a></li>
<li><a href="#stack-overflow">Stack overflow</a></li>
<li><a href="#register-usage">Register usage</a></li>
<li><a href="#initialize-the-stack">Initialize the stack</a></li>
<li><a href="#calling-a-procedure">Calling a procedure</a></li>
<li><a href="#structure-of-procedure-stack-frame">Structure of Procedure stack frame</a></li>
<li><a href="#called-procedure-creates-its-stack-frame">Called procedure creates its stack frame</a></li>
<li><a href="#procedure-finishes-and-returns">Procedure finishes and returns</a></li>
<li><a href="#stack-overflow-1">Stack overflow</a></li>
<li><a href="#blocks">Blocks</a><ul>
<li><a href="#syntax-for-blocks">Syntax for blocks</a></li>
</ul></li>
<li><a href="#python-syntax-style-for-blocks-layout">Python syntax style for blocks: layout</a></li>
<li><a href="#algolpascal-style-for-blocks-beginend">Algol/Pascal style for blocks: begin—end</a></li>
<li><a href="#c-style-for-blocks-braces">C style for blocks: braces</a></li>
<li><a href="#block-structured-style-for-blocks-matching-keywords">Block structured style for blocks: matching keywords</a></li>
<li><a href="#enter-at-beginning-exit-at-end">Enter at beginning, exit at end</a></li>
<li><a href="#single-entranceexit-for-compilation-patterns">Single entrance/exit for compilation patterns</a></li>
<li><a href="#systematic-approach-to-programming">Systematic approach to programming?</a></li>
<li><a href="#why-use-this-systematic-approach-to-programming">Why use this systematic approach to programming?</a></li>
<li><a href="#nested-conditionals">Nested conditionals</a><ul>
<li><a href="#nested-if-then-else">Nested if-then-else</a></li>
</ul></li>
<li><a href="#special-case-of-nested-if-then-else">Special case of nested if-then-else</a></li>
<li><a href="#another-way-to-write-it">Another way to write it</a></li>
<li><a href="#some-programming-languages-have-elsif-or-elif">Some programming languages have elsif or elif</a></li>
<li><a href="#case-and-jump-tables">Case and jump tables</a></li>
<li><a href="#a-common-application-numeric-code">A common application: numeric code</a></li>
<li><a href="#the-case-statement">The case statement</a></li>
<li><a href="#example-numeric-code-specifies-a-command">Example: numeric code specifies a command</a></li>
<li><a href="#selecting-the-command-with-a-case-statement">Selecting the command with a case statement</a></li>
<li><a href="#finding-a-numeric-code">Finding a numeric code</a></li>
<li><a href="#a-problem-with-efficiency">A problem with efficiency</a></li>
<li><a href="#jump-tables-the-basic-idea">Jump tables: the basic idea</a></li>
<li><a href="#jump-table">Jump table</a></li>
<li><a href="#we-have-to-be-careful">We have to be careful!</a></li>
<li><a href="#checking-whether-the-code-is-invalid">Checking whether the code is invalid</a></li>
<li><a href="#commands">Commands</a><ul>
<li><a href="#example-1">Example</a></li>
</ul></li>
<li><a href="#why-are-ordered-lists-useful">Why are ordered lists useful?</a></li>
<li><a href="#where-do-the-commands-come-from">Where do the commands come from?</a></li>
<li><a href="#representing-a-command">Representing a command</a></li>
<li><a href="#reading-a-program-before-writing">Reading a program before writing</a></li>
<li><a href="#some-tips-on-testing-and-debugging">Some tips on testing and debugging</a></li>
<li><a href="#reading-and-testing-a-program">Reading and testing a program</a></li>
<li><a href="#breakpoints">Breakpoints</a></li>
<li><a href="#how-to-set-a-breakpoint">How to set a breakpoint</a></li>
</ul></li>
<li><a href="#trees">Trees</a><ul>
<li><a href="#tree">Tree</a></li>
<li><a href="#a-binary-tree">A binary tree</a></li>
<li><a href="#applications-of-trees">Applications of trees</a></li>
<li><a href="#holding-structured-data">Holding structured data</a></li>
<li><a href="#parsing">Parsing</a></li>
<li><a href="#another-application-of-jump-tables">Another application of jump tables!</a></li>
<li><a href="#searching">Searching</a></li>
<li><a href="#a-better-approach">A better approach</a></li>
<li><a href="#binary-search-tree">Binary search tree</a></li>
<li><a href="#algorithmic-complexity">Algorithmic Complexity</a></li>
<li><a href="#algorithm-is-more-important-than-small-optimisation">Algorithm is more important than small optimisation</a></li>
<li><a href="#complexity-for-search">Complexity for search</a></li>
<li><a href="#how-much-faster">How much faster?</a></li>
<li><a href="#a-common-pitfall">A common pitfall</a></li>
<li><a href="#how-bad-can-complexity-be">How bad can complexity be?</a></li>
</ul></li>
<li><a href="#interrupts">Interrupts</a><ul>
<li><a href="#control-constructs">Control constructs</a></li>
<li><a href="#another-kind-of-control-losing-control">Another kind of control: losing control!</a></li>
<li><a href="#interrupts-1">Interrupts</a></li>
<li><a href="#what-causes-an-interrupt">What causes an interrupt</a></li>
<li><a href="#what-happens-when-an-interrupt-occurs">What happens when an interrupt occurs</a></li>
<li><a href="#saving-state-1">Saving state</a></li>
<li><a href="#how-interrupts-are-used">How interrupts are used</a></li>
<li><a href="#interrupts-and-programming-languages">Interrupts and programming languages</a></li>
<li><a href="#using-interrupts-to-catch-errors">Using interrupts to catch errors</a></li>
<li><a href="#catching-errors">Catching errors</a></li>
<li><a href="#explicit-error-checking">Explicit error checking</a></li>
<li><a href="#problems-with-explicit-error-checking">Problems with explicit error checking</a></li>
<li><a href="#a-better-approach-interrupts">A better approach: interrupts!</a></li>
<li><a href="#why-are-interrupts-better-than-explicit-checking">Why are interrupts better than explicit checking?</a></li>
<li><a href="#concurrent-processes">Concurrent processes</a></li>
<li><a href="#interrupts-and-processes">Interrupts and processes</a></li>
<li><a href="#waiting-for-io-wasted-time">Waiting for I/O = wasted time</a></li>
<li><a href="#a-process-must-sometimes-wait">A process must sometimes wait</a></li>
<li><a href="#dont-wait-switch-to-another-process">Don’t wait — switch to another process</a></li>
<li><a href="#dont-wait-switching-to-another-program">Don’t wait — switching to another program</a></li>
<li><a href="#concurrent-processes-1">Concurrent processes</a></li>
<li><a href="#operating-system-kernel">Operating system kernel</a></li>
<li><a href="#events-that-can-trigger-an-interrupt">Events that can trigger an interrupt</a></li>
<li><a href="#interrupts-and-preemptive-scheduling">Interrupts and preemptive scheduling</a></li>
<li><a href="#the-scheduler">The Scheduler</a></li>
<li><a href="#mouse">Mouse</a></li>
<li><a href="#how-interrupts-are-implemented">How interrupts are implemented</a></li>
<li><a href="#how-interrupts-are-implemented-1">How interrupts are implemented</a></li>
<li><a href="#control">Control</a></li>
<li><a href="#the-control-algorithm">The Control Algorithm</a></li>
<li><a href="#registers">Registers</a></li>
<li><a href="#notation-1">Notation</a></li>
<li><a href="#infinite-loop">Infinite loop</a></li>
<li><a href="#case-dispatch">Case dispatch</a></li>
<li><a href="#control-algorithm">Control algorithm</a></li>
</ul></li>
<li><a href="#languages-and-systems">Languages and systems</a><ul>
<li><a href="#advice-on-software-engineering">Advice on software engineering</a></li>
<li><a href="#what-should-a-software-engineer-study">What should a software engineer study?</a></li>
<li><a href="#syntax-semantics-compilation">Syntax, semantics, compilation</a><ul>
<li><a href="#syntax-easier-but-less-important">Syntax — easier but less important</a></li>
</ul></li>
<li><a href="#syntax-errors">Syntax errors</a></li>
<li><a href="#example-of-syntax-operator-precedence">Example of syntax: operator precedence</a></li>
<li><a href="#deeper-example-of-syntax-ambiguity">Deeper example of syntax: ambiguity</a></li>
<li><a href="#ambiguity-in-if-then-else">Ambiguity in if-then-else</a></li>
<li><a href="#how-does-python-prevent-ambiguity">How does Python prevent ambiguity?</a></li>
<li><a href="#goto">goto</a></li>
<li><a href="#goto-spelled-differently">goto spelled differently</a></li>
<li><a href="#the-break-statement">The break statement</a></li>
<li><a href="#where-does-break-go">Where does break go?</a></li>
<li><a href="#the-continue-statement">The continue statement</a></li>
<li><a href="#break-and-continue-translation-to-low-level">Break and continue: translation to low level</a><ul>
<li><a href="#semantics-harder-but-more-important">Semantics — harder but more important</a></li>
</ul></li>
<li><a href="#semantics">Semantics</a></li>
<li><a href="#how-is-the-semantics-of-a-language-defined">How is the semantics of a language defined?</a></li>
<li><a href="#why-do-the-translation-from-high-to-low-level">Why do the translation from high to low level?</a></li>
<li><a href="#watch-out-for-loose-explanations">Watch out for loose explanations</a></li>
<li><a href="#semantics-of-while">Semantics of while</a></li>
<li><a href="#lists-iterators-and-for-loops">Lists, +, +=, iterators, and for loops</a></li>
<li><a href="#lets-do-some-matrix-calculations">Let’s do some matrix calculations</a></li>
<li><a href="#what-does-mean-in-python">What does += mean in Python?</a></li>
<li><a href="#is-a-b-shorthand-for-a-a-b">Is a += b shorthand for a = a + b?</a></li>
<li><a href="#how-do-we-figure-out-problems-like-this">How do we figure out problems like this?</a><ul>
<li><a href="#are-two-nodes-with-the-same-value-identical">Are two nodes with the same value identical?</a></li>
</ul></li>
<li><a href="#are-two-nodes-with-the-same-value-identical-1">Are two nodes with the same value identical?}</a><ul>
<li><a href="#low-level-list-manipulation">Low level list manipulation</a></li>
</ul></li>
<li><a href="#low-level-list-manipulation-1">Low level list manipulation</a></li>
<li><a href="#b-a.copy">b = a.copy()</a></li>
<li><a href="#list-is-represented-as-nodes">List is represented as nodes</a></li>
<li><a href="#appending-to-a-list">Appending to a list</a></li>
<li><a href="#extending-a-list">Extending a list</a><ul>
<li><a href="#the-operator">The + operator</a></li>
<li><a href="#the-operator-1">The += operator</a></li>
</ul></li>
<li><a href="#the-operator-2">The + operator}</a></li>
<li><a href="#list-with-and">List with + and +=</a></li>
<li><a href="#iterators">Iterators</a></li>
<li><a href="#defining-an-iterator-for-even-numbers">Defining an iterator for even numbers</a></li>
<li><a href="#using-the-iterator">Using the iterator</a></li>
<li><a href="#running-the-even-iterator">Running the even iterator</a></li>
<li><a href="#extending-a-list-with-an-iterator">Extending a list with an iterator</a><ul>
<li><a href="#for-loops-1">for loops</a></li>
</ul></li>
<li><a href="#for-loops-in-algol-and-descendants">for loops in Algol and descendants</a></li>
<li><a href="#for-loops-in-python">for loops in Python</a><ul>
<li><a href="#revisiting-the-mysteries">Revisiting the mysteries}</a></li>
</ul></li>
<li><a href="#compilers">Compilers</a></li>
<li><a href="#source-and-object">Source and object</a></li>
<li><a href="#compilation">{Compilation</a></li>
<li><a href="#how-a-compiler-works">How a compiler works</a></li>
<li><a href="#major-tasks-in-compilation">Major tasks in compilation</a></li>
<li><a href="#parsing-1">Parsing</a></li>
<li><a href="#types">Types</a></li>
<li><a href="#integer-and-floating-point">Integer and floating point</a></li>
<li><a href="#typechecking">Typechecking</a></li>
<li><a href="#write-programs-at-a-high-level">Write programs at a high level</a></li>
<li><a href="#use-patterns-to-translate-to-low-level">Use patterns to translate to low level</a></li>
<li><a href="#translate-low-level-to-assembly-language">Translate low level to assembly language</a></li>
<li><a href="#practical-programming-tip">Practical programming tip</a></li>
</ul></li>
<li><a href="#architecture-1">Architecture</a><ul>
<li><a href="#instructions-2">Instructions</a></li>
<li><a href="#addresses-and-data-structures">Addresses and data structures</a><ul>
<li><a href="#compilation-patterns-3">Compilation patterns</a></li>
</ul></li>
<li><a href="#high-and-low-level-programming-constructs">High and low level programming constructs</a></li>
<li><a href="#high-and-low-level-programming-constructs-1">High and low level programming constructs</a></li>
<li><a href="#compliation-patterns">Compliation patterns</a></li>
<li><a href="#programming-fundamentals">Programming fundamentals</a><ul>
<li><a href="#how-do-you-learn-programming">How do you learn programming</a></li>
</ul></li>
<li><a href="#connections-with-other-subjects">Connections with other subjects</a></li>
<li><a href="#basic-list-operations-extend-and-append">Basic list operations: extend and append</a></li>
<li><a href="#effect-of-extend-and-append-on-data-structures">Effect of extend and append on data structures</a></li>
<li><a href="#make-some-lists">Make some lists}</a></li>
<li><a href="#xx-changed-a-yy-changed-c.">XX changed a, YY changed c.\</a></li>
<li><a href="#list-manipulation-abc-foobarbaz">List manipulation: abc foobarbaz</a></li>
<li><a href="#list-manipulation-abc-initial-values">List manipulation abc: initial values</a></li>
<li><a href="#list-manipulation-abc-after-and-append">List manipulation abc: after + and append</a></li>
<li><a href="#list-manipulation-def">List manipulation: def</a></li>
<li><a href="#list-manipulation-def-initial-values">List manipulation: def initial values</a></li>
<li><a href="#list-manipulation-def-after-appends">List manipulation: def after appends</a></li>
<li><a href="#list-manipulation-ghi">List manipulation: ghi</a></li>
<li><a href="#list-manipulation-ghi-initial-values">List manipulation: ghi initial values</a></li>
<li><a href="#list-manipulation-ghi-after-and-append">List manipulation: ghi after += and append</a></li>
<li><a href="#for-loop">For loop</a></li>
<li><a href="#data-structure-used-in-for-loop">Data structure used in for loop</a></li>
<li><a href="#a-flowchart">A flowchart</a></li>
<li><a href="#if-statement">If statement</a></li>
<li><a href="#data-structure-for-the-if-statement">Data structure for the if statement</a></li>
<li><a href="#flowchart-for-the-if-statement">Flowchart for the if statement</a></li>
<li><a href="#while-loop">While loop</a></li>
<li><a href="#question-continue-statement">Question: Continue statement</a></li>
<li><a href="#question-break-statement">Question: Break statement</a></li>
<li><a href="#a-note-about-the-break-statement">A note about the break statement</a></li>
<li><a href="#results">Results</a></li>
<li><a href="#example-writevalchar">Example: WriteValChar</a></li>
<li><a href="#a-simple-procedure-writevalchar">A simple procedure: WriteValChar</a></li>
<li><a href="#calling-writevalchar">Calling WriteValChar</a></li>
<li><a href="#definition-of-writevalchar-1">Definition of WriteValChar (1)</a></li>
<li><a href="#definition-of-writevalchar-2">Definition of WriteValChar (2)</a></li>
<li><a href="#static-variables-in-a-data-segment">Static variables in a data segment</a></li>
<li><a href="#implementing-static-data-segment">Implementing static data segment</a></li>
<li><a href="#practical-tip---editing">Practical tip - editing</a></li>
</ul></li>
<li><a href="#linking">Linking}</a><ul>
<li><a href="#subroutines">Subroutines</a></li>
<li><a href="#calling-conventions">Calling conventions</a></li>
<li><a href="#linking-1">Linking</a></li>
<li><a href="#interrupts-an-unrequested-jump">Interrupts — an unrequested jump</a></li>
<li><a href="#implementing-interrupts">Implementing interrupts</a></li>
<li><a href="#basic-interrupt-control">Basic interrupt control</a></li>
<li><a href="#saving-the-pc">Saving the PC</a></li>
<li><a href="#where-to-save-the-pc">Where to save the PC?</a></li>
<li><a href="#saving-state-2">Saving state</a></li>
<li><a href="#disabling-interrupts">Disabling interrupts</a></li>
<li><a href="#missing-interrupts">Missing interrupts</a></li>
<li><a href="#architecture-must-support-os">Architecture must support OS</a></li>
<li><a href="#some-historical-examples">Some historical examples</a></li>
<li><a href="#more-recent-examples">More recent examples</a></li>
<li><a href="#speed-of-cache-memory">Speed of cache memory</a></li>
<li><a href="#whats-in-the-cache">What’s in the cache</a></li>
<li><a href="#cache-lines">Cache lines</a></li>
<li><a href="#searching-the-cache">Searching the cache</a></li>
<li><a href="#fully-associative-cache">Fully associative cache</a></li>
<li><a href="#associative-memory">Associative memory</a></li>
<li><a href="#searching-in-associative-memory">Searching in associative memory</a></li>
<li><a href="#a-compromise-set-associative-cache">A compromise: Set associative cache</a></li>
<li><a href="#reducing-cache-misses">Reducing cache misses</a></li>
<li><a href="#processor-after-load-x">Processor: after load x</a></li>
<li><a href="#processor-after-load-y">Processor: after load y</a></li>
<li><a href="#processor-after-add">Processor: after add</a></li>
<li><a href="#processor-after-store">Processor: after store</a></li>
<li><a href="#processor-after-termination">Processor: after termination</a></li>
</ul></li>
<li><a href="#data-types">Data types</a><ul>
<li><a href="#many-kinds-of-procedure">Many kinds of procedure</a></li>
<li><a href="#about-those-jumps-call-and-return">About those jumps (call and return)</a></li>
<li><a href="#characters">Characters</a></li>
<li><a href="#calling-conventions-1">Calling conventions</a></li>
<li><a href="#programming-tips-1">Programming tips</a></li>
<li><a href="#how-to-program-efficiently">How to program efficiently</a></li>
<li><a href="#how-to-waste-time">How to waste time</a></li>
</ul></li>
<li><a href="#using-the-instruction-set">Using the instruction set</a><ul>
<li><a href="#part-of-the-instruction-set">Part of the instruction set</a></li>
<li><a href="#closed-source-open-source-free">Closed source, open source, free</a></li>
</ul></li>
<li><a href="#operating-systems">Operating Systems</a><ul>
<li><a href="#essential-services">Essential services</a></li>
<li><a href="#requests-to-the-os">Requests to the OS</a></li>
<li><a href="#the-trap-instruction">The trap instruction</a></li>
<li><a href="#trap-is-like-jump-but-different">trap is like jump, but different</a></li>
<li><a href="#typical-os-requests-1">Typical OS requests</a></li>
<li><a href="#memory-allocation">Memory allocation</a></li>
<li><a href="#adding-a-character-to-a-string">Adding a character to a string</a></li>
<li><a href="#memory-allocation-1">Memory allocation</a></li>
<li><a href="#part-of-the-instruction-set-1">Part of the instruction set</a></li>
</ul></li>
<li><a href="#pointers-1">Pointers</a><ul>
<li><a href="#three-key-instructions-lea-load-store">Three key instructions: lea, load, store</a></li>
<li><a href="#applications-of-the-instructions">Applications of the instructions</a></li>
<li><a href="#a-computer-is-a-digital-circuit">A computer is a digital circuit!}</a></li>
<li><a href="#philosophical-question-finding-the-ultimate-cause">Philosophical question: finding the ultimate cause}</a></li>
<li><a href="#some-examples-of-emergent-ultimate-causes">Some examples of emergent ``ultimate causes’’}</a></li>
<li><a href="#summary-1">Summary</a><ul>
<li><a href="#booleans">Booleans</a></li>
</ul></li>
<li><a href="#booleans-in-machine-language">Booleans in machine language</a></li>
<li><a href="#example-program-findmax">Example: program findmax}</a></li>
<li><a href="#trap-1">Trap</a></li>
</ul></li>
<li><a href="#addresses">Addresses</a><ul>
<li><a href="#accessing-data">Accessing data</a></li>
<li><a href="#the-multiplexer-circuit">The multiplexer circuit}</a><ul>
<li><a href="#characteristics-of-combinational-circuits">Characteristics of combinational circuits}</a></li>
</ul></li>
<li><a href="#two-kinds-of-circuit">Two kinds of circuit}</a></li>
<li><a href="#hexadecimal-numbers">Hexadecimal Numbers}</a></li>
</ul></li>
<li><a href="#hexadecimal-numbers-1">Hexadecimal Numbers</a><ul>
<li><a href="#hexadecimal-digits">Hexadecimal Digits</a></li>
<li><a href="#hexadecimal-numbers-hex-numbers">Hexadecimal numbers (``hex numbers’’)</a></li>
<li><a href="#hexadecimal-is-easier-to-read-than-bits">Hexadecimal is easier to read than bits</a></li>
<li><a href="#black-boxes">Black boxes</a></li>
</ul></li>
<li><a href="#jumping-2">Jumping</a><ul>
<li><a href="#instruction-set-1">Instruction set</a></li>
<li><a href="#what-can-we-learn-from-this">What can we learn from this?</a></li>
<li><a href="#closed-source-open-source-free-1">Closed source, open source, free</a></li>
<li><a href="#processor-organisation">Processor organisation}</a></li>
<li><a href="#a-computer-is-a-digital-circuit-1">A computer is a digital circuit!</a></li>
<li><a href="#processor-organisation-1">Processor organisation</a></li>
<li><a href="#control-registers-2">Control registers</a></li>
<li><a href="#the-control-algorithm-1">The control algorithm</a></li>
<li><a href="#structure-of-the-control-algorithm">Structure of the control algorithm</a></li>
<li><a href="#a-closer-look-at-lea">A closer look at lea</a></li>
<li><a href="#lea-and-load-similar-but-not-identical">Lea and Load: similar but not identical!</a></li>
<li><a href="#a-jump-is-just-a-load">A jump is just a load!</a></li>
<li><a href="#processor-organisation-2">Processor organisation</a></li>
<li><a href="#processor-organisation-3">Processor organisation</a></li>
<li><a href="#control-registers-3">Control registers</a></li>
<li><a href="#the-control-algorithm-2">The control algorithm</a></li>
<li><a href="#structure-of-the-control-algorithm-1">Structure of the control algorithm</a></li>
<li><a href="#a-closer-look-at-lea-1">A closer look at lea</a></li>
<li><a href="#lea-and-load-similar-but-not-identical-1">Lea and Load: similar but not identical!</a></li>
<li><a href="#a-jump-is-just-a-load-1">A jump is just a load!</a></li>
<li><a href="#programming-guidelines">Programming Guidelines</a></li>
<li><a href="#identify-the-program">Identify the program</a></li>
<li><a href="#high-level-algorithm-as-pseudocode">High level algorithm as pseudocode</a></li>
<li><a href="#middle-level-the-goto-form">Middle level: the ``goto form’’</a></li>
<li><a href="#translate-high-level-code-to-low-level-goto-form-1">Translate high level code to low level ``goto form’’</a></li>
<li><a href="#specify-how-the-registers-are-used-1">Specify how the registers are used</a></li>
<li><a href="#lowest-level-commented-assembly-language">Lowest level: Commented assembly language</a></li>
<li><a href="#block-of-statements-to-initialise-registers-1">Block of statements to initialise registers</a></li>
<li><a href="#assembly-language-code">Assembly language code</a></li>
<li><a href="#assembly-language-continued">Assembly language, continued</a></li>
<li><a href="#data-definitions-1">Data definitions</a></li>
<li><a href="#static-variables-in-a-data-segment-1">Static variables in a data segment</a></li>
<li><a href="#implementing-static-data-segment-1">Implementing static data segment</a></li>
</ul></li>
<li><a href="#a-digital-circuit-for-sigma16">A digital circuit for Sigma16</a><ul>
<li><a href="#emergent-behaviour">Emergent behaviour</a></li>
<li><a href="#some-examples-of-emergent-ultimate-causes-1">Some examples of emergent ``ultimate causes’’</a></li>
</ul></li>
<li><a href="#a-multi-level-systems-programming-language">A multi-level systems programming language</a><ul>
<li><a href="#features-of-sigma-so-far">Features of Sigma (so far)</a></li>
</ul></li>
<li><a href="#assembly-language-3">Assembly language</a><ul>
<li><a href="#assembly-language-notation">Assembly language notation</a></li>
<li><a href="#fields-separated-by-spaces-1">Fields separated by spaces</a></li>
<li><a href="#correct-form-of-operand-field-1">Correct form of operand field</a></li>
<li><a href="#each-of-these-statements-is-wrong-1">Each of these statements is wrong!</a></li>
<li><a href="#writing-constants-1">Writing constants</a></li>
<li><a href="#good-style-1">Good style</a></li>
<li><a href="#comments-2">Comments</a></li>
<li><a href="#indent-your-code-consistently-1">Indent your code consistently</a></li>
<li><a href="#use-spaces-not-tabs-1">Use spaces, not tabs</a></li>
</ul></li>
<li><a href="#programming-techniques-1">Programming techniques</a><ul>
<li><a href="#programming-tip-copying-one-register-to-another-1">Programming tip: Copying one register to another</a></li>
<li><a href="#using-load-and-store-1">Using load and store</a></li>
<li><a href="#a-useful-convention-1">A useful convention</a></li>
<li><a href="#development-by-transformation">Development by transformation}</a></li>
<li><a href="#high-level">High level</a></li>
<li><a href="#low-level">Low level</a></li>
<li><a href="#assembly">Assembly</a><ul>
<li><a href="#basic-types-and-statements">Basic types and statements}</a></li>
</ul></li>
<li><a href="#basic-expressions-and-statements">Basic expressions and statements</a></li>
<li><a href="#exposing-the-architecture">Exposing the architecture</a></li>
<li><a href="#relations-between-the-levels">Relations between the levels</a><ul>
<li><a href="#data-types-and-data-structures">Data types and data structures</a></li>
</ul></li>
<li><a href="#data-types-1">Data types</a></li>
<li><a href="#records-3">Records</a></li>
<li><a href="#traverse-array-of-records-with-indexing-1">Traverse array of records with indexing</a></li>
<li><a href="#traverse-array-of-records-with-pointers">Traverse array of records with pointers</a></li>
<li><a href="#high-level-control-structures-1">High level control structures</a></li>
<li><a href="#low-level-control-structures">Low level control structures</a></li>
<li><a href="#compilation-patterns-4">Compilation patterns</a></li>
<li><a href="#if-bexp-then-s-2">if bexp then S</a></li>
<li><a href="#if-bexp-then-s1-else-s2-2">if bexp then S1 else S2</a></li>
<li><a href="#while-b-do-s-1">while b do S</a></li>
<li><a href="#implementing-compilation-patterns">Implementing compilation patterns</a></li>
<li><a href="#some-interesting-points">Some interesting points</a></li>
<li><a href="#opportunities">Opportunities</a></li>
<li><a href="#opportunity-for-multiple-execution-models">Opportunity for multiple execution models</a></li>
<li><a href="#tricky-issues">Tricky issues</a></li>
</ul></li>
<li><a href="#stacks-1">Stacks</a></li>
</ul></li>
<li><a href="#circuit">Circuit</a><ul>
<li><a href="#m1-circuit">M1 circuit</a></li>
</ul></li>
<li><a href="#installation">Installation</a><ul>
<li><a href="#browser-compatibility">Browser compatibility</a></li>
<li><a href="#where-to-find-the-software">Where to find the software</a></li>
<li><a href="#how-to-run-sigma16">How to run Sigma16</a><ul>
<li><a href="#the-easiest-way-just-click-a-link">The easiest way: just click a link</a></li>
<li><a href="#download-and-open-file-in-browser">Download and open file in browser</a></li>
<li><a href="#run-locally-with-npm-and-electron">Run locally with npm and electron</a></li>
<li><a href="#compiling-a-standalone-executable">Compiling a standalone executable</a></li>
</ul></li>
<li><a href="#workflow-for-development">Workflow for development</a><ul>
<li><a href="#making-a-release-on-github-pages">Making a release on github pages</a></li>
<li><a href="#version-number">Version number</a></li>
<li><a href="#running-in-a-browser.">Running in a browser.</a></li>
<li><a href="#running-a-standalone-pre-compiled-executable">Running a standalone pre-compiled executable</a></li>
</ul></li>
</ul></li>
<li><a href="#about-sigma16">About Sigma16</a><ul>
<li><a href="#author">Author</a></li>
<li><a href="#license">License</a></li>
<li><a href="#implementation-of-sigma16">Implementation of Sigma16</a></li>
<li><a href="#changes-underway">Changes underway</a></li>
</ul></li>
</ul>
</nav>
<h1 id="introduction">Introduction</h1>
<p>Sigma16 is a computer architecture designed for research and teaching in computer systems. This application provides a complete environment for experimenting with the architecture, including an editor, assembler, linker, emulator, and an integrated development environment. There is a digital circuit that implements the architecture, which is specified using the Hydra functional hardware description language. Hydra can simulate the circuit, and machine language programs can run on both the emulator and the circuit.</p>
<p>This reference manual is organised by topic, with chapters on the architecture, the assembly language, and the emulator. However, it’s a good idea to begin with an overview of how the whole system works, and to be able to write and run simple programs, before delving into the details. For a quick start, begin with the tutorials, which show you how to enter and run a program and how to use the programming environment.</p>
<h1 id="tutorials">Tutorials</h1>
<p>The following short tutorials introduce the system; full details appear in later sections. You can keep the tutorials visible in the right panel while following along with the exercises in the main panel.</p>
<h3 id="hello-world">Hello, world!</h3>
<p>The Sigma16 IDE (the main “app”) is implemented in JavaScript and runs in a web browser. There are additional components to the system that must be downloaded and run on a computer; these include a digital circuit that implements the architecture and a high speed emulator. You can run the IDE simply by <a href="https://jtod.github.io/S16/dev/app/Sigma16.html">clicking a link to Launch Sigma16 to run in your browser</a>. See the <a href="https://jtod.github.io/S16/">Sigma16 Home Page</a> for further information, documentation, and executable versions. For now, we will just work with the IDE running in a browser.</p>
<p>The main window contains three main sections. The largest area, on the left side, is the <em>main working area</em>. When the program launches, this will show the Welcome page. The <em>user guide</em> is on the right side. At the top is a row of buttons (Welcome, Examples, etc.). These select which page is displayed in the main working area.</p>
<p>It’s convenient to see the main working area and the user guide side by side. Begin by resizing the entire window (bigger is better). Then you can change the amount of space given to the user guide by clicking the arrow symbols on the right side of the top button bar. These arrows will expand or shrink the user guide: the small arrows adjust by one pixel, the larger arrows by ten pixels. If you resize the entire browser window, Sigma16 will maintain the same relative sizes of the architecture and user guide sections.</p>
<p>You can also open the User Guide in a separate browser tab or window. The Welcome page contains a link to do this.</p>
<p>A good way to get started is to go through the entire process of running a simple program. For now, we focus just on how to use the software tools; an explanation of the Sigma16 architecture comes later.</p>
<p>The main working area has several pages, with buttons at the top to switch between them:</p>
<ul>
<li><p><strong>Welcome</strong> contains some introductory information, release notes, and links.</p></li>
<li><p><strong>Examples</strong> contains a collection of assembly language programs, organized by topic.</p></li>
<li><p><strong>Modules</strong> shows a summary of all the files and modules you currently have open.</p></li>
<li><p><strong>Editor</strong> shows the selected module, where it can be edited.</p></li>
<li><p><strong>Assembler</strong> translates a program from assembly language to machine language, and shows the assembly isting as well as the object code.</p></li>
<li><p><strong>Linker</strong> combines a collection of object code modles into a single executable program.</p></li>
<li><p><strong>Processor</strong> shows the components of the architecture and executes machine language programs.</p></li>
</ul>
<p>Let’s begin by running a simple example program.</p>
<ul>
<li><p>Click <strong>Editor</strong>, then <strong>Simple Example</strong>. This will enter a small assembly language program into the editor window. Later, we’ll load some of the more complex example programs into the editor, and you can also modify a program or type in a new one from scratch.</p></li>
<li><p>Click <strong>Assembler</strong> and then the <strong>Assemble</strong> button. This translates the program in the Editor page from assembly language to machine language. The <strong>Assembly Listing</strong> button displays the result of the translation, including any error messages. The <strong>Object Code</strong> button displays the output from the translation.</p></li>
<li><p>For this simple example, we don’t need the Linker, so you can skip it. The linker is needed for larger and more complex programs with multiple modules, or with external references, or that need relocation.</p></li>
<li><p>Click <strong>Processor</strong>, which shows the main components of the computer architecture, including registers and memory. These components are explained later. For now, just note that this page is where you can run programs using the emulator.</p></li>
<li><p>Still on the Processor page, click <strong>Boot</strong>. This reads the machine language program into the memory, and you can see it in the Memory display. The source code (the assembly language) appears in the bottom section.</p></li>
<li><p>Click <strong>Step</strong>. The processor executes a single instruction and displays the effects on the registers and memory: blue for using a value, and red for modifying it. The assembly listing shows the instruction that just executed by highlighting it in red. It also shows the instruction that will execute next by highlighting it in blue. This is just to make it easier to follow what is happening; the actual machine ignores the assembly language listing and doesn’t even “know” that it exists.</p></li>
<li><p>Click Step repeatedly to watch the program execute, instruction by instruction. When the program terminates, the small window labelled <strong>Emulator</strong> will display Halted.</p></li>
<li><p>To rerun the program, click Boot again.</p></li>
</ul>
<p>To exit the app, just close the browser window or tab. This should put up a dialogue box warning that any unsaved data may be lost and asking you to confirm.</p>
<h3 id="registers-and-arithmetic">Registers and arithmetic</h3>
<p>Registers are like variables in a programming language. They are even more similar to the registers in a calculator.</p>
<p>There are four arithmetic instructions, to perform addition, subtraction, multiplication, and division. (There are also a few more not discussed here.)</p>
<p>The add instruction takes the contents of two operand registers and places their sum into a destination register. It is written with the operation <em>add</em>, and the three registers separated by commas: <em>add destination,firstOperand,secondOperand</em>. For example, add R2,R5,R8 calculates the sum of R5 and R8 and places the result into R2. The effect can be described with an assignment statement: R2 := R5+R8.</p>
<p>To place a constant into a register, use the lea instruction. The destination is a register, and the operand is a constant followed by [R0]. For example, to load 42 into register 3, write</p>
<pre><code>    lea   R2,42[R0]   ; R2 := 42</code></pre>
<p>For now, just ignore the [R0], but this is a required part of the instruction. Later we’ll see why [R0] is there, along with more capabilities of the lea instruction.</p>
<pre><code>    lea   R5,3[R0]    ; R5 := 3
    lea   R8,4[R0]    ; R8 := 4
    add   R2,R5,R8    ; R2 := R5 + R8 = 3+4 = 7</code></pre>
<p>hexadecimal</p>
<p>Replace 3+4 by 23+5. Now the result is 28. The processor page shows numbers in hexadecimal, so 28 is displayed as 001c (i.e. 28 = 1*16 + 12, and the hex digit for 12 is c).</p>
<pre><code>    lea   R5,23[R0]   ; R5 := 23
    lea   R8,5[R0]    ; R8 := 5
    add   R2,R5,R8    ; R2 := R5 + R8 = 23+5 = 28 = $001c</code></pre>
<p>Further instructions</p>
<pre><code>    add   R1,R2,R3
    sub   R1,R2,R3
    mul   R1,R2,R3
    div   R1,R2,R3</code></pre>
<p>In the lea instruction, the constant value can be specified using either decimal or hexadecimal notation. Indicate hexadecimal in assembly language by putting $ before the number. Thus $00a5 and 0165 both represent the integer 165.</p>
<p>Most instructions follow a similar pattern, where the first operand is the destination where the result is placed, and the subsequent operands are the arguments to the computation. This is the same convention used in assignment statements in many programming languages: the registers in sub R1,R2,R3 appear in the same order as the varaibles in R1 := R2-R3.</p>
<p>An arithmetic instruction performs just one operation. Several instructions are needed to evaluate a larger expression, such as 7 + 10*9:</p>
<pre><code>   lea   R1,7[R0]
   lea   R2,10[R0]
   lea   R3,9[R0]
   mul   R2,R2,R3
   add   R1,R1,R2</code></pre>
<p>Generally you can use any register you like; in the previous example we could have used R12, R6, and R8 instead of R1, R2, R3. Registers R1 through R14 are all the same. However, two of the registers are different:</p>
<ul>
<li><p>R0 contains the constant 0 and it will never change. Any time an instruction uses R0, the value it gets will be 0. It is legal for an instruction to attempt to modify R0 (for example, add R0,R3,R4 is legal) but after executing this instruction R0 still contains 0. The reason for this is that we frequently need to have access to a register containing 0.</p></li>
<li><p>R15 contains a number of bits that provide some information about an instruction. For example, if an addition produces a result that is too large to fit in a register, a special flag indicating this is set in R15. Many of the instructions, including all the arithmetic instructions, change the value of R15 as well as placing the result in the destination register. For this reason, R15 cannot be used to hold a variable: its value would be destroyed almost immediately.</p></li>
</ul>
<p>To summarise, Registers R1 through R14 are all identical and can be used for variables. R0 contains 0 and will never change. R1 changes very frequently and can be used to determine various error conditions and other information about an instruction.</p>
<p>Every register contains one word of data. On the Sigma16 architecture, a word is 16 bits of data. This is enough to represent any of the following:</p>
<ul>
<li><p>An integer between ? and ?</p></li>
<li><p>A natural number between 0 and 65,535</p></li>
<li><p>A character</p></li>
</ul>
<h3 id="accessing-memory">Accessing memory</h3>
<p>Only 14 registers can be used to hold variables, but most programs need many more variables.</p>
<p>The Memory is a large set of locations</p>
<h3 id="comparisons-and-jumps">Comparisons and jumps</h3>
<h3 id="instruction-control">Instruction control</h3>
<h3 id="effective-addresses-and-arrays">Effective addresses and arrays</h3>
<h3 id="further-topics">Further topics</h3>
<p>To run the program slowly, click Step repeatedly. To run the program faster but without updating the display after each instruction, click Run. At any time you can click Pause to stop the processor, and you can resume execution with either Step or Run.</p>
<p>There are two independent views into the memory; this is convenient for looking at the machine language code in one view and the data in the other view. (Despite the two views, there is just one memory!) At this point the pc register contains 0, meaning that the next instruction to be executed is the one in memory location 0. The ir and other registers also contain 0, but that is just the initial value.</p>
<p>To set a breakpoint, click Breakpoint and enter the stopping condition in the dialogue box. For example, to stop when the pc register becomes $01b7, enter BPeq BPpc (BPhex “01b7”). Then click Run, and the emulator will run at full speed until the pc reaches the specified value; then it will stop so you can examine the state of the machine.</p>
<h1 id="architecture">Architecture</h1>
<p>An <em>instruction set architecture</em> is a precise specification of all aspects of a machine that are visible to a programmer. It includes a description of the registers, memory, data representations, and all the instructions, but does not include components of the implementation that are not visible to a machine language programmer.</p>
<h2 id="data-representation">Data representation</h2>
<p>Sigma16 is a 16-bit architecture, and every data value is a 16-bit word. Integers are represented in 16-bit two’s complement notation. The bits of a word are numbered from left to right, starting with 0. Thus the leftmost (most significant) bit of a word is bit 0, and the rightmost (least significant) is bit 15.</p>
<h2 id="register-file">Register file</h2>
<p>The <strong>register file</strong> is a set of 16 general registers that hold a 16 bit word. A register is referenced by a 4-bit binary number. In assembly language, we use the notations R0, R1, R2, …, R9, R10, R11, R12, R13, R14, R15 to refer to the registers.</p>
<p>Sigma16 is a load/store style architecture; that is, it does not combine memory accesses with arithmetic. All calculations are carried out in the register file, and explicit load and store instructions must be used to copy data between the memory and the register file.</p>
<p>There are some programming conventions that use certain registers for special purposes. The hardware does not enforce, or even know about, these conventions, and you do not have to follow the conventions in programming. However, it is necessary to obey the conventions in order to use the standard software libraries in your program. See the section on Programming for a discussion of these standard usage conventions.</p>
<h3 id="r0-holds-the-constant-0">R0 holds the constant 0</h3>
<p>One of the registers, R0, has a special property: it always contains the constant 0. It is legal to perform an instruction that attempts to load some other value into R0, but the register will still contain 0 after executing such an instruction. Such an instruction will simply have no lasting effect.</p>
<h3 id="r15-is-the-condition-code-register">R15 is the condition code register</h3>
<p>Several instructions produce status information: the result of a comparison, whether there was an overflow, etc. This information is automatically loaded into R15, which is the condition code register. The description of each instruction states whether R15 is modified, and what goes into it.</p>
<p>The bits in R15 are indexed from bit 0 (the most significant, or lefttmost bit) to bit 15 (the least significant, or rightmost). The condition code bits that have specific meanings are called <em>flags</em>.</p>
<p>Table: Condition code flags</p>
<table>
<tr>
<th>
Bit
</th>
<th>
Flag
</th>
<th>
Symbolic name
</th>
<th>
Meaning
</th>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>G</strong>
</td>
<td>
sysccG
</td>
<td>
gt (or gt 0) unsigned (binary)
</td>
</tr>
<tr>
<td>
1
</td>
<td>
<strong>g</strong>
</td>
<td>
sysccg
</td>
<td>
gt (or gt 0) signed (two’s complement)
</td>
</tr>
<tr>
<td>
2
</td>
<td>
<strong>E</strong>
</td>
<td>
sysccE
</td>
<td>
= (or =0) word, signed, unsigned
</td>
</tr>
<tr>
<td>
3
</td>
<td>
<strong>l</strong>
</td>
<td>
sysccl
</td>
<td>
lt (or lt 0) signed (two’s complement)
</td>
</tr>
<tr>
<td>
4
</td>
<td>
<strong>L</strong>
</td>
<td>
sysccL
</td>
<td>
lt (or lt 0) unsigned (binary)
</td>
</tr>
<tr>
<td>
5
</td>
<td>
<strong>V</strong>
</td>
<td>
sysccV
</td>
<td>
unsigned overflow (binary)
</td>
</tr>
<tr>
<td>
6
</td>
<td>
<strong>v</strong>
</td>
<td>
sysccv
</td>
<td>
signed overflow (two’s complement)
</td>
</tr>
<tr>
<td>
7
</td>
<td>
<strong>C</strong>
</td>
<td>
sysccC
</td>
<td>
carry propagation (binary)
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</table>
<p>The condition code flags are defined to make the condition code easier to read in hex:</p>
<ul>
<li><p>The first (leftmost) hex digit holds the comparison flags</p></li>
<li><p>The second hex digit holds the carry and overflow flags</p></li>
<li><p>The third hex digit holds the stack error flags</p></li>
</ul>
<p>conditional jump</p>
<p>jumpc0 jump if cc bit is 0 jumpc1 jump if cc bit is 1</p>
<h2 id="memory">Memory</h2>
<p>The memory is a hardware array of words that are accessed by address. A memory address is 16 bits wide, and there is one memory location corresponding to each address, so there are 2^16 = 64k memory locations. Each memory location is a 16-bit word.</p>
<h3 id="effective-address">Effective address</h3>
<p>The effective address is defined to be the binary sum of the displacement and the index register.</p>
<h2 id="instruction-control-registers">Instruction control registers</h2>
<p>There are several <strong>program control registers</strong> that enable the processor to keep track of the state of the running program. These registers are rarely used directly by the machine language program, but they are essential for keeping track of the execution of the program, and some instructions use them directly.</p>
<ul>
<li><p>ir – instruction register (16-bit word)</p></li>
<li><p>pc – program counter (16-bit word)</p></li>
<li><p>adr – address register (16-bit word)</p></li>
<li><p>dat – data register (16-bit word)</p></li>
<li><p>status – collection of control flags</p></li>
</ul>
<h3 id="status-register-flags">Status register flags</h3>
<p>The processor can be executing in several modes, which are determined by the <strong>system control registers</strong>.</p>
<ul>
<li><p>sys (bit 0) – system state (1-bit flag)</p></li>
<li><p>ie (bit 1) – interrupts enabled (1-bit flag)</p></li>
</ul>
<p>Table: Processor status flags</p>
<table>
<tr>
<th>
Bit
</th>
<th>
Flag
</th>
<th>
Meaning
</th>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>U</strong>
</td>
<td>
User state
</td>
</tr>
<tr>
<td>
1
</td>
<td>
<strong>E</strong>
</td>
<td>
Interrupts enabled
</td>
</tr>
</table>
<h2 id="interrupts-and-exceptions">Interrupts and exceptions</h2>
<ul>
<li><p>imask</p></li>
<li><p>ireq</p></li>
<li><p>istatus</p></li>
<li><p>ipc</p></li>
<li><p>ivect</p></li>
</ul>
<h3 id="mask-and-request-flags">Mask and request flags</h3>
<table>
<tr>
<th>
Bit
</th>
<th>
Flag
</th>
<th>
Meaning
</th>
</tr>
<tr>
<td>
0
</td>
<td>
Trap
</td>
<td>
Trap
</td>
</tr>
<tr>
<td>
0
</td>
<td>
Trap
</td>
<td>
Trap
</td>
</tr>
<tr>
<td>
1
</td>
<td>
Overflow
</td>
<td>
Trap
</td>
</tr>
<tr>
<td>
2
</td>
<td>
Div0
</td>
<td>
Trap
</td>
</tr>
<tr>
<td>
3
</td>
<td>
StackFault
</td>
<td>
Trap
</td>
</tr>
<tr>
<td>
4
</td>
<td>
SegFault
</td>
<td>
Trap
</td>
</tr>
<tr>
<td>
5
</td>
<td>
Privelege
</td>
<td>
Trap
</td>
</tr>
<tr>
<td>
6
</td>
<td>
Timer
</td>
<td>
Interrupt
</td>
</tr>
<tr>
<td>
7
</td>
<td>
Input
</td>
<td>
Interrupt
</td>
</tr>
<tr>
<td>
8
</td>
<td>
Output
</td>
<td>
Interrupt
</td>
</tr>
</table>
<h2 id="instruction-representation">Instruction representation</h2>
<p>There are three instruction formats:</p>
<ul>
<li><p>RRR – (1 word) Instructions that perform operations on data in registers, but not referring to memory.</p></li>
<li><p>RX – (2 words) Instructions that specify a memory location, as well as a register operand.</p></li>
<li><p>EXP – (2 words) Expanded (or experimental) instructions, for instructions that cannot be encoded as RRR or RX.</p></li>
</ul>
<p>The first word of an instruction contains four 4-bit fields, named op (bits 0-3), d (bits 4-7), sa (bits 8-11), and sb (bits 12-15).</p>
<table class="wordlayout"">
 <tr>
  <th>op</th>
  <th>d</th>
  <th>a</th>
  <th>b</th>
 </tr>
 <tr>
  <td>0-3</td>
  <td>4-7</td>
  <td>8-11</td>
  <td>12-15</td>
 </tr>
</table>
<p>Each instruction has a 4-bit field called the opcode (op for short). This gives 16 values of the opcode: 14 of them (0 through 13) denote the 14 RRR instructions. If the op field is 14 (hex e) the instruction is EXP format and has a secondary opcode in the a and b fields. If the op field contains 15 (hex f) the instruction is RX format with a secondary opcode in the b field.</p>
<h3 id="rrr-format">RRR format</h3>
<p>An RRR instruction contains an operation code (op), and specifies three operands registers using the d, sa, and sb fields. It is represented as one word, which is divided into four fields:</p>
<ul>
<li>op (4 bits, starting from bit 0) Operation code
<ul>
<li>d (4 bits, starting from bit 4) Destination register</li>
<li>sa (4 bits, starting from bit 8) Source a register</li>
<li>sb (4 bits, starting from bit 12) Source b register</li>
</ul></li>
</ul>
<table class="wordlayout"">
  <tr>
    <th>op</th>
    <th>d</th>
    <th>a</th>
    <th>b</th>
  </tr>
  <tr>
    <td>d</td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
  </tr>
  <tr>
    <td>0-3</td>
    <td>4-7</td>
    <td>8-11</td>
    <td>12-15</td>
  </tr>
</table>
<p>The op field of an RRR instruction must be in the range from 0 through 13 (hex 0 through d). This allows for a total of 14 distinct RRR instructions. If the op field is outside this range, it indicates an “expanding opcode”: 14 (hex e) indicates the EXP format, and 15 (hex f) indicates the RX format.</p>
<p>A RRR instruction is written with an instruction name (menonic) and three register operands. For example, the “trap” instruction has mnemonic 13 (and the hex value of 13 is d), so the assembly language “trap R4,R12,R2” is translated to machine language as d4c2.</p>
<p>In most cases, an RRR instruction takes two operands in registers specified by the a and b fields and produces a result which is loaded into the register specified by the d field. A typical example of an RRR instruction is add R4,R9,R2, which adds the contenst of registers R9 and R2, and loads the result into R4. It’s equivalent to R4 := R9 + R2.</p>
<h3 id="rx-format">RX format</h3>
<p>The RX instruction format is used for instructions that use a memory address, which is specified by an index register and a displacement. The name of the format describes briefly the two operands: a register (R) and an indexed memory address (X).</p>
<p>An RX instruction contains two operands: one is a memory address, and the other is a register. Typical RX instructions are loads, stores, and jumps. The instruction consists of two consecutive words. The first has the same format as an RRR instruction, with four fields: op, d, sa, sb. The second word is a single 16-bit binary number, and is called the displacement.</p>
<p>The memory address is specified in two parts: an index register and the displacement. The index register is specified in the sa field. In assembly language, the notation used is number[reg], where the number is the value of the displacement, and the reg is the index register. Thus $20b3[R2] means the address has displacement $20b3 and the index register is R2.</p>
<p>When the machine executes an RX instruction, it begins by calculating the effective address. This is abbreviated “ea”, and its value is the sum of the displacement and the contents of the index register.</p>
<p>RX instructions are represented in two words, and they use an “expanding opcode”. That is, the op field of the first word of the instruction contains the constant f (the bits 1111) for every RX instruction, and the sb field is used to hold a secondary opcode indicating which RX instruction it is.</p>
<p>The register operand is specified in the d field. For several RX instructions, this is indeed the destination of the instruction: for example, load places data into Rd. However, a few RX instructions use the d field differently (see, for example, the conditional jump instructions).</p>
<p>The memory address is specified using the sa field and the displacement, which is the entire second word of the instruction.</p>
<ul>
<li>op field (bits 0-3 of ir) is f for all RX instructions
<ul>
<li>d field (bits 4-7 of ir) has several uses</li>
<li>a field (bits 8-11 of ir) is index register for effective address</li>
<li>b field (bits 12-15 of ir) is secondary opcode</li>
<li>disp (displacement) is the second word of the instruction</li>
<li>ea (effective address) = displacement + r[a]</li>
</ul></li>
</ul>
<h3 id="exp-format">EXP format</h3>
<p>The EXP instruction format is used for expanded instructions cannot be represented using the RRR or RX formats. It provides many unused opcodes, so it is useful for experimental instructions.</p>
<p>An EXP instruction consists of two words. The first word has a constant hex e in the op field, which indicates the EXP format. The a and b fields together form an 8-bit secondary opcode, allowing for 256 distinct EXP instructions. The d field in the first word, and all of the second word, hold operands which depend on the particular instruction.</p>
<p>First word of the instruction</p>
<table class="wordlayout"">
<tr>
<th>op</th>
<th>d</th>
<th>a</th>
<th>b</th>
</tr>
<tr>
<td>0-3</td>
<td>4-7</td>
<td>8-11</td>
<td>12-15</td>
</tr>
</table>
<p>Second word of the instruction</p>
<table class="wordlayout"">
  <tr>
    <th>p</th>
    <th>q</th>
    <th>r</th>
    <th>s</th>
  </tr>
  <tr>
    <td>0-3</td>
    <td>4-7</td>
    <td>8-11</td>
    <td>12-15</td>
  </tr>
</table>
<h2 id="summary-of-notation">Summary of notation</h2>
<p>ea m[ea] r[d] r[a] r[b] q#r[d] lsb q</p>
<h1 id="instruction-set">Instruction set</h1>
<p>The following sections describe the instructions in groups organized by their function. Some of the groups contain instructions with different formats. From the programmer’s perspective the function is more important, so these groups are useful in finding the right instruction to use. (From the perspective of designing a digital circuit to impleemnt the architecture, the format is essential.)</p>
<h2 id="arithmetic-instructions">Arithmetic instructions</h2>
<p>The add instruction can be used for both binary addition (on natural numbers) and for two’s complement addition (on signed integers).</p>
<ul>
<li><p>16-bit natural numbers are unsigned integers 0, 1, 2, …, 65535. If two natural numbers are added, the result is a natural number (the result cannot be negative). If the result is 65536 or larger, it cannot be represented as a 16 bit binary number. If this happens, the destination register is set to the lower 16 bits of the true result, and the binary overflow flag is set in the Condition Code.</p></li>
<li><p>16-bit two’s complement numbers are signed integers -32999?, …, -1, 0, 1, …, 32???. If two signed integers are added, the result is a signed integer. If the result is less than -32000 or greater than 32000, then the result cannot be represented as a 16 bit two’s complement number. If this happens, the destination register is set to the lower 16 bits of the true result, and the two’s complement overflow flag is set in the Condition Code. Furthermore, the overflow flag is set in the req register. If interrupts are enabled and the overflow flag is 1 in the mask register, then an interrupt will occur immediatelhy after the add instruction executes.</p></li>
</ul>
<h3 id="add">add</h3>
<p>The instruction add Rz,Rx,Ry has operands Rx and Ry and destination Rz. It fetches the operands reg[x] and reg[y], calculates the sum reg[x] + reg[y], and loads the result into the destination reg[z]. The effect is reg[z] := reg[x] + reg[y]. For example, add R5,R12,R2 performs R5 := R12 + R3.</p>
<p>The add instruction is RRR format with opcode=0. Given destination z and operands x and y (where z, x, y are hex digits), add Rz,Rx,Ry is reprseented by 0zxy.</p>
<table>
<thead>
<tr class="header">
<th>de As</th>
<th>sembly Ef</th>
<th style="text-align: left;">fect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>062c</td>
<td>add R6,R2,R12</td>
<td style="text-align: left;">; R6 := R2 + R12</td>
</tr>
<tr class="even">
<td>0d13</td>
<td>add R13,R1,R3</td>
<td style="text-align: left;">; R13 := R1 + R3</td>
</tr>
</tbody>
</table>
<p>In addition to setting the destination register, the add instruction sets several bits in the condition code R15 and may set a bit in the req register.</p>
<table style="width:46%;">
<colgroup>
<col style="width: 15%" />
<col style="width: 30%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">R15.ccG R15.ccg := R15.ccE := R15.ccl := R15.CCL := R15.ccV := R15.CCv := R15.CCc :=</td>
<td style="text-align: center;">:= result &gt;bin 0 result &gt;tc 0 result = 0 result &lt;tc 0 0 bin overflow tc overflow carry output</td>
</tr>
<tr class="even">
<td style="text-align: center;">### sub</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">sub R1,R2,R</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: center;">### mul</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">### div</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">### addc</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">## Accessin</td>
<td style="text-align: center;">g memory</td>
</tr>
<tr class="even">
<td style="text-align: center;">### Effecti</td>
<td style="text-align: center;">ve address</td>
</tr>
<tr class="odd">
<td style="text-align: center;">### lea</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">The effecti displacemen</td>
<td style="text-align: center;">ve address is defined to be the binary sum of the t and the index register.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">### load</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">Load copies destination</td>
<td style="text-align: center;">the word in memory at the effective address into the register.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">general for</td>
<td style="text-align: center;">m: load Rd,disp[Ra]</td>
</tr>
<tr class="even">
<td style="text-align: center;">effect: reg</td>
<td style="text-align: center;">[Rd] := mem[disp+reg[Ra]]</td>
</tr>
<tr class="odd">
<td style="text-align: center;">format: RX</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">load R load R load R</td>
<td style="text-align: center;">12,count[R0] ; R12 := count 6,arrayX[R2] ; R6 := arrayX[R2] 3,$2b8e[R5] ; R3 := mem[2b8e+R5]</td>
</tr>
<tr class="odd">
<td style="text-align: center;">### store</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">Store copie effective a "destinatio destination</td>
<td style="text-align: center;">s the word in the destination register into memory at the ddress. Unlike most instructions, store treats the n register" as the source of data, and the actual is the memory location.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">general effect: format:</td>
<td style="text-align: center;">form: store Rd,disp[Ra] mem[disp+reg[Ra]] := reg[Rd] RX</td>
</tr>
<tr class="even">
<td style="text-align: center;">store store store</td>
<td style="text-align: center;">R3,$2b8e[R5] R12,count[R0] R6,arrayX[R2]</td>
</tr>
<tr class="odd">
<td style="text-align: center;">### save</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">### restore</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">### push</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">push R1</td>
<td style="text-align: center;">,R2,R3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">R1 = va R2 = st R3 = st</td>
<td style="text-align: center;">lue to push onto stack in memory ack top ack limit</td>
</tr>
<tr class="even">
<td style="text-align: center;">Push the wo stack is fu in the cond will occur</td>
<td style="text-align: center;">rd in R1 onto a stack with top R2 and limit R3. If the ll, nothing is stored into memory and an error is indicated ition code and interrupt request registers; an interrupt if interrupts are enabled and the stack mask bit is set.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Push has th</td>
<td style="text-align: center;">e following semantics:</td>
</tr>
<tr class="even">
<td style="text-align: center;">if R2&lt;R then else</td>
<td style="text-align: center;">3 R2 := R2+1; mem[R2] := R1 R15.sovfl := 1, req.StackBounds := 1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">If R2=R3 th no space to does not st doesn’t ove indicates a in the cond the interru stack fault interrupt w will be no bit is not</td>
<td style="text-align: center;">is means the stack completely fills the block, and there is store a new element. In this case, the push instruction ore R1: it doesn’t modify memory outside the block, and it rwrite data in the stack. Instead, the instruction stack overflow by setting the sovfl (stack overflow) bit ition code (R15), and it also sets the stack fault bit in pt request register. If interrupts are enabled and the bit is set in the interrupt mask register, then an ill occur after the push instruction completes. But there interrupt if interrupts are disabled, or the stack fault set in the mask register.</td>
</tr>
<tr class="even">
<td style="text-align: center;">Push is an</td>
<td style="text-align: center;">EXP format instruction comprising two words:</td>
</tr>
</tbody>
</table>
<p>op d a b<br />
<strong>e</strong> R1 <strong>5</strong><br />
0-2 3-6 7-10 11-15<br />
—— —— —— ——</p>
<h3 id="pop">pop</h3>
<p>The pop instruction removes the top element from a stack and loads it into the destination register. (See push for a description of representation of a stack.)</p>
<p>pop R1,R2,R3</p>
<p>R1 = value popped from stack R2 = stack top R3 = stack base</p>
<p>if R2&gt;R3 then R1 := mem[R2]; R2 := R2 - 1 else R15.StackUnderflow := 1, req.StackBounds := 1</p>
<h3 id="top">top</h3>
<p>top R1,R2,R3</p>
<p>R1 = value of top of stack R2 = stack top R2 = stack base</p>
<p>if R2&gt;R2 then R1 := mem[R1] else R15.StackEmpty := 1, req.StackBounds := 1</p>
<h2 id="comparisons">Comparisons</h2>
<h3 id="condition-codes-and-booleans">Condition codes and booleans</h3>
<h3 id="cmplt">cmplt</h3>
<h3 id="cmpeq">cmpeq</h3>
<h3 id="cmpgt">cmpgt</h3>
<h3 id="cmp">cmp</h3>
<h2 id="jumps">Jumps</h2>
<h3 id="jump">jump</h3>
<h3 id="jumpf">jumpf</h3>
<h3 id="jumpt">jumpt</h3>
<h3 id="jumpc0">jumpc0</h3>
<h3 id="jumpc1">jumpc1</h3>
<h3 id="jal">jal</h3>
<h3 id="aliases-for-conditional-jumps">Aliases for conditional jumps</h3>
<h2 id="bits-and-booleans">Bits and Booleans</h2>
<h3 id="inv">inv</h3>
<h3 id="and">and</h3>
<h3 id="or">or</h3>
<h3 id="xor">xor</h3>
<h3 id="shiftl">shiftl</h3>
<h3 id="shiftr">shiftr</h3>
<h3 id="getbit">getbit</h3>
<h3 id="getbitinv">getbitinv</h3>
<h3 id="putbit">putbit</h3>
<h3 id="putbitinv">putbitinv</h3>
<h3 id="extract">extract</h3>
<h3 id="execute">execute</h3>
<h2 id="system-control">System control</h2>
<h3 id="trap">trap</h3>
<h3 id="getctl">getctl</h3>
<h3 id="putctl">putctl</h3>
<h3 id="rfi">rfi</h3>
<h2 id="summary-of-the-instruction-set">Summary of the instruction set</h2>
<p>The following table shows the complete instruction set. The instructions are in order of increasing operation code.</p>
<hr />
<table style="width:67%;">
<colgroup>
<col style="width: 12%" />
<col style="width: 9%" />
<col style="width: 6%" />
<col style="width: 9%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr class="header">
<th>Mnemonic</th>
<th>Format</th>
<th style="text-align: left;">Op</th>
<th>Notes</th>
<th style="text-align: left;">Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>add</td>
<td>RRR</td>
<td style="text-align: left;">0</td>
<td>E</td>
<td style="text-align: left;">r[d] := r[a] + r[b] signed +</td>
</tr>
<tr class="even">
<td>sub</td>
<td>RRR</td>
<td style="text-align: left;">1</td>
<td>E</td>
<td style="text-align: left;">r[d] := r[a] - r[b] signed -</td>
</tr>
<tr class="odd">
<td>mul</td>
<td>RRR</td>
<td style="text-align: left;">2</td>
<td></td>
<td style="text-align: left;">rem#r[d] := r[a] * r[b] signed *</td>
</tr>
<tr class="even">
<td>div</td>
<td>RRR</td>
<td style="text-align: left;">3</td>
<td>E</td>
<td style="text-align: left;">r[d] := r[a] div r[b], R15 := r[a] rem r[b]</td>
</tr>
<tr class="odd">
<td>cmplt</td>
<td>RRR</td>
<td style="text-align: left;">4</td>
<td></td>
<td style="text-align: left;">r[d] := r[a] &lt; r[b]</td>
</tr>
<tr class="even">
<td>cmpeq</td>
<td>RRR</td>
<td style="text-align: left;">5</td>
<td></td>
<td style="text-align: left;">r[d] := r[a] = r[b]</td>
</tr>
<tr class="odd">
<td>cmpgt</td>
<td>RRR</td>
<td style="text-align: left;">6</td>
<td></td>
<td style="text-align: left;">r[d] := r[a] &gt; r[b]</td>
</tr>
<tr class="even">
<td>cmp</td>
<td>RRR</td>
<td style="text-align: left;">7</td>
<td></td>
<td style="text-align: left;">R15 := comparison result (both signed, unsigned)</td>
</tr>
<tr class="odd">
<td>inv</td>
<td>RRR</td>
<td style="text-align: left;">8</td>
<td></td>
<td style="text-align: left;">r[d] := inv r[a]</td>
</tr>
<tr class="even">
<td>and</td>
<td>RRR</td>
<td style="text-align: left;">9</td>
<td></td>
<td style="text-align: left;">r[d] := r[a] and r[b]</td>
</tr>
<tr class="odd">
<td>or</td>
<td>RRR</td>
<td style="text-align: left;">a</td>
<td></td>
<td style="text-align: left;">r[d] := r[a] or r[b]</td>
</tr>
<tr class="even">
<td>xor</td>
<td>RRR</td>
<td style="text-align: left;">b</td>
<td></td>
<td style="text-align: left;">r[d] := r[a] xor r[b]</td>
</tr>
<tr class="odd">
<td></td>
<td>RRR c</td>
<td style="text-align: left;"></td>
<td></td>
<td style="text-align: left;">reserved; currently nop</td>
</tr>
<tr class="even">
<td>trap</td>
<td>RRR</td>
<td style="text-align: left;">d</td>
<td>E</td>
<td style="text-align: left;">xa := pc, pc := 0</td>
</tr>
<tr class="odd">
<td>lea</td>
<td>RX</td>
<td style="text-align: left;">f,0</td>
<td></td>
<td style="text-align: left;">r[d] := ea</td>
</tr>
<tr class="even">
<td>load</td>
<td>RX</td>
<td style="text-align: left;">f,1</td>
<td>E</td>
<td style="text-align: left;">r[d] := m[ea]</td>
</tr>
<tr class="odd">
<td>store</td>
<td>RX</td>
<td style="text-align: left;">f,2</td>
<td>E</td>
<td style="text-align: left;">m[ea] := r[d]</td>
</tr>
<tr class="even">
<td>jump</td>
<td>RX</td>
<td style="text-align: left;">f,3</td>
<td>E</td>
<td style="text-align: left;">pc := ea</td>
</tr>
<tr class="odd">
<td>jumpc0</td>
<td>RX</td>
<td style="text-align: left;">f,4</td>
<td></td>
<td style="text-align: left;">if r[15] AND d == 0 then pc := ea</td>
</tr>
<tr class="even">
<td>jumpc1</td>
<td>RX</td>
<td style="text-align: left;">f,5</td>
<td></td>
<td style="text-align: left;">if r[R15] AND d /= 0 then pc := ea</td>
</tr>
<tr class="odd">
<td>jumpf</td>
<td>RX</td>
<td style="text-align: left;">f,6</td>
<td>E</td>
<td style="text-align: left;">if not r[d] then pc := ea</td>
</tr>
<tr class="even">
<td>jumpt</td>
<td>RX</td>
<td style="text-align: left;">f,7</td>
<td>E</td>
<td style="text-align: left;">if r[d] then pc := ea</td>
</tr>
<tr class="odd">
<td>jal</td>
<td>RX</td>
<td style="text-align: left;">f,8</td>
<td>E</td>
<td style="text-align: left;">r[d] := pc, pc := ea</td>
</tr>
<tr class="even">
<td>trap</td>
<td>RRR</td>
<td style="text-align: left;">d</td>
<td>E</td>
<td style="text-align: left;">xa := pc, pc := 0</td>
</tr>
<tr class="odd">
<td>lea</td>
<td>RX</td>
<td style="text-align: left;">f,0</td>
<td></td>
<td style="text-align: left;">r[d] := ea</td>
</tr>
<tr class="even">
<td>load</td>
<td>RX</td>
<td style="text-align: left;">f,1</td>
<td>E</td>
<td style="text-align: left;">r[d] := m[ea]</td>
</tr>
<tr class="odd">
<td>store</td>
<td>RX</td>
<td style="text-align: left;">f,2</td>
<td>E</td>
<td style="text-align: left;">m[ea] := r[d]</td>
</tr>
<tr class="even">
<td>jump</td>
<td>RX</td>
<td style="text-align: left;">f,3</td>
<td>E</td>
<td style="text-align: left;">pc := ea</td>
</tr>
<tr class="odd">
<td>jumpf</td>
<td>RX</td>
<td style="text-align: left;">f,4</td>
<td>E</td>
<td style="text-align: left;">if not r[d] then pc := ea</td>
</tr>
<tr class="even">
<td>jumpt</td>
<td>RX</td>
<td style="text-align: left;">f,5</td>
<td>E</td>
<td style="text-align: left;">if r[d] then pc := ea</td>
</tr>
<tr class="odd">
<td>jal</td>
<td>RX</td>
<td style="text-align: left;">f,6</td>
<td>E</td>
<td style="text-align: left;">r[d] := pc, pc := ea</td>
</tr>
<tr class="even">
<td>test</td>
<td>EXP</td>
<td style="text-align: left;"></td>
<td></td>
<td style="text-align: left;">r[d] := r[a] [bit b]</td>
</tr>
<tr class="odd">
<td>addl</td>
<td>EXP</td>
<td style="text-align: left;">e,0a</td>
<td></td>
<td style="text-align: left;">rem#r[d] := r[a] + r[b] + lsb rem</td>
</tr>
<tr class="even">
<td>shiftl</td>
<td>RRR</td>
<td style="text-align: left;">b</td>
<td></td>
<td style="text-align: left;">rem#r[d] := r[a] shl b</td>
</tr>
<tr class="odd">
<td>shiftr</td>
<td>RRR</td>
<td style="text-align: left;">c</td>
<td></td>
<td style="text-align: left;">rem#r[d] := r[a] shr b</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="assembly-language">Assembly Language</h1>
<p>A computer is a digital circuit that executes programs in machine language, which is hard for humans to read because it consists entirely of numbers. Assembly language provides a readable notation for writing machine language programs. It uses names for instructions and variables, as well as other notations to make the code easier to understand.</p>
<p>An instruction in machine language is just one or more words (often written in hexadecimal notation), while the corresponding instruction in assembly language uses mnemonic names so the programmer doesn’t have to memorise all the operation codes, addresses of variables, and so on. For example, the assembly language statement mul R12,R3,R8 is more readable than the corresponding machine language instruction 2c38. However, the assembly language still gives the programmer complete control over every bit a program.</p>
<p>Each line of source code is an assembly language statement. Unlike higher level languages, assembly language statements are not nested. There are three kinds of assembly language statement:</p>
<ul>
<li><p>Most statements specify either an instruction or some constant data.</p></li>
<li><p>Some statements are full line comments.</p></li>
<li><p>Other statements are <em>directives</em>, which control the behavior of the assembler but don’t generate any code.</p></li>
</ul>
<h2 id="notation">Notation</h2>
<p>A name must begin with a letter (a-z or A-Z), and may contain letters, digits, or underscore characters.</p>
<p>Constants can be written in decimal, hexadecimal, or binary:</p>
<ul>
<li><p>Decimal constants consist of a sequence of digits, with an optional leading - sign. Examples: 42 55039 -1</p></li>
<li><p>Hexadecimal constants are written with a dollar sign $ followed by four hex digits (0 1 2 3 4 5 6 7 8 9 a b c d e f). Examples: $0249 $c78a</p></li>
<li><p>Binary constants are written with a hash sign # followed by any number of 0 or 1 characters. You can write fewer than 16 bits; they will be padded on the left with zeros. Examples: #1101 #000100000001101</p></li>
</ul>
<p>An expression denotes a 16-bit word. Usually they are used to specify a word of machine language, either an address or a data constant.</p>
<h2 id="statement-formats">Statement formats</h2>
<p>A statement may contain several fields. A field consists of non-space characters (with one exception: a space may appear in a string literal). Fields are separated from each other by one or more white space characters.</p>
<ul>
<li><p>Label. The label field is optional. If present, the label must be a name and it must begin in the first character of the line. If the first character is a space, then that line has no label.</p>
<ul>
<li><p>Operation. The operation field specifies an instruction or assembler directive. It must be preceded by one or more white space characters. Every statement (apart from a full line comment) must have an operation field, which must be a name.</p></li>
<li><p>Operands. The operands field specifies operands for an instruction or arguments for assembly directive. Most instructions and assembler directives require operands, but some do not.</p></li>
<li><p>Comment. All text that follows white space after the operands field is a comment, and is ignored by the assembler. If one or more of the other fields (label, operation, operands) is missing, the comment must be preceded by a semicolon to prevent it from being interpreted as operands. The rule is: all text after a semicolon is a comment, and all text after white space following operands is a comment. A statement where the first non-space character is a semicolon is a full line comment. If the statement has no operands, then all text after the operation field is a comment. It is good practice always to begin a comment with a semicolon.</p></li>
</ul></li>
</ul>
<h2 id="instructions">Instructions</h2>
<h2 id="directives">Directives</h2>
<p>A directive is an assembly language statement that doesn’t generate an instruction, but which gives further information about how to translate the program to object code.</p>
<p>Directive formats</p>
<pre><code>ASMDIR    operand:    xyz module
ASMDIRX   expression  org 234
ASMDIRNS  list of names   import m1,m2 export a,b,c</code></pre>
<pre><code>abc        Module
x          import   Mod1
y          import   Mod1
z          import   Mod2
           export   x,y,z
           org      34
           org      $02bf
           org      *+100
codeWrite  equ  2
codeRead   equ  1

astart     data 5
           data 9
           data 78
aend
asize      equ  aend-astart</code></pre>
<h4 id="expressions">Expressions</h4>
<p>An expression may be used in a directive (e.g. org xyz) or in an instruction (e.g. lea R2,aend-astart[R0]).</p>
<p>Expressions are useful in professional systems programming. However, they can easily confuse beginners. It is essential to understand that the arithmetic in an expression is evaluated at assembly time, not at run time. It’s a good idea not even to mention expressions in the early stages of teaching computer systems.</p>
<p>Consider how expressions are evaluated. If an expression is used to define size of a block of memory, its value would need to be known before any labels appearing after the block can be resolved. This could lead to unnecessary complexity.</p>
<ul>
<li><p>A simple and clean rule is that an org statement must be of the form constant or <em>+constant, but </em>+label is disallowed. The principle is that a first pass through the assembly source code must resolve the values of all names. But this is needlessly restrictive.</p></li>
<li><p>The important point is that during the second pass it should be possible to evaluate all expressions without backtracking. This can be achieved by another approach: simply to disallow forward references in expressions. For example this could be allowed</p></li>
</ul>
<pre><code>a  equ  123
...
   org  *+a</code></pre>
<p>An expression may be</p>
<ul>
<li><p>A literal constant</p></li>
<li><p>An identifier defined within the module</p></li>
<li><p>The sum of a local relocatable epression and a constant</p></li>
<li><p>The difference between two local locatable expressions</p></li>
<li><p>An identifier imported from another module. In this case, the expression may not contain any operators or other terms: the entire expression must just be that identifier.</p></li>
</ul>
<h4 id="module">module</h4>
<p>A program may be organized as a collection of modules, where each module appears in a separate file. When several modules are present, each one needs a unique name. The purpose of the module statement is to specify this name.</p>
<p>A small program can be written as just one module, and it may have a module name but this is not required.</p>
<p>The module statement defines the name of a module. The statement is optional. If present, it must be the first statement in the program, apart from full line comments and blank lines. A file may contain only one module statement, and if the statement “MyModuleName module” is present the file name should be MyModuleName.asm.txt.</p>
<p>Examples</p>
<p>quicksort module main module myprog module</p>
<h3 id="org">org</h3>
<p>The org statement specifies where in memory instructions and data should be placed when the program is booted. It takes an operand consisting of a word value, and it sets the location counter to this value.</p>
<p>Examples</p>
<p>org $0f20 ; subsequent instructions start from 0f20 org *+50 ; skip 50 words</p>
<p>The assembler initializes the location counter to 0 before it begins translating an assembly language module. This means that, in effect, every module begins with org 0.</p>
<h3 id="import">import</h3>
<p>The import statement states that the value of an identifier is defined in another module. During the assembly of the module containing the import, the identifier is given a provisional value of 0, but this will be replaced by the actual value by the linker. For example,</p>
<pre><code>    x          import   Mod1</code></pre>
<p>a</p>
<p>says that x is a name that can be used in this module, but it is defined in Mod1 and its actual value will remain unknown until the linker sets it later on.</p>
<h3 id="export">export</h3>
<p>The export statement states that the value of an identifier should be made available for other modules to import. For example, this module defines a function and exports it so other modules can import and call it:</p>
<pre><code>Mod1     module
         export fcn

fcn      add    R1,R1,R1
         jump   0[R12]</code></pre>
<h3 id="equ">equ</h3>
<pre><code>trapWrite   equ  2</code></pre>
<h2 id="assembly-listing">Assembly listing</h2>
<p>The first section of the assembly listing shows each line of the source program. The line number appears first, followed by the memory address that the instruction on this line will be placed in. The address is given as a 4 digit hexadecimal number, and it is binary (not two’s complement). Next comes the machine language code generated by the line of source code. If the line contains a two-word instruction, there will be two 4-digit hexadecimal values; for a one-word instruction there will be one hex number, and if the line doesn’t produce any code these fields will be blank. After the code, the original source statement appears.</p>
<p>The second section of the assembly listing is the <em>Symbol Table</em>. This shows each identifier (or “symbol”) that appears in the program, the address allocated for the symbol, the source code line where it was defined, and the source code lines where it was used.</p>
<h1 id="linker">Linker</h1>
<p>The assembler doesn’t translate a source module in assembly langauge directly to raw machine language. Instead, it produces an <em>object module</em> which contains some additional metadata along with the machine language code. This metadata enables the linker to combine the object module with other modules into an <em>executable module</em>.</p>
<h2 id="object-code">Object code</h2>
<p>Ojbect modules are specified in an object code language with a simple syntax and only a few types of statement. Each object statement is written on line line. It begins with a keyword indicating the type of statement, followed by white space, followed by an operand which must not contain any spaces. Operands may contain either hex constants or identifiers.</p>
<ul>
<li><p>In the object language, hex constants are written as four characters, using digits 0-9 a-f. Unlike assembly language, a hex constant is not preceded by $.</p></li>
<li><p>Identifiers have the same syntax as in assembly language: a string of letters, digits, and underscore characters, beginning with a letter.</p></li>
</ul>
<p>The object language has six statements: module, org, data, import, export, and relocate. These are related to corresponding statements in assembly language, but their syntax is different. For example, an import statement in assembly language will generate one or more import statements in the object code, but those statements have a different syntax and contain different information.</p>
<h3 id="module-statement">module statement</h3>
<p>Declare the name of the module. The argument must be an indentifier. The following statement says that this is the object code for module named abc.</p>
<pre><code>module abc</code></pre>
<h3 id="org-statement">org statement</h3>
<p>The org statement sets the location counter to a specified address. Currently the argument must be a a 4-digit hexadecimal constant, such as 3b9f.</p>
<pre><code>org  0a04</code></pre>
<h3 id="data-statement">data statement</h3>
<p>The data statement specifies a sequence of constants to be placed in consecutive memory locations starting at the location counter, subject to relocation. Its argument is a list of one or more 4-digit hex constants separated by commas.</p>
<p>A long block of data can be broken up into several data statements. Suppose x1, x2, etc are 4-digit hex constants. Then</p>
<pre><code>data  x1,x2,x3,x4,x5,x6</code></pre>
<p>is equivalent to</p>
<pre><code>data x1,x2,x3
data x4,x5,x6</code></pre>
<p>Suppose</p>
<ul>
<li><p>The module’s relocation constant is r</p></li>
<li><p>The location counter has been set to c</p></li>
<li><p>The i’th constant (counting from 0) in a data statement is x.</p></li>
</ul>
<p>Then the linker will set mem[r+c+i] := x.</p>
<p>One point to watch out for is that an assembly language data statement uses $ to indicate that a number is a hex constant (e.g. $03b7) but the object language data statement requires all numbers to be 4-digit hex constants, and does not require (or allow) a preceding $ character</p>
<h3 id="import-statment">import statment</h3>
<pre><code>import mod3,sqr,addr,addr,...</code></pre>
<h3 id="export-statement">export statement</h3>
<p>An export statement says that the module is making the value of a symbol available for use in other modules, which may import it. The statement takes two operands: the name being exported and the value, which must be a 4-digit hex constant. It makes no difference whether the name is relocatable, as the linker performs any relocation before writing the exported value into other modules that import it. Examples:</p>
<pre><code>export  haltcode,0
export  fcn,002c</code></pre>
<h3 id="relocate-statement">relocate statement</h3>
<p>The relocate statement specifies a list of addresses of words that must be relocated. Suppose the value x is specified in a relocate statement, and the linker is relocating the module by offset y. Then the linker will set mem[x+y] = obj[x]+y.</p>
<pre><code>relocate hex4,hex4,...</code></pre>
<h2 id="executable-code">Executable code</h2>
<p>An executable module is written in the same language as object modules. The only difference is that an executable module must contain only these types of statement: module, data, org. It is now allowed to contain any of the following statments: import, export, relocate.</p>
<p>If an assembly language program doesn’t contain any import or export directives, then its object code won’t contain any import, export, or relcate statements. In this case, the object code is already executable and does not require linking: it can be booted directly by the processor.</p>
<p>The booter (invoked by clicking the Boot button in the processor page) reads in the currently selected module and checks to see whether it is a valid executable module. If so, it loads the code into the memory. If not, it indicates that the program cannot be booted.</p>
<h2 id="programs-modules-and-files">Programs, modules, and files</h2>
<p>The system is designed to allow programs that consist of several modules, but also to allow programs consisting of one standalone module. In addition, an aim is to do this simply and intuitively, so that you can ignore the issues of modules and linking if you just want to write a andalone program.</p>
<p>There is a standard convention for file names. If, for example, you have a program named MyProgram, then the files associated with it should be as follows:</p>
<hr />
<p>module name MyProgram source file MyProgram.asm.txt object file MyProgram.obj.txt assembly listing MyProgram.lst.txt —————– ———–</p>
<h2 id="simple-standalone-programs">Simple standalone programs</h2>
<p>If a program does not import any names, it is <em>standalone</em>. The text of the program is shown in the editor pane. Go to the Assembler pane and click Assemble. If there are no errors, go directly to the Processor pane (you can skip the Linker) and click Boot. This will read the machine language into the memory, and now you can run the program.</p>
<h2 id="programs-with-multiple-modules">Programs with multiple modules</h2>
<p>A module consists of program text, and it may have an optional file, and an optional module name.</p>
<ul>
<li><p>The module text is a sequence of assembly language statements. The text may exist only in the editor buffer, or it may be associated with a file.</p>
<ul>
<li>If there is a file, this may be specified either as a path (the unique identification of the file (C:\Users....asm.txt), or as just a filename (myprogram.asm.txt) which is relative to the current directory.</li>
</ul></li>
</ul>
<p>To edit a file, the modDir and modName are both optional. An edited file may have a module name specified with a module statement. To read or save a file, both the module directory and name must be known.</p>
<p>Editor operations on files and modules</p>
<p>Each operation that changes the editor buffer (New, Open, Close) checks first to see whehter the buffer has been changed since it was last saved. If so, a dialogue asks whether the file should be saved.</p>
<ul>
<li><p>New – Check whether text in the editor buffer has been saved; if not, ask whether to save it. Create a new module with empty text and no file name, add it to the module set, and select it as the current module. Clear the text in the editor buffer.</p>
<ul>
<li><p>Open – Check whether text in the editor buffer has been saved; if not, ask whether to save it. Enter the open file dialogue where an existing file can be found by navigation or by typing in its name. If the dialogue is cancelled, the module set and editor buffer are left unchanged. If a file is selected in the dialogue, and it is already in the module set, then it is selected in the current module. Otherwise, a new module is created with the file’s contents, and is selected as the current module. and The file is loaded into the editor buffer and added to the module set.</p></li>
<li><p>Refresh – The file corresponding to the current module is read, and its contents are loaded into the editor buffer.</p></li>
<li><p>SaveAs – Enters the save file dialogue where the directory and file name can be chosen. The editor buffer is written into this file.</p></li>
<li><p>Save – Writes the editor buffer into the current file and directory. If either the module name or directory is not known, this reverts to a SaveAs.</p></li>
<li><p>Select – Opens a list of all modules; you can click one of them which is then set as the current module.</p></li>
<li><p>Close – Check whether text in the editor buffer has been saved; if not, ask whether to save it. The module is removed from the module set, and the editor buffer is cleared. The first module (module number 0) is selected as the current module, but if there is no module at all, an empty module is created and selected as current (in effect, if there is only one module and you close it, an automatic New is performed).</p></li>
<li><p>Example – Reads in a very simple example program and sets it as the current module. This is a standalone program; you can simply click Editor: Example, then Assembler: Assemble, then Processor: Boot, and run the program. This example is used in the first “getting started” tutorial. The example program is also available in the Examples directory, accessible through Editor: Open.</p></li>
</ul></li>
</ul>
<p>Select is for switching among the existing modules, while New and Open are for introducing a new module.</p>
<h1 id="programming">Programming</h1>
<h2 id="computer-architecture">Computer Architecture</h2>
<h3 id="machine-language-and-instructions">Machine language and instructions</h3>
<p>Very different from Python, Java, C, etc. The designer of a machine language has to `look both up and down’:</p>
<ul>
<li><p>Looking up to higher levels of abstraction, the machine language must be powerful enough to provide the foundation for operating systems and programming languages.</p></li>
<li><p>Looking down to the lower levels of implementation, the machine language must be simple enough so that a digital circuit can execute it.</p></li>
</ul>
<p>Machine languages are designed to achieve high performance possible at reasonable cost. Their primary aim is not to make programming as easy as possible</p>
<p>A machine language program consists of instructions. An instruction is analogous to a statement in a programming language. However, each instruction just performs a small fixed set of operations, while programming language statements can be complex. For example, the assignment statement x := 2 * (a + b/c) involves three arithmitic operations, and it would require at least three instructions to express in machine language.</p>
<h3 id="why-use-sigma16">Why use Sigma16?</h3>
<p>Our focus is on fundamental concepts, ideas and principles. Sigma16 illustrates the fundementals of computer systems but it avoids unnecessary complexity. For example, Sigma16 has just one word size (16 bits) while most commercial machines provide a variety. That variety is useful for practical applications but it complicates many of the details while not adding any new fundamental ideas. Most commercial computers that achieve success in the marketplace eventually become encrusted with complications that help support backward compatibility; this can lead to great complexity.</p>
<h3 id="structure-of-a-computer">Structure of a computer</h3>
<p>All computers have several main subsystems</p>
<ul>
<li><p>A register is a digital circuit that can retain one word of data. A new value can be loaded into a register, and the current contents may be read out.</p></li>
<li><p>The register file is a set of 16 registers that are available to the user programmer for holding values of variables. They are named R0, R1, R2, …, R15.</p>
<p>Register Contents ~~~~~~~~~~ ~~~~~~~~~~ R0 0000 R1 fffe R2 13c4 … … R14 03c8 R15 0020</p></li>
<li><p>The ALU (arithmetic and logic unit) is a circuit that can do arithmetic, such as addition, subtraction, comparison, and some other operations</p></li>
<li><p>The memory can hold a large number of words. It’s similar to the register file, but significantly slower and much larger.</p></li>
<li><p>The Input/Output system can transfer data between the computer and the outside world.</p></li>
</ul>
<h3 id="instructions-1">Instructions}</h3>
<h3 id="the-rtm-instructions">The RTM instructions</h3>
<ul>
<li><p>The RTM circuit can execute two instructions</p>
<ul>
<li>R2 := R1 + R0 ; add two registers and load result</li>
<li>R1 := 8 ; load a constant</li>
</ul></li>
<li><p>We’ll begin with the corresponding Sigma16 instructions</p></li>
</ul>
<h3 id="the-add-instruction">The add instruction}</h3>
<ul>
<li>Think of the registers as variables</li>
<li><p>Examples:</p></li>
<li>add R5,R2,R3 ; means R5 := R2 + R3</li>
<li><p>add R12,R1,R7 ; means R12 := R1 + R7</p></li>
<li><p>General form:</p></li>
<li> where dest, op1, op2 are registers</li>
<li>The two  are added, the result is placed in the </li>
<li><p>Meaning:  :=  + </p></li>
<li><p>Everything after a semicolon ; is a comment</p></li>
</ul>
<h3 id="registers-can-hold-variables">Registers can hold variables}</h3>
<ul>
<li>We often think of a variable as </li>
<li>A register can hold a variable!</li>
<li>An add instruction (or sub, mul, div) is like an assignment statement</li>
<li> means  \begin{enumerate}</li>
<li>Evaluate the right hand side </li>
<li>The operands (R8, R2) are not changed</li>
<li>Overwrite the left hand side (destination) (R2) with the result</li>
<li>The old value of the destination is destroyed</li>
<li>It is </li>
<li>It is  \end{enumerate}</li>
<li>Assignment is often written </li>
<li>The  operator means , and does not mean </li>
</ul>
<h3 id="notation-and-terminology">Notation and terminology}</h3>
<p>Why write a notation like add R5,R2,R3 instead of R5 := R2 + R3?</p>
<ul>
<li>It’s actually more consistent because  instruction will be written in this form: a keyword for the operation, followed by the operands</li>
<li>The notation is related closely to the way instructions are represented in memory, which we’ll see later</li>
</ul>
<h3 id="a-simple-program">A simple program}</h3>
<p>The problem:</p>
<ul>
<li>Given three integers in R1, R2, R3</li>
<li>Goal: calculate the sum R1+R2+R3 and put it in R4</li>
</ul>

<p>Solution: </p>
<pre><code>    add  R4,R1,R2    ;  R4 := R1+R2   (this is a comment)
    add  R4,R4,R3    ;  R4 := (R1+R2) + R3</code></pre>
<h3 id="more-arithmetic-instructions">More arithmetic instructions}</h3>
<p>There are instructions for the basic arithmetic operations</p>
<pre><code> add  R4,R11,R0   ; R4 := R11 + R0
 sub  R8,R2,R5    ; R8 := R2 - R5
 mul  R10,R1,R2   ; R10 := R1 * R2
 div  R7,R2,R12   ; R7 := R2 / R12</code></pre>
<p></p>
<h3 id="example">Example}</h3>
<ul>
<li>Suppose we have variables a, b, c, d</li>
<li>R1=a, R2=b, R3=c, R4=d</li>
<li>We wish to compute R5 = (a+b) * (c-d)</li>
</ul>
<pre><code>    add   R6,R1,R2     ; R6 := a + b
    sub   R7,R3,R4     ; R7 := c - d
    mul   R5,R6,R7     ; R5 := (a+b) * (c-d)</code></pre>

<h3 id="general-form-of-arithmetic-instruction">General form of arithmetic instruction}</h3>

<h3 id="register-r0-and-r15-are-special">Register R0 and R15 are special!}</h3>
<ul>
<li>You should not use R0 or R15 to hold ordinary variables!</li>
<li></li>
<li>Any time you need the number 0, it’s available in R0</li>
<li>You cannot change the value of R0</li>
<li>add R0,R2,R3 ; does nothing — R0 will not change</li>
<li>add R5,R2,R3 ; fine - you can change all other registers</li>
<li><p>It is  to use R0 as the destination, but it will still be 0 after you do it!</p></li>
<li></li>
<li>Some instructions place additional information in R15 (is the result negative? was there an overflow?)</li>
<li>Therefore the information in R15 is transient</li>
<li><p>R15 is for temporary information; it’s not a safe place to keep long-term data</p></li>
</ul>
<h3 id="memory-1">Memory</h3>
<h3 id="limitation-of-register-file-its-small">Limitation of register file: it’s small}</h3>
<ul>
<li>The register file is used to perform calculations</li>
<li>In computing somethine like , all the arithmetic will be done using the register file</li>
<li><p>But it has a big limitation:</p></li>
<li>There are only 16 registers</li>
<li><p>And most programs need more than 16 variables!</p></li>
<li><p>Solution: the  is large and can hold far more data than the register file</p></li>
</ul>
<h3 id="memory-2">Memory}</h3>
<ul>
<li>The memory is similar to the register file: it is a large collection of words</li>
<li>A variable name (x, sum, count) refers to a word in memory</li>
<li><p>Some differences between memory and register file:</p></li>
<li>The memory is : 65,536 locations (the register file has only 16)</li>
<li><p>The memory cannot do arithmetic</p></li>
<li><p>So our strategy in programming:</p></li>
<li>Keep data permanently in memory</li>
<li>When you need to do arithmetic, copy a variable from memory to a register</li>
<li><p>When finished, copy the result from a register back to memory</p></li>
</ul>
<h3 id="registers-and-memory">Registers and memory</h3>
<ul>
<li><p>The </p>
<ul>
<li>16 registers</li>
<li></li>
<li>Each register holds a 16-bit word</li>
<li>Names are R0, R1, R2, <span class="math inline">…</span>, R15</li>
<li>You can do arithmetic on data in the registers</li>
<li></li>
</ul></li>
<li><p>The </p></li>
<li>65,536 memory locations</li>
<li>Each memory location holds a 16-bit word</li>
<li>Each memory location has an  0, 1, 2, <span class="math inline">…</span>, 65,535</li>
<li>The machine cannot do arithmetic on a memory location</li>
<li><p></p></li>
</ul>
<h3 id="copying-a-word-between-memory-and-register">Copying a word between memory and register</h3>
<p>There are two instructions for accessing the memory</p>
<ul>
<li><p> copies a variable from memory to a register</p>
<ul>
<li> copies the variable  from memory to register R2</li>
<li></li>
<li>R2 is changed; x is unchanged</li>
</ul></li>
<li><p> copies a variable from a register to memory</p></li>
<li> copies the word in register R3 to the variable  in memory</li>
<li></li>
<li><p>y is changed; R3 is unchanged</p></li>
<li><p>Notice that we write  after a variable name. Later we’ll see the reason.</p></li>
</ul>
<h3 id="an-assignment-statement-in-machine-langauge">An assignment statement in machine langauge</h3>
<p></p>

<pre><code>       load   R1,a[R0]      ; R1 := a
       load   R2,b[R0]      ; R2 := b
       add    R3,R1,R2      ; R3 := a+b
       load   R4,c[R0]      ; R4 := c
       add    R5,R3,R4      ; R5 := (a+b) + c
       store  R5,x[R0]      ; x := a+b+c</code></pre>

<h3 id="why-do-we-have-registers-and-memory">Why do we have registers and memory</h3>
<ul>
<li>The programmer has to keep track of which variables are currently in registers</li>
<li>You have to use load and store instructions to copy data between the registers and memory</li>
<li>Wouldn’t it be easier just to get rid of the distinction between registers and memory? Do all the arithmetic on memory</li>
<li><p>Short answer:</p></li>
<li>Yes, it’s possible to design a computer that way</li>
<li>But it makes the computer </li>
<li><p>With modern circuits, a computer without load and store instructions (where you do arithmetic on memory locations) would run between 100 and 1,000 times slower</p></li>
</ul>
<h3 id="constants-the-lea-instruction">Constants: the lea instruction</h3>
<ul>
<li>The RTM has an instruction that loads a constant into a register</li>
<li>Use the  instruction</li>
<li> loads the constant 57 into R2: </li>
<li></li>
<li>General form: </li>
<li>You must write [R0] after the constant; we’ll see the reason for this later on</li>
</ul>
<h3 id="example-using-lea">Example using lea</h3>
<pre><code>; R3 := R1 + 39*R2

    lea   R4,39[R0]    ; R4 := 39
    mul   R3,R4,R2     ; R3 := 39 * R2
    add   R3,R1,R3     ; R3 := R1 + (39*R2)</code></pre>
<h3 id="stopping-the-program">Stopping the program</h3>
<p>The last instruction should be</p>
<pre><code>     trap   R0,R0,R0   ; halt</code></pre>
<p>This tells the computer to halt; it stops execution of the program</p>
<h3 id="defining-variables">Defining variables</h3>
<p>To define variables x, y, z and give them initial values</p>
<pre><code>x    data   34    ; x is a variable with initial value 34
y    data    9    ; y is initially 9
z    data    0    ; z is initially 0
abc  data  $02c6  ; specify initial value as hex</code></pre>
<p>The data statements should come  all the instructions in the program (we’ll see why later)</p>
<h3 id="a-complete-example-program">A complete example program</h3>
<pre><code>; Program Add
; A minimal program that adds two integer variables

; Execution starts at location 0, where the first instruction will be
; placed when the program is executed.

      load   R1,x[R0]   ; R1 := x
      load   R2,y[R0]   ; R2 := y
      add    R3,R1,R2   ; R3 := x + y
      store  R3,z[R0]   ; z := x + y
      trap   R0,R0,R0   ; terminate

; Static variables are placed in memory after the program

x     data  23
y     data  14
z     data  99</code></pre>
<p>}</p>
<h3 id="programming-languages-and-compiling">Programming languages and Compiling</h3>
<h3 id="compiling">Compiling</h3>
<ul>
<li>The computer cannot execute programs in a high level language</li>
<li>Therfore we must  a program into assembly language</li>
<li>{Translating from a high level programming language to assembly language is called} </li>
<li>This is done by software called a : it reads in a program in e.g. C++ and translates it to assembly language</li>
<li><p>There are many benefits of using compilers</p></li>
<li>We can have many compilers, one for each language, so a computer can run programs in  languages</li>
<li>The compilers can make programming easier: good error messages, etc.</li>
<li><p>Languages can be designed to fit well for different purposes</p></li>
<li><p>For each type of high level language construct, we will translate to assembly language following a standard pattern</p></li>
</ul>
<h4 id="high-level-constructs">High level constructs</h4>
<h3 id="statements">Statements</h3>
<p>A program contains</p>
<ul>
<li><p>Statements that perform calculations</p>
<ul>
<li>Assignment statements</li>
</ul></li>
<li><p>Statements that determine what order the calculations occur in</p></li>
<li>Conditionals: if—then—else</li>
<li>Loops: while, repeat, for</li>
<li><p>Structuring computation: functions, procedures, coroutines, recursion</p></li>
<li><p>These are called </p></li>
</ul>
<h3 id="high-level-control-structures">High level control structures</h3>
<ul>
<li><p>Notation</p>
<ul>
<li><span class="math inline"><em>S</em></span>, <span class="math inline"><em>S</em><sub>1</sub></span>, <span class="math inline"><em>S</em><sub>2</sub></span>, etc. means ``any statement’’ (e.g. an assignment statement)</li>
<li><span class="math inline"><em>b</em><em>e</em><em>x</em><em>p</em></span> means any Boolean expression (an expression that is either True or False). Examples </li>
</ul></li>
<li> We can treat several consecutive statements as just a single statement: </li>
<li> </li>
<li> </li>
<li> </li>
<li><p>And there are many more</p></li>
</ul>
<h4 id="low-level-constructs">Low level constructs</h4>
<h3 id="low-level-constructs-1">Low level constructs</h3>
<ul>
<li>Assignment statements: </li>
<li>Goto: </li>
<li>Conditional: </li>
<li>First we translate high level constructs into these low level statements</li>
<li>Then translate the low level statements into assembly language</li>
</ul>
<h3 id="the-goto-statement">The Goto statement</h3>
<pre><code>        S;
loop:   S;
        S;
        S;
        goto loop;</code></pre>
<ul>
<li>Many (not all) programming languages have a  statement</li>
<li>Any statement may have a  (for example ``loop’’)</li>
<li>Normally execution proceeds from one statement to the next, on and on</li>
<li>A  transfers control to the statement with label L</li>
</ul>
<h3 id="using-the-goto-statement">Using the goto statement</h3>
<ul>
<li>The first programming language (Fortran, 1955) didn’t have fancy control structures — you had to do nearly everything with goto</li>
<li>But goto leads to unreadable programs and unreliable software</li>
<li><p>The modern view:</p></li>
<li>In a high level language, </li>
<li><p>For low level programming — like assembly language — the goto serves as the  for implementing the higher level control statements</p></li>
<li><p>We will use two forms:</p></li>
<li>goto L</li>
<li><p>if b then goto L</p></li>
</ul>
<h3 id="the-conditional-goto-statement">The conditional goto statement</h3>
<ul>
<li>if bexp then goto label</li>
<li>bexp is a Boolean expression: <span class="math inline"><em>x</em> &lt; <em>y</em></span>, <span class="math inline"><em>j</em> = <em>k</em></span>, <span class="math inline"><em>a</em><em>b</em><em>c</em> &gt; <em>d</em><em>e</em><em>f</em></span></li>
<li>If the bexp is True the statement goes to the label</li>
<li>Otherwise we just move on the the next statement</li>
<li></li>
</ul>
<h3 id="jumping-and-comparing">Jumping and comparing</h3>
<h4 id="unconditional-jump">Unconditional jump</h4>
<h3 id="jumping">Jumping</h3>
<ul>
<li>The foundation of control structures is  instructions</li>
<li> is the machine language equivalent of </li>
<li>An instruction may have a </li>
<li>The label is a name, starting with a letter, and must appear starting in the first character of a line</li>
<li>The unconditional instruction  means </li>
</ul>
<h4 id="comparison-instructions">Comparison instructions</h4>
<h3 id="comparison-instruction-boolean-form">Comparison instruction: Boolean form</h3>
<ul>
<li>cmplt R2,R5,R8
<ul>
<li>Means ``compare for Less Than’’</li>
<li>The operands are compared: R5 <span class="math inline">&lt;</span> R8</li>
<li>This gives a Boolean, 0 (for False) or 1 (for True)</li>
<li>That Boolean result is loaded into the destination R2</li>
<li><p>There are three of these instructions</p></li>
<li>cmplt — compare for Less Than</li>
<li>cmpeq — compare for Equal</li>
<li><p>cmpgt — compare for Greater Than</p></li>
</ul></li>
</ul>
<h4 id="conditional-jumps">Conditional jumps</h4>
<h3 id="conditional-jumps-boolean-decision">Conditional jumps: Boolean decision</h3>
<ul>
<li>There are two instructions: you can jump if a Boolean is False or True</li>
<li><p>jumpf — jump if False</p></li>
<li>jumpf R4,aardvark[R0]</li>
<li>Means if R4 contains False, then goto aardvark</li>
<li><p>0 means False, so this means if R4=0 then goto aardvark</p></li>
<li><p>jumpt — jump if True</p></li>
<li>jumpt R5,banana[R0]</li>
<li>Means if R5 contains True, then goto banana</li>
<li><p>Any number other than 0 means True, so this means if R5 <span class="math inline">≠</span> 0 then goto banana</p></li>
</ul>
<h3 id="compilation-patterns">Compilation patterns</h3>
<h3 id="compilation-patterns-1">Compilation patterns</h3>
<ul>
<li>Each programming construct can be translated according to a standard pattern</li>
<li><p>It’s useful to translate in two steps:</p></li>
<li>First, translate complex statements to simple high level statements (go to label, if b then goto label)</li>
<li>The ``goto form’’ of the algorithm corresponds closely to machine instructions</li>
<li><p>Then it’s straightforward to complete the translation to assembly language</p></li>
<li>Assignment statements — loads, then arithmetic, then store</li>
<li>goto label — jump label[R0]</li>
<li>if b then goto label — jumpt R5,label[R0] where R5 contains b</li>
<li><p>if not b then goto label — jumpf R5,label[R0] where R5 contains b</p></li>
<li><p>This approach clarifies how the algorithm works</p></li>
</ul>
<h3 id="compiling-an-assignment-statement">Compiling an assignment statement</h3>
<p>Load the operands; do calculations; store results</p>
<pre><code>; x := a + b*c;
   load  R1,a[R0]   ; R1 = a
   load  R2,b[R0]   ; R2 = b
   load  R3,c[R0]   ; R3 = c
   mul   R4,R2,R3   ; R4 = b*c
   add   R4,R1,R4   ; R4 = a + (b*c)
   store R4,x[R0]   ; x := a+(b*c)</code></pre>
<h4 id="if-bexp-then-s">if bexp then S</h4>
<h3 id="if-bexp-then-s-1">if bexp then S</h3>
<pre><code>if x&lt;y
  then {statement 1;}
statement 2;</code></pre>
<p></p>
<pre><code>   R7 := (x &lt; y)
   jumpf R7,skip[R0]
   instructions for statement 1
skip
   instructions for statement 2 </code></pre>
<h3 id="example-code-with-if-then">Example: code with if-then</h3>
<p>Source program fragment:</p>
<pre><code>x := 2;
if y&gt;x
   then { a := 5; }
b := 6;</code></pre>
<h3 id="example-translating-if-then">Example: translating if-then</h3>
<p>{ ~~~~ ; x := 2; lea R1,2[R0] ; R1 := 2 store R1,x[R0] ; x := 2</p>
<p>; if y&gt;x load R1,y[R0] ; R1 := y load R2,x[R0] ; R2 := x cmpgt R3,R1,R2 ; R3 := (y&gt;x) jumpf R3,skip[R0] ; if y &lt;= x then goto skip</p>
<p>; then { a := 5; } lea R1,5[R0] ; R1 := 5 store R1,a[R0] ; a := 5</p>
<p>; b := 6; skip lea R1,6[R0] ; R1 := 6 store R1,b[R0] ; b := 6 ~~~~ }</p>
<h4 id="if-bexp-then-s1-else-s2">if bexp then S1 else S2</h4>
<h3 id="if-bexp-then-s1-else-s2-1">if bexp then S1 else S2</h3>
<pre><code>if x&lt;y
  then { S1 }
  else { S2 }
S3</code></pre>
<p>Compiled into: ~~~~ R5 := (x&lt;y) jumpf R5,else[R0] ; then part of the statement instructions for S1 jump done[R0] ; else part of the statement else instructions for S2 done instructions for statement S3 ~~~~</p>
<h4 id="while-bexp-do-s">while bexp do S</h4>
<h3 id="while-b-do-s">while b do S</h3>
<pre><code>while i&lt;n do
  { S1 }
S2</code></pre>
<p>Compiled into: ~~~~ loop R6 := (i&lt;n) jumpf R6,done[R0] … instructions for the loop body S1 … jump loop[R0] done instructions for S2 ~~~~</p>
<h3 id="infinite-loops">Infinite loops</h3>
<pre><code>while (true)
  {statements} </code></pre>
<p>Compiled into: ~~~~ loop … instructions for the loop body … jump loop[R0] ~~~~</p>
<h4 id="nested-statements">Nested statements</h4>
<h3 id="nested-statements-1">Nested statements</h3>
<ul>
<li>For each kind of high level statement, there is a pattern for translating it to</li>
<li>In larger programs, there will be </li>
</ul>
<pre><code>if b1
  then { S1;
         if b2 then {S2} else {S3};
         S4;
       }
  else { S5;
         while b3 do {S6};
       }
S7</code></pre>
<h3 id="how-to-compile-nested-statements">How to compile nested statements</h3>
<ul>
<li><p>A  is a sequence of instructions where</p>
<ul>
<li>To execute it, </li>
<li>When it finishes, it </li>
</ul></li>
<li>Every statement should be compiled into a block of code</li>
<li>This block may contain internal structure — it may contain several smaller blocks — but to execute it you should </li>
<li>The patterns work for nested statements</li>
<li><p>You need to use new labels (can’t have a label like ``skip’’ in several places)</p></li>
</ul>
<h3 id="programming-technique">Programming technique</h3>
<h3 id="programming-technique-1">Programming technique</h3>
<p>There are two ways to handle variables:</p>
<ul>
<li><p>The :</p>
<ul>
<li>{Each statement is compiled independently.}</li>
<li>load, arithmetic, store</li>
<li>Straightforward but inefficient.</li>
<li>{Use this style if you feel confused.}</li>
</ul></li>
<li><p>The :</p></li>
<li>{Keep variables in registers across a group of statements}</li>
<li>Don’t need as many loads and stores</li>
<li>More efficient</li>
<li>You have to keep track of whether variables are in memory or a register.</li>
<li></li>
<li>Real compilers use this style.</li>
<li><p>{Use this style if you like the shorter code it produces.}</p></li>
</ul>
<h3 id="examples-of-the-two-styles">Examples of the two styles</h3>
<p>We’ll translate the following program fragment to assembly language, using each style:</p>
<pre><code>x = 50;
y = 2*z;
x = x+1+z;</code></pre>
<h4 id="statement-by-statement-style">Statement-by-statement style</h4>
<h3 id="example-of-statement-by-statement-style">Example of statement-by-statement style</h3>
<p>{ ~~~~ ; x = 50; lea R1,$0032 ; R1 = 50 store R1,x[R0] ; x = 50</p>
<p>; y = 2<em>z; lea R1,$0002 ; R1 = 2 load R2,z[R0] ; R2 = z mul R3,R1,R2 ; R3 = 2</em>z store R3,y[R0] ; y = 2*z</p>
<p>; x = x+1+z; load R1,x[R0] ; R1 = x lea R2,1[R0] ; R2 = 1 load R3,z[R0] ; R3 = z add R4,R1,R2 ; R4 = x+1 add R4,R4,R3 ; R4 = x+1+z store R4,x[R0] ; x = x+1+z ~~~~ }</p>
<h4 id="register-variable-style">Register-variable style}</h4>
<h3 id="example-of-register-variable-style">Example of register-variable style</h3>
<p>{ ~~~~ ; Usage of registers ; R1 = x ; R2 = y ; R3 = z</p>
<p>; x = 50; lea R1,$0032 ; x = 50 load R3,z[R0] ; R3 = z lea R4,$0002 ; R4 = 2 ; y = 2<em>z; mul R2,R4,R3 ; y = 2</em>z ; x = x+1+z; lea R4,$0001 ; R4 = 1 add R1,R1,R4 ; x = x+1 add R1,R1,R3 ; x = x+z store R1,x[R0] ; move x to memory store R2,y[R0] ; move y to memory ~~~~ }</p>
<h4 id="comparison-of-the-styles">Comparison of the styles</h4>
<h3 id="comparison-of-the-two-styles">Comparison of the two styles</h3>
<ul>
<li><p>Statement by statement</p>
<ul>
<li>Each statement is compiled into a separate block of code.</li>
<li>Each statement requires loads, computation, then stores.</li>
<li>A variable may appear in several different registers.</li>
<li>There may be a lot of redundant loading and storing.</li>
<li>The object code corresponds straightforwardly to the source code, but it may be unnecessarily long.</li>
</ul></li>
<li><p>Register variable</p></li>
<li>The instructions corresponding to the statemnts are mixed together.</li>
<li>Some statements are executed entirely in the registers.</li>
<li>A variable is kept in the same register across many statments.</li>
<li>The use of loads and stores is minimised.</li>
<li><p>The object code is concise, but it’s harder to see how it corresponds to the source code.</p></li>
<li><p>It’s possible to have a mixture of the styles: you don’t have to follow one or the other all the time.</p></li>
</ul>
<h2 id="machine-language">Machine language</h2>
<h3 id="machine-language-representing-instructions-in-memory">Machine language: representing instructions in memory</h3>
<ul>
<li>The actual bits representing an instruction (written in hex) —  – is </li>
<li>The actual hardware runs the machine language — it’s just looking at the numbers</li>
<li>The text notation with names —  — is </li>
<li>Assembly language is for humans, machine language is for machines</li>
<li>Both , down to the last bit</li>
</ul>
<h3 id="whats-in-the-memory">What’s in the memory?</h3>
<ul>
<li><p>All your program’s data</p>
<ul>
<li>Variables</li>
<li>Data structures, arrays, lists</li>
</ul></li>
<li><p></p></li>
</ul>

<h3 id="instruction-formats-different-types-of-instruction">Instruction formats: different types of instruction</h3>
<ul>
<li><p>Sigma16 has </p>
<ul>
<li> instructions use the </li>
<li> instructions use the </li>
<li> instructions use </li>
</ul></li>
<li>Each kind of instruction is called an </li>
<li>All the instructions with the same format are similar</li>
<li><p></p></li>
</ul>
<h3 id="instruction-formats-representing-instructions">Instruction formats: representing instructions</h3>
<ul>
<li>The machine language program is in the memory</li>
<li>So we need to represent each instruction as a word</li>
<li>An  is </li>
<li><p>Every instruction is either RRR, RX, or EXP</p></li>
<li>An RRR instruction is represented in  (remember, a word is 16 bits)</li>
<li><p>An RX or EXP instruction is represented in </p></li>
<li>We just need to learn three ways to represent an instruction!</li>
<li><p>For now, we just need RRR and RX (EXP is needed only for some more advanced instructions, which we’ll see later)</p></li>
</ul>
<h3 id="fields-of-an-instruction-word">Fields of an instruction word</h3>
<ul>
<li>An instruction word has 16 bits</li>
<li>There are four fields, each 4 bits</li>
<li>We write the value in a field using  \begin{enumerate}</li>
<li>hex digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f</li>
<li>represent numbers 1, <span class="math inline">…</span>, 15 \end{enumerate}</li>
<li><p>The fields have standard names:</p></li>
<li>op — holds the operation code</li>
<li>d — usually holds the destination register</li>
<li>a — usually holds the first source operand register</li>
<li><p>b — usually holds the second source operand register</p></li>
</ul>
<h4 id="rrr-instructions">RRR instructions</h4>
<h3 id="rrr-instructions-1">RRR instructions</h3>
<ul>
<li><p>Every RRR instruction consists of</p>
<ul>
<li>An operation (e.g. add)</li>
<li>Three register operands: a destination and two operands</li>
<li>The instruction performs the operation on the operands and puts the result in the destination</li>
</ul></li>
</ul>
<h3 id="representing-rrr">Representing RRR</h3>
<ul>
<li>Example: add R3,R12,R5</li>
<li>We need to specify  RRR instruction this is. Is it add? sub? mul? another?</li>
<li>This is done with an  — a number that says what the operation is</li>
<li>There are about a dozen RRR instructions, so a 4-bit operation code suffices</li>
<li>We also need to specify three registers: destination and two source operands</li>
<li>There are 16 registers, so a particular one can be specified by 4 bits</li>
<li>Total requirements: 4 fields, each 4 bits — total 16 bits</li>
<li>An RRR instruction exactly fills one word</li>
</ul>
<h3 id="some-rrr-instructions">Some RRR instructions</h3>
<ul>
<li><p>All RRR instructions have the same form, just the operation differs</p>
<ul>
<li>add R2,R2,R5 ; R2 = R2 + R5</li>
<li>sub R3,R1,R3 ; R3 = R1 - R3</li>
<li>mul R8,R6,R7 ; R8 = R6 * R7</li>
</ul></li>
<li>In ``add R2,R5,R9’’ we call R5 the , R9 the , and R2 the </li>
<li>It’s ok to use the same register as an operand and destination!</li>
<li><p>Later we’ll see some more RRR instructions, but they all have the same form as these do</p></li>
</ul>
<h3 id="a-few-rrr-operation-codes">A few RRR operation codes</h3>


<p></p>
<h3 id="example-of-rrr">Example of RRR</h3>
<p>{ ~~~~ add R13,R6,R9 ~~~~ }</p>
<ul>
<li>Since each field of the instruction is 4 bits, written as a hex digit</li>
<li>The opcode (operation code) is 0</li>
<li>Destination register is 13 (hex d)</li>
<li>Source operand registers are 6 and 9 (hex 6 and 9)</li>
<li>So the instruction is:</li>
</ul>

<h4 id="rx-instructions">RX instructions</h4>
<h3 id="rx-instructions-1">RX instructions</h3>
<ul>
<li><p>Every RX instruction contains two operands:</p>
<ul>
<li>A </li>
<li>A </li>
</ul></li>
<li><p>We have seen several so far:</p></li>
<li>lea R5,19[R0] ; R5 = 19</li>
<li>load R1,x[R0] ; R1 = x</li>
<li>store R3,z[R0] ; z = R3</li>
<li><p>jump finished[R0] ; goto finished</p></li>
</ul>
<h3 id="rx-instructions-2">RX instructions</h3>
<p>A typical RX instruction: </p>
<ul>
<li>The first operand (e.g. R1 here) is called the , just like for RRR instructions</li>
<li>The second operand  specifies a .</li>
<li>Each variable is kept in memory at a specific location: we talk about </li>
<li><p>The memory operand has two parts:</p></li>
<li>The variable x is a name for the address where x is kept — called the </li>
<li><p>The R0 part is just a register, called the </p></li>
</ul>
<h3 id="format-of-rx-instruction">Format of RX instruction</h3>
<p>{ ~~~~ load R1,x[R0] ~~~~ }</p>
<ul>
<li>There are two words in the machine language code</li>
<li><p>The first word has 4 fields: op, d, a, b</p></li>
<li>op contains f for every RX instruction</li>
<li>d contains the register operand (in the example, 1)</li>
<li>a contains the index register (in the example, 0)</li>
<li><p>b contains a code indicating  RX instruction this is (1 means load)</p></li>
<li><p>The second word contains the displacement (address) (in the example, the address of x)</p></li>
</ul>
<p>Suppose x has memory address 0008. Then the machine code for load R1,x[R0] is:</p>

<h3 id="operation-codes-for-rx-instructions">Operation codes for RX instructions</h3>
<ul>
<li>Recall, for RRR the op field contains a number saying  RRR instruction it is</li>
<li>For RX, the op field </li>
<li>So how does the machine know  RX instruction it is?</li>
<li>Answer: there is a secondary code in the b field</li>
</ul>

<h3 id="the-assembler">The assembler</h3>
<h3 id="assembly-language-1">Assembly language</h3>
<ul>
<li><p>Humans write </p>
<ul>
<li>The program is text: {add R4,R2,R12}</li>
<li>It’s easier to read</li>
<li>You don’t need to remember all the codes</li>
<li>Memory addresses are  to handle</li>
</ul></li>
<li><p>The machine executes </p></li>
<li>The program is words containing 16-bit numbers: {042c}</li>
<li>It’s possible for a digital circuit (the computer) to execute</li>
<li><p>No names for instructions or variables: everything is a number</p></li>
</ul>
<h3 id="the-assembler-1">The assembler</h3>
<ul>
<li>A human writes a machine-level program in assembly language</li>
<li>A software application called the  reads it in, and translates it to machine language</li>
<li><p>What does the assembler do?</p></li>
<li>When it sees an instruction mnemonic like add or div, it replaces it with the operation code (0, 3, or whatever).</li>
<li><p>The assembler helps with variable names — the machine language needs addresses (numbers) and the assembler calculates them</p></li>
</ul>
<h3 id="assembly-language-2">Assembly language</h3>
<ul>
<li>Each statement corresponds to one instruction</li>
<li>You can use names (add, div) rather than numeric codes (0, 3)</li>
<li>You can use variable names (x, y, sum) rather than memory addresses (02c3, 18d2)</li>
<li>You write a program in assemply language</li>
<li>The  translates it into machine language</li>
<li><p>What’s the relationship between compilers and assemblers?</p></li>
<li>Compilers translate between languages that are very different</li>
<li><p>Assemblers translate between very similar languages</p></li>
</ul>
<h3 id="a-sequence-of-rrr-instructions">A sequence of RRR instructions</h3>
<p> ~~~~ add R3,R5,R1 sub R4,R2,R3 mul R1,R9,R10<br />
~~~~</p>

<p> </p>
<p> ~~~<sub> 0351 1423 219a </sub>~~~</p>
<h3 id="variable-names-and-addresses">Variable names and addresses</h3>
<ul>
<li>Each variable needs to be declared with a  statement</li>
<li>x data 23</li>
<li>This means: allocate a word in memory for x and initialize it to 23</li>
<li></li>
</ul>
<h3 id="instructions-in-assembly-language">Instructions in assembly language</h3>
<ul>
<li>The syntax is simple, but you have to follow the form of the instructions exactly!</li>
<li><p>RRR instructions</p></li>
<li>Typical example: </li>
<li>R8 is the  (where the result goes)</li>
<li><p>R2 and R12 are the  (the operands to be added)</p></li>
<li><p>RX instructions</p></li>
<li>RX instructions specify a  and a </li>
<li>Typical example: </li>
<li>Meaning of load: R3 = x</li>
<li></li>
<li>Meaning of store: y = R3</li>
<li> copies from </li>
<li><p> copies from </p></li>
</ul>
<h3 id="how-the-assembler-allocates-memory">How the assembler allocates memory</h3>
<h3 id="how-the-assembler-allocates-memory-1">How the assembler allocates memory}</h3>

<h3 id="program-structure">Program structure</h3>
<ul>
<li><p>A complete program needs</p>
<ul>
<li>Good comments explaining what it is</li>
<li>The actual program — a sequence of instructions</li>
<li>An instruction to stop the program: </li>
<li>Declarations of the variables:  statements</li>
</ul></li>
<li><p>Why do we put the instructions first, and define the variables at the end?</p></li>
<li>The assembler can find the definitions because it reads the program twice: the first pass finds all the labels, the second pass generates the machine language code</li>
<li><p>The computer will start executing at memory address 0, so there had better be in instruction there, not data!</p></li>
</ul>
<h3 id="example-program-add">Example program Add</h3>
<pre><code>; Program Add
; A minimal program that adds two integer variables

; Execution starts at location 0, where the first instruction will be
; placed when the program is executed.

      load   R1,x[R0]   ; R1 := x
      load   R2,y[R0]   ; R2 := y
      add    R3,R1,R2   ; R3 := x + y
      store  R3,z[R0]   ; z := x + y
      trap   R0,R0,R0   ; terminate

; Static variables are placed in memory after the program

x     data  23
y     data  14
z     data  99</code></pre>
<p>}</p>
<h3 id="snapshot-of-memory-example-program-add">Snapshot of memory: example program Add</h3>

<h3 id="control-registers">Control registers</h3>
<h3 id="boot-reading-in-the-program">Boot: reading in the program</h3>
<ul>
<li>The program is placed in memory starting at location 0</li>
<li>The program should finish by executing the instruction ``trap R0,R0,R0’’</li>
<li>Normally, trap R0,R0,R0 should be the last instruction of the program (i.e. the program begins execution with the first instruction, and ends execution with the last, although it may jump around during execution)</li>
<li>After the trap R0,R0,R0 come the data statements, which tell the assembler the names of the variables and their initial values</li>
<li>These conventions were typical for early computers; later we will discuss how the operating system interacts with user programs</li>
</ul>
<h3 id="control-registers-1">Control registers</h3>
<ul>
<li>Some of the registers in the computer are accessible to the programmer: R0, R1, R2, <span class="math inline">…</span>, R15</li>
<li>There are several more registers that {the machine uses to keep track of what it’s doing}</li>
<li>These are called </li>
<li>They are (mostly) invisible to the program</li>
</ul>
<h3 id="keeping-track-of-where-you-are">Keeping track of where you are</h3>
<p>When you ``hand execute’’ a program, you need to know</p>
<ul>
<li>Where you are (point a finger at the current instruction)
<ul>
<li>What you’re doing (read the current instruction)</li>
</ul></li>
<li></li>
<li>The  (``program counter’’) contains  to be executed</li>
<li>The  (``instruction register’’) contains </li>
<li>If an RX instruction is being executed, the  (``address register’’) contains  of the second operand.</li>
</ul>
<h3 id="following-pc-and-ir-control-registers">Following PC and IR control registers</h3>
<ul>
<li>Try running a simple program</li>
<li>Step through the execution</li>
<li>Before each instruction executes, look at the PC and IR registers</li>
<li>Notice that PC always contains the  and IR always contains the </li>
<li>{The control registers help to understand in detail what the machine is doing.}</li>
</ul>
<h3 id="assembly-language-syntax">Assembly language syntax</h3>
<h3 id="assembly-language-syntax-1">Assembly language syntax</h3>
<ul>
<li>The syntax of assembly language is simple and rigid</li>
<li>See the document , where you will find these notes and additional tips and techniques</li>
</ul>
<h3 id="fields-separated-by-spaces">Fields separated by spaces</h3>
<ul>
<li><p>An assembly language statement has </p>
<ul>
<li>label (optional) – if present, must begin in leftmost character</li>
<li>operation load, add, etc.</li>
<li>operands: R1,R2,R3 or R1,x[R0]</li>
<li>comments: ; x = 2 * (a+b)</li>
</ul></li>
<li><p></p></li>
<li>R1,R12,R5 is ok</li>
<li><p>R1, R12,R5 is wrong</p></li>
</ul>
<p>{ ~~~~ loop load R1,count[R0] ; R1 = count add R1,R1,R2 ; R1 = R1 + 1 ~~~~ }</p>
<p>The assember first breaks each statement into the four fields; then it looks at the operation and operands.</p>
<h3 id="correct-form-of-operand-field">Correct form of operand field</h3>
<ul>
<li><p>RRR</p>
<ul>
<li>Exactly three registers separated by commas</li>
<li>Example: </li>
</ul></li>
<li><p>RX</p></li>
<li>Two operands: first is a register, second is an address</li>
<li>Address is a name or constant followed by [register]</li>
<li><p>Example: </p></li>
</ul>
<h3 id="each-of-these-statements-is-wrong">Each of these statements is wrong!</h3>
<pre><code>    add   R2, R8, R9     Spaces in the operand field
    store x[R0],R5       First operand must be register, second is address
  loop load R1,x[R0]     Space before the label
    jumpt R6,loop        Need register after address:  loop[R0]
    jal   R14, fcn[R0]   Space in operand field</code></pre>
<p>}</p>
<p>If you forget some detail, look at one of the example programs</p>
<h3 id="writing-constants">Writing constants</h3>
<ul>
<li><p>In assembly language, you can write constants in either decimal or hexadecimal</p>
<ul>
<li> 50</li>
<li> $0032</li>
</ul></li>
</ul>
<p>Examples:</p>
<pre><code>   lea   R1,40[R0]      ; R1 = 40
   lea   R2,$ffff[R0]   ; R2 = -1

x  data  25
y  data  $2c9e</code></pre>
<h3 id="good-style">Good style</h3>
<ul>
<li>It isn’t enough just to get the assembler to accept your program without error messages</li>
<li>Your program should be </li>
<li>This requires good style</li>
<li></li>
<li>A sloppy program looks unprofessional</li>
</ul>
<h3 id="comments">Comments</h3>
<ul>
<li>In Sigma16, a semicolon  indicates that the rest of the line is a comment</li>
<li>You can have a full line comment: just put ; at the beginning</li>
<li>You should use good comments in all programs, regardless of language</li>
<li>But they are even more important in machine language, because the code needs more explanation</li>
<li>At the beginning of the program, use comments to give the name of the program and to say what it does</li>
<li>Use a comment on every instruction to explain what it’s doing</li>
</ul>
<h3 id="indent-your-code-consistently">Indent your code consistently</h3>
<p>Each field should be lined up vertically, like this:</p>

<pre><code>    load   R1,three[R0]  ; R1 = 3
    load   R2,x[R0]      ; R2 = x
    mul    R3,R1,R2      ; R3 = 3*x
    store  R3,y[R0]      ; y = 3*x
    trap   R0,R0,R0      ; stop the program</code></pre>
<p>}</p>
<p>Not like this:</p>

<pre><code>    load   R1,three[R0]     ; R1 = 3
  load  R2,x[R0] ; R2 = x
       mul R3,R1,R2           ; R3 = 3*x
 store         R3,y[R0]      ; y = 3*x
   trap  R0,R0,R0      ; stop the program</code></pre>
<p>}</p>
<p>{The exact number of spaces each field is indented isn’t important; what’s important is to }</p>
<h3 id="use-spaces-not-tabs">Use spaces, not tabs</h3>
<ul>
<li>To indent your code, always use spaces</li>
<li>Don’t use tabs!</li>
<li><p>In general,  except in the (rare) cases they are actually required</p></li>
<li>The tab character was introduced to try to mimic the tab key on old mechanical typewriters</li>
<li>But </li>
<li><p>If you use tabs, your can look good in one application and a mess in another</p></li>
<li><p>It’s easy to indent with spaces, and it works everywhere!</p></li>
</ul>
<h3 id="address-arithmetic">Address arithmetic</h3>
<h3 id="why-r0">Why [R0]?</h3>
<ul>
<li><p>So far, we have always been writing [R0] after constants or names</p>
<ul>
<li>lea R2,39</li>
<li>load R3,xyz</li>
<li>store R4,total</li>
</ul></li>
<li>Why?</li>
<li><p>This is part of a general and powerful technique called </p></li>
</ul>
<h3 id="address-arithmetic-1">Address arithmetic</h3>
<ul>
<li>Every piece of data in the computer (in registers, or memory) is a </li>
<li><p>A word can represent several different kinds of data</p></li>
<li>So far, we’ve just been using </li>
<li><p>Represented with : <span class="math inline"> − 2<sup>15</sup>, …,  − 1, 0, 1, 2, …, 2<sup>15</sup> − 1</span></p></li>
<li>Now, we’ll start doing computations with  too</li>
<li><p>Addresses are : <span class="math inline">0, 1, 2, …, 65535</span></p></li>
</ul>
<h3 id="what-can-you-do-with-address-arithmetic">What can you do with address arithmetic?</h3>
<ul>
<li><p>Powerful data structures</p>
<ul>
<li> Arrays</li>
<li>Pointers and records</li>
<li>Linked lists, queues, dequeues, stacks, trees, graphs, hash tables, <span class="math inline">…</span> Subject of </li>
</ul></li>
<li><p>Powerful control structures</p></li>
<li>Input/Output</li>
<li>Procedures and functions</li>
<li>Recursion</li>
<li>Case dispatch</li>
<li><p>Coroutines, classes, methods</p></li>
</ul>
<h2 id="arrays">Arrays</h2>
<h3 id="data-structures">Data structures</h3>
<ul>
<li>An ordinary variable holds one value (e.g. an integer)</li>
<li>A  can hold many individual elements</li>
<li>A data structure is a </li>
<li>The simplest data structure: </li>
<li>There are many more data structures!</li>
<li>The key idea: {we will do arithmetic on addresses}</li>
</ul>
<h3 id="arrays-1">Arrays</h3>
<ul>
<li><p>In mathematics, an array (vector) is a sequence of indexed values <span class="math inline"><em>x</em><sub>0</sub>, <em>x</em><sub>1</sub>, …, <em>x</em><sub><em>n</em> − 1</sub></span></p>
<ul>
<li><span class="math inline"><em>x</em></span> is the entire array</li>
<li><span class="math inline"><em>x</em><sub>3</sub></span> is one specific element of the array with index 3</li>
<li>It’s useful to refer to an arbitrary element by using an integer variable as index: <span class="math inline"><em>x</em><sub><em>i</em></sub></span></li>
</ul></li>
<li>Arrays are ubiquitous: used in all kinds of applications</li>
<li><p>In programming languages, we refer to <span class="math inline"><em>x</em><sub><em>i</em></sub></span> as </p></li>
</ul>
<h3 id="representing-an-array">Representing an array</h3>
<ul>
<li>An array is represented in a computer by placing the elements in consecutive memory locations</li>
<li>The array x starts in memory at some location: here, it’s 01a5</li>
<li>The address of the array x is the address of its first element x[0]</li>
<li>The elements follow in consecutive locations</li>
</ul>




<h3 id="allocating-an-array">Allocating an array</h3>
<ul>
<li>An array is in memory along with other data — after the trap that terminates the program</li>
<li>You can allocate the elements and give them initial value with data statements</li>
<li>Use the name of the array as a label on the first element (the one with index 0)</li>
<li>Don’t put labels on the other elements</li>
</ul>
<h3 id="example-of-array-allocation">Example of array allocation</h3>
<pre><code>   ...
      trap   R0,R0,R0  ; terminate

; Variables and arrays

abc   data    25       ; some variable
n     data     6       ; size of array x

x     data    13       ; x[0]
      data   189       ; x[1]
      data   870       ; x[2]
      data    42       ; x[3]
      data     0       ; x[4]
      data  1749       ; x[5]

def   data     0       ; some other variable</code></pre>
<h3 id="what-about-big-arrays">What about big arrays?</h3>
<ul>
<li>In the programs we’ll work with, the arrays will be small (a dozen elements or so)</li>
<li>In real scientific computing, it’s common to have large arrays with thousands — or even millions — of elements</li>
<li>It would be horrible to have to write thousands of data statements!</li>
<li><p>In large scale software, arrays are allocated  with help from the </p></li>
<li>The user program calculates how large an array it wants, and stores that in a variable (e.g. n = 40000)</li>
<li>It uses a trap to request (from the operating system) a block of memory big enough to hold the array</li>
<li><p>The operating system returns the address of this block to the user program</p></li>
<li><p>We won’t be doing this: we will just allocate small arrays using data statements</p></li>
</ul>
<h3 id="indexed-addressing">Indexed addressing</h3>
<h3 id="accessing-an-element-of-an-array">Accessing an element of an array</h3>
<ul>
<li>Suppose we have array x with elements x[0], x[1], …, x[n-1]</li>
<li>Elements are stored in consecutive memory locations</li>
<li>Use the label x to refer to the array; x is also the location of x[0]</li>
<li>{The address of x[i] is x+i}</li>
<li>To do any calculations on x[i], we must load it into a register, or store a new value into it</li>
<li></li>
<li>If you try  the effect will be R4 := x[0]</li>
<li>We need a way to access x[i] where i is a variable</li>
</ul>
<h3 id="effective-address-1">Effective address</h3>
<ul>
<li><p>An RX instruction specifies addresses in two parts, for example  or  or </p>
<ul>
<li>The  is a 16 bit constant (you can write the number, or use a name — the assembler will put in the address for you)</li>
<li>The  is written in brackets</li>
</ul></li>
<li>The machine adds the displacement to the value in the index register — this is called the </li>
<li><p>The instruction is performed using the effective address</p></li>
</ul>
<h3 id="using-the-effective-address">Using the effective address</h3>
<p>The addressing mechanism is flexible!</p>
<ul>
<li>You can access an ordinary variable:\ \ R0 always contains 0, so the effective address is just the address of sum</li>
<li>You can access an array element: if R8 contains an index i, then\ \ will load x[i] into R2</li>
<li>There’s more: effective addresses are used to implement pointers, functions, procedures, methods, classes, instances, jump tables, case dispatch, coroutines, records, interrupt vectors, lists, heaps, trees, forests, graphs, hash tables, activation records, stacks, queues, dequeues, <span class="math inline">…</span></li>
</ul>
<h3 id="addressing-modes">Addressing modes</h3>
<ul>
<li>An  is a scheme for specifying the address of data</li>
<li>Sigma16 has one addressing mode: displacement[index], e.g. x[R4]</li>
<li>Many older computers provided many addressing modes: one for variables, another for arrays, yet another for linked lists, still another for stacks, and so on</li>
<li>It’s more efficient to provide just one or two flexible addressing modes, rather than a big collection of them</li>
</ul>
<h3 id="using-effective-address-for-an-array">Using effective address for an array</h3>
<p>Suppose we want to execute </p>
<pre><code>    lea   R1,50[R0]   ; R1 := 50
    load  R5,i[R0]    ; R5 := i
    load  R6,x[R5]    ; R6 := x[i]
    add   R6,R6,R1    ; R6 := x[i] + 50
    store R6,x[R5]    ; x[i] := x[i] + 50</code></pre>
<h3 id="array-traversal-and-for-loops">Array traversal and for loops</h3>
<h3 id="array-traversal">Array traversal</h3>
<ul>
<li>A typical operation on an array is to  it</li>
<li>That means to perform a calculation on each element</li>
</ul>
<p>Here’s a loop that doubles each element of x:</p>
<pre><code>i := 0;
while i &lt; n do
  { x[i] := x[i] * 2;
    i := i + 1;
  }</code></pre>
<h3 id="for-loops">For loops</h3>
<ul>
<li>A for loop is designed specifically for array traversal</li>
<li>It handles the loop index automatically</li>
<li>It sets the index to each array element index and executes the body</li>
<li>The intuition is </li>
</ul>
<pre><code>for i := exp1 to exp2 do
   { statements }</code></pre>
<h3 id="array-traversal-with-while-and-for">Array traversal with while and for</h3>
<p>Here is the program that doubles each element of x, written with both constructs</p>
<pre><code>i := 0;
while i &lt; n do             for i := 0 to n-1 do
  { x[i] := x[i] * 2;          { x[i] := x[i] * 2; }
    i := i + 1;
  }</code></pre>
<h3 id="translating-the-for-loop-to-low-level">Translating the for loop to low level</h3>
<p>High level for loop (with any number of statements in the body) ~~~~ for i := exp1 to exp2 do { statement1; statement2; } ~~~~</p>
<p>Translate to low level with this pattern:</p>
<pre><code>       i := exp1;
loop:  if i &gt; exp2 then goto loopdone;
       statement1;
       statement2;
       i := i + 1;
       goto loop;
loopdone:</code></pre>
<p>It’s straightforward to complete the translation to assembly language.</p>
<h3 id="alternative-syntax-for-for-loops">Alternative syntax for for loops</h3>
<p>In languages derived from C (C++, Java, C#, and many more) you will see for loops written like this:</p>
<pre><code>for (i=x; i&lt;y; i++)
   { S1; }
S2;</code></pre>
<h3 id="example-program-arraymax">Example program ArrayMax</h3>
<ul>
<li>A complete programming example</li>
<li>The problem: find the maximum element of an array</li>
<li><p>To do this we need to</p></li>
<li>Allocate an array</li>
<li>Loop over the elements</li>
<li>Access each element</li>
<li><p>Perform a conditional</p></li>
<li><p>This example puts all our techniques together into one program</p></li>
</ul>
<h3 id="state-what-the-program-does">State what the program does</h3>
<p>; Program ArrayMax ; John O’Donnell</p>
<p>;——————————————————————— ; The program finds the maximum element of an array. It is given ; * a natural number n, assume n&gt;0 ; * an n-element array x[0], x[1], …, x[n-1] ; and it calculates ; * max = the maximum element of x</p>
<p>; Since n&gt;0, the array x contains at least one element, and a maximum ; element is guaranteed to exist. ~~~~ }</p>
<h3 id="high-level-algorithm">High level algorithm}</h3>
<p>;——————————————————————— ; High level algorithm</p>
<p>; max := x[0]; ; for i := 1 to n-1 do ; { if x[i] &gt; max ; then max := x[i]; ; } ~~~~ }</p>
<p>%———————————————————————</p>
<h3 id="translate-high-level-code-to-low-level-goto-form">Translate high level code to low level ``goto form’’</h3>
<p>It’s easier to check that this low level is equivalent to both the high level algorithm and the assembly language, rather than translating all the way to assembly language in one giant step.</p>
<p>;——————————————————————— ; Low level algorithm</p>
<p>; max := x[0] ; i := 1 ; forloop: ; if i &gt;= n then goto done ; if x[i] &lt;= max then goto skip ; max := x[i] ; skip: ; i := i + 1 ; goto forloop ; done: ; terminate ~~~~ }</p>
<h3 id="specify-how-the-registers-are-used">Specify how the registers are used</h3>
<p>The program is written in the ``register variable style’’.</p>
<pre><code>
;---------------------------------------------------------------------
; Assembly language

; Register usage
;   R1 = constant 1
;   R2 = n
;   R3 = i
;   R4 = max</code></pre>
<p>}</p>
<h3 id="block-of-statements-to-initialise-registers">Block of statements to initialise registers</h3>
<p>; Initialise lea R1,1[R0] ; R1 = constant 1 load R2,n[R0] ; R2 = n ; max := x[0] load R4,x[R0] ; R4 = max = x[0] ; i := 1 lea R3,1[R0] ; R3 = i = 1</p>
<h3 id="beginning-of-loop">Beginning of loop</h3>
<p>; Top of loop, determine whether to remain in loop forloop ; if i &gt;= n then goto done cmp R3,R2 ; compare i, n jumpge done[R0] ; if i&gt;=n then goto done</p>
<h3 id="body-of-loop-if-then">Body of loop: if-then</h3>
<p>; if x[i] &lt;= max then goto else load R5,x[R3] ; R5 = x[i] cmp R5,R4 ; compare x[i], max jumple skip[R0] ; if x[i] &lt;= max then goto skip</p>
<p>; max := x[i] add R4,R5,R0 ; max := x[i]</p>
<h3 id="end-of-loop">End of loop</h3>
<p>skip ; i := i + 1 add R3,R3,R1 ; i = i + 1 ; goto forloop jump forloop[R0] ; go to top of forloop ~~~~</p>
<h3 id="finish">Finish</h3>
<p>; Exit from forloop done store R4,max[R0] ; max = R4 ; terminate trap R0,R0,R0 ; terminate</p>
<h3 id="data-definitions">Data definitions</h3>
<p>; Data area</p>
<p>n data 6 max data 0 x data 18 data 3 data 21 data -2 data 40 data 25</p>
<h2 id="programming-tips">Programming tips</h2>
<p>Standard idioms for common programming problems</p>
<h3 id="a-useful-convention">A useful convention</h3>
<ul>
<li><p>The instruction set is designed to be regular, and to follow consistent conventions</p>
<ul>
<li>This makes programming easier</li>
<li>It also helps with the hardware design!</li>
</ul></li>
<li><p>For most instructions, the operands follow the pattern of an assignment statement: information goes right to left</p></li>
<li>Assignment statement: </li>
<li>Add instruction: </li>
<li>The two operands on the right (R2, R3) are added, and placed in the destination on the left (R1)</li>
<li><p>Load instruction:  means </p></li>
<li><p></p></li>
<li> means x := R1: the information goes from left to right</li>
<li><p>Why? Doing it this way makes the digital circuit (the processor) a little bit faster</p></li>
</ul>
<h3 id="programming-tip-copying-one-register-to-another">Programming tip: Copying one register to another</h3>
<ul>
<li>Here’s a useful tip — a standard programming technique</li>
<li><p>Sometimes you want to copy a value from one register to another</p></li>
<li><p>R3 := R12</p></li>
<li><p>There’s a standard way to do it:</p></li>
<li><p></p></li>
<li>The idea is that R12 + 0 = R12!</li>
<li><p>Why do it this way? </p></li>
</ul>
<h3 id="using-load-and-store">Using load and store</h3>
<ul>
<li>A common error is to confuse load and store</li>
<li><p>The main points to remember:</p></li>
<li>We need to keep variables in memory (most of the time) because memory is big — there aren’t enough registers to hold all your variables</li>
<li>The computer hardware can do arithmetic on data in registers, but it cannot do arithmetic on data in memory</li>
<li>Therefore, to do arithmetic on variables, you must</li>
</ul>
<h3 id="compilation-patterns-2">Compilation patterns</h3>
<ul>
<li><p>We have looked at several high level programming constructs</p>
<ul>
<li>if  then </li>
<li>if  then  else </li>
<li>while  do </li>
<li>for  :=  to  do </li>
</ul></li>
<li>There is a standard way to translate each to low level form: assignment, goto , if  then goto </li>
<li><p>The low level statements correspond closely to instructions</p></li>
</ul>
<h3 id="follow-the-patterns">Follow the patterns!</h3>
<p>You should use these patterns as you write your programs because</p>
<ul>
<li>This helps you understand  what high level language constructs mean—this is one of the aims of the course.</li>
<li>This is essentially how real compilers work, and this is another aim of the course.</li>
<li><p>This saves time because</p></li>
<li>It’s quicker to catch errors at the highest level (e.g. translating if-then-else to goto) rather than the lowest level (instructions)</li>
<li><p>It makes the program more readable, and therefore faster to check and to debug</p></li>
<li>This leads to good comments that make the program more readable</li>
<li>This approach scales up to large programs</li>
<li><p></p></li>
</ul>
<h3 id="how-can-you-tell-if-youre-using-the-pattern">How can you tell if you’re using the pattern?</h3>
<ul>
<li><p>Each pattern contains</p>
<ul>
<li>Changeable parts: boolean expressions, integer expressions, statements</li>
<li>Fixed parts: goto, if-then-goto</li>
<li>The labels have to be different every time, but the structure of the fixed parts never changes</li>
</ul></li>
<li><p>Example: translating a while loop</p></li>
<li>There should be one comparison, one conditional jump at the start of the loop</li>
<li><p>There should be one unconditional jump at the end of the loop</p></li>
</ul>
<h3 id="are-you-using-the-pattern">Are you using the pattern?</h3>
<p></p>
<p>{   \  }</p>

<p></p>
<p>{ \   \ \ \  }</p>

<ul>
<li>The blue text is fixed (except you need to use unique labels)</li>
<li>There should be one comparison, one conditional jump at the start of the loop</li>
<li>There should be one unconditional jump at the end of the loop</li>
</ul>
<h3 id="can-you-gain-efficiency-by-violating-the-pattern">Can you gain efficiency by violating the pattern?</h3>
<ul>
<li>No! Example: avoid the cost of jumping to a test that jumps out of the loop by transforming the while loop to\ {\   \ \ \   \ }\</li>
<li><p>But consider:</p></li>
<li>Even if the loop executes a million times, this version saves  one jump instruction</li>
<li>And the code is longer, which likely makes it slower (because of cache—haven’t reached that topic yet)</li>
<li>And when you do this in a large program it becomes incomprehensible</li>
<li><p></p></li>
</ul>
<h3 id="comments-1">Comments</h3>
<ul>
<li>Initial comments to identify the program, author, date</li>
<li>Early comments to say what the program does</li>
<li>High level algorithm (in comments)</li>
<li>Translation to low level algorithm (in comments)</li>
<li><p>Translation to assembly language (with comments)</p></li>
<li>Copy the low level algorithm comments, and paste, so you have two copies</li>
<li>The first copy remains as the low level algorithm</li>
<li>In the second copy, insert the assembly language code</li>
<li><p>Every low level statement should appear as a comment in the assembly code</p></li>
</ul>
<h3 id="write-the-comments-first">Write the comments first!</h3>
<ul>
<li>The program development methodology entails writing the comments </li>
<li>Avoid the temptation of writing code first, hacking it until it appears to work, and then adding comments</li>
<li>The comments, the high and low level algorithms, </li>
</ul>
<h3 id="why-is-goto-controversial">Why is goto controversial?</h3>
<ul>
<li>If you develop code randomly, with goto jumping all over the place, the program is hard to understand, unlikely to work, and difficult to debug</li>
<li>This has given the goto statement a bad reputation</li>
<li>But goto is  for a compiler because it’s essentially the jump instruction</li>
<li>The compilation patterns provide a  and  way to introduce goto into a program</li>
<li>But if you ignore the patterns, you lose these advantages</li>
<li></li>
</ul>
<p></p>
<h3 id="goto-considered-harmful-3-march-1968">Goto considered harmful:  (3), March 1968}</h3>
<p></p>
<h3 id="what-happened-next">What happened next?</h3>
<ul>
<li><p>Considered harmful</p>
<ul>
<li>Dozens (hundreds?) of  essays</li>
</ul></li>
<li><p>Goto elimination</p></li>
<li><p>Theorem:  program using goto can be expressed without goto, using while and if-then-else</p></li>
<li><p>Structured programming</p></li>
<li><p>A positive, effective way to develop programs (instead of focusing on eliminating goto)</p></li>
</ul>
<h2 id="records">Records</h2>
<h3 id="records-1">Records}</h3>
<p>A  contains several . Access a field with the dot (.) operator</p>
<pre><code>;   x, y :
;     record
;       { fieldA : int;
;         fieldB : int;
;         fieldC : int;
;       }
;
;   x.fieldA := x.fieldB + x.fieldC;
;   y.fieldA := y.fieldB + y.fieldC;</code></pre>
<p>(Some programming languages call it a  or .)</p>
<h3 id="defining-some-records">Defining some records</h3>
<pre><code>; Data definitions

; The record x
x
x_fieldA   data   3    ; offset 0 from x  &amp;x_fieldA = &amp;x
x_fieldB   data   4    ; offset 1 from x  &amp;x_fieldB = &amp;x + 1
x_fieldC   data   5    ; offset 2 from x  &amp;x_fieldC = &amp;x + 2

; The record y
y
y_fieldA   data  20    ; offset 0 from y  &amp;y_fieldA = &amp;y
y_fieldB   data  21    ; offset 1 from y  &amp;y_fieldB = &amp;y + 1
y_fieldC   data  22    ; offset 2 from y  &amp;y_fieldC = &amp;y + 2</code></pre>
<h3 id="naming-each-field-explicitly">Naming each field explicitly</h3>
<pre><code>; ------------------------------------------------------------
; Simplistic approach, with every field of every record named
; explicitly

; In record x,  fieldA := fieldB + fieldC

; x.fieldA := x.fieldB + x.fieldC
    load   R1,x_fieldB[R0]
    load   R2,x_fieldC[R0]
    add    R1,R1,R2
    store  R1,x_fieldA[R0]</code></pre>
<p>This is awkward—but there’s a better way!</p>
<h3 id="pointers">Pointers</h3>
<p>So far, we have been finding a piece of data by giving it a label</p>
<pre><code>     load    R2,xyz[R0]
...
xyz  data  5</code></pre>
<p>An alternative way to find the data is to make a  to it</p>

<p></p>

<p> means the address of x: a pointer to x. You can apply the &amp; operator to a variable but not to a complex expression</p>
<ul>
<li> is ok</li>
<li> is not ok</li>
</ul>

<p> means the value that p points to. You can apply the * operator to any pointer.</p>
<h3 id="expressions-using-pointers">Expressions using pointers</h3>
<ul>
<li><p>The &amp; operator gives the address of its operand</p>
<ul>
<li> puts the  of x into p</li>
<li> puts the  of x into p. The address of x is called a , and we say ``p points at x’’.</li>
</ul></li>
<li><p>The * operator follows a pointer and gives whatever it points to</p></li>
<li> is an expression whose value is whatever p points at</li>
<li> stores p into y, so y is also now a pointer to x</li>
<li><p>  p, gets the value (which is x) and stores that in y</p></li>
</ul>
<h3 id="the-operator-requires-only-one-instruction-lea">The &amp; operator requires only one instruction: lea!</h3>
<pre><code>     lea   R5,x[R0]    ; R5 := &amp;x
...
     lea   R6,y[R0]    ; R6 := &amp;y
     store R6,p[R0]    ; p := &amp;y
...
x    data  25
y    data  0
p    data  0</code></pre>
<h3 id="the-operator-requires-only-one-instruction-load">The * operator requires only one instruction: load!</h3>
<pre><code>     load   R7,p[R0]    ; R7 := p
     load   R8,0[R7]    ; R8 := *p</code></pre>
<h3 id="flexibility-of-load-and-lea">Flexibility of load and lea</h3>
<p>We have now seen two ways to use lea:</p>
<ul>
<li>To load a constant into a register: lea R1,42[R0] ; R1 := 42</li>
<li>To create a pointer: lea R2,x[R0] ; R2 := &amp;x</li>
<li>lea can do more, too — can you figure out what?</li>
</ul>
<p>And there are several ways to use load:</p>
<ul>
<li>To load a variable into a register: load R3,x[R0] ; R3 := x</li>
<li>To access an array element: load R4,a[R5] ; R4 := a[R5]</li>
<li>To follow a pointer: load R6,0[R7] ; R6 := *R7</li>
</ul>
<h3 id="following-a-pointer-to-the-address-of-x-gives-x">Following a pointer to the address of x gives x}</h3>
<p>The value of  is just !</p>

<pre><code>   lea    R4,x[R0]    ; R4 := &amp;x
   load   R5,0[R4]    ; R5 := *(&amp;x) = x

   load   R6,x[R0]    ; R6 := x</code></pre>
<h3 id="review-accessing-a-variable-the-ordinary-way">Review: accessing a variable the ordinary way</h3>
<p> ~~~~ x := x + 5; ~~~~</p>

<p> ~~~~ ; Accessing variable x by its address, with R0 lea R1,5[R0] ; R1 := 5 (constant) load R2,x[R0] ; R2 := x add R2,R2,R1 ; R2 := x + 5 store R2,x[R0] ; x := x + 5 ~~~~</p>
<h3 id="accessing-a-variable-through-a-pointer">Accessing a variable through a pointer</h3>
<p> ~~~~ x := x + 5; ~~~~</p>

<p> ~~~~ ; Put a pointer to x into R3, which contains the address of x ; R3 := &amp;x lea R3,x[R0] ; R3 := &amp;x</p>
<p>; Add 5 to whatever word R3 points to lea R1,5[R0] ; R1 := 5 (constant) load R4,0[R3] ; R4 := <em>R3 add R4,R4,R1 ; R4 := </em>R3 + 5 store R4,0[R3] ; <em>R3 := </em>R3 + 5 ~~~~</p>
<p>Equivalent to </p>
<h3 id="why-is-the-pointer-helpful">Why is the pointer helpful?</h3>
<ul>
<li>We can write a block of code that accesses variables through pointers.<br />
</li>
<li>This can be , by executing it with the pointer set to point to different data.</li>
<li>Later, we’ll see additional benefits of using pointers.</li>
</ul>
<h3 id="access-a-record-using-a-pointer">Access a record using a pointer</h3>
<pre><code>; Make the same code work for any record with the same fields

; Set x as the current record by making R3 point to it
    lea    R3,x[R0]    ; R3 := &amp;x

; Perform the calculation on the record that R3 points to
    load   R1,1[R3]    ; R1 := (*R3).fieldB
    load   R2,2[R3]    ; R2 := (*R3).fieldC
    add    R1,R1,R2    ; R1 := (*R3).fieldB + (*R3).fieldC
    store  R1,0[R3]    ; *R3.fieldA := (*R3).fieldB + (*R3).fieldC</code></pre>
<h2 id="requests-to-the-operating-system">Requests to the Operating System</h2>
<ul>
<li><p>Many operations cannot be performed directly by a user program because</p>
<ul>
<li></li>
<li>Also, some operations are difficult to program</li>
<li>The code would need to change when OS is updated</li>
</ul></li>
<li>The program requests the operating system to perform them</li>
<li>An OS request is performed by executing a  instruction, such as </li>
<li> (and you don’t have to give the address to jump to)</li>
<li><p>We use pointers to tell the operating system what to do</p></li>
</ul>
<h3 id="typical-os-requests">Typical OS requests</h3>
<ul>
<li>The type of request is a number, placed in R1, and operands (if any) are in R2, R3</li>
<li>The specific codes used to make a request are defined by the operating system, not by the hardware</li>
<li>{This is a major reason why compiled programs run only on one operating system}</li>
<li><p>Typical requests:</p>
<ul>
<li>Terminate execution of the program</li>
<li>Read from a file</li>
<li>Write to a file</li>
<li>Allocate a block of memory</li>
</ul></li>
</ul>
<h3 id="termination">Termination</h3>
<ul>
<li>A program cannot stop the machine; it requests the operating system to terminate it</li>
<li>The operating system then removes the program from its tables of running programs, and reclaims any resources dedicated to the program</li>
<li>In Sigma16, you request termination by </li>
</ul>
<h3 id="character-strings-pointer-to-array-of-characters">Character strings: pointer to array of characters</h3>
<ul>
<li>A string like  is represented as an array of characters</li>
<li>Each element of the array contains one character</li>
<li>If you are writing a string to output, the last character of the string should be a ``newline character’’</li>
</ul>
<h3 id="write-operation-on-sigma16">Write operation on Sigma16}</h3>
<p>To write a string of characters</p>
<ul>
<li>trap R1,R2,R3</li>
<li>R1 — 2 is the code that indicates a write request</li>
<li>R2 — address of first word of string to write</li>
<li>R3 — length of string (the last word should be newline character)</li>
<li>See example program Write.asm.txt</li>
</ul>
<h3 id="writing-a-string">Writing a string}</h3>
<p>To write a string named , we use (1) lea to load a constant, (2) lea to load the address of an array, (3) load to get a variable</p>
<pre><code>; write out (size = k)
     lea    R1,2[R0]         ; trap code: write
     lea    R2,animal[R0]    ; address of string to print
     load   R3,k[R0]         ; string size = k
     trap   R1,R2,R3         ; write out (size = k)

     trap   R0,R0,R0         ; terminate

k    data   4    ; length of animal
; animal = string &quot;cat&quot;
animal
     data   99   ; character code for &#39;c&#39;
     data   97   ; character code for &#39;a&#39;
     data  116   ; character code for &#39;t&#39;
     data   10   ; character code for newline</code></pre>
<p>}</p>
<h2 id="procedures">Procedures</h2>
<ul>
<li><p>Often there is a sequence of instructions that comes up again and again</p>
<ul>
<li>For example: sqrt (square root)</li>
<li>It takes a lot of instructions to calculate a square root</li>
<li>An application program may need a square root in many different places</li>
</ul></li>
<li><p>We don’t want to keep repeating the code</p></li>
<li>It’s tedious</li>
<li><p>It wastes space (all those instructions require memory!)</p></li>
<li><p>The aim:  and </p></li>
<li>Write the code  — the block of code is called a procedure (or subroutine, function)</li>
<li>Put the instructions off by themselves somewhere, not in the main flow of instructions</li>
<li>Give the block of code a label (e.g. work) that describes what it does</li>
<li>Every time you need to perform this computation, : go to work</li>
<li><p>When it finishes, </p></li>
</ul>
<h3 id="call-and-return">Call and return</h3>
<ul>
<li>One idea is just to use jump instructions for both call and return</li>
<li>But that isn’t actually sufficient — let’s look in more detail at what happens</li>
</ul>
<h3 id="returning-to-the-instruction-after-the-call">Returning to the instruction after the call</h3>
<ul>
<li>Suppose a procedure named {dowork} is used in several places</li>
<li>Each call jumps to the same place (the address of the first instruction of the procedure</li>
<li>But the calls </li>
<li>Therefore the procedure must finish by </li>
</ul>
<h3 id="calling-and-returning">Calling and returning</h3>
<p>Here is a main program that calls a procedure ``dowork’’ several times. (It takes the value in R1 and doubles it, and the main program would use the result but we ignore that here.)</p>



<p></p>
<p> (call1) to [out=180, in=175] (entry.west);  (return.east) to [out=10, in=0] (ret1.east);  (call2) to [out=2000, in=150] (entry.north west);  (return.north east) to [out=45, in=0] (ret2.east);</p>
<h3 id="the-jump-and-link-instruction-jal">The jump-and-link instruction: jal</h3>
<ul>
<li>When the main program calls the subroutine, it needs to </li>
<li>This is the purpose of the  instruction — jump and link</li>
<li><p></p></li>
<li>A  — the return address — is loaded into the destination register (e.g. R5)</li>
<li><p>Then the machine jumps to the effective address</p></li>
</ul>
<h3 id="jumping-1">Jumping</h3>
<p>All jump instructions (jump, jal, jumplt, etc.) refer to </p>
<ul>
<li>jump  \ { goto loop}</li>
<li>jump  \ { goto instruction whose address is in R14}</li>
<li>jump  \ { goto instruction whose address is const+R2}</li>
</ul>
<h3 id="implementing-call-and-return">Implementing call and return</h3>
<ul>
<li><p>To call a procedure : </p>
<ul>
<li>The address of the instruction  the jal is placed in R13</li>
<li>The program jumps to the effective address, and the procedure starts executing</li>
</ul></li>
<li><p>To return when the procedure has finished: </p></li>
<li>The effective address is 0 + the address of the instruction after the jal</li>
<li><p>The program jumps there and the main program resumes</p></li>
</ul>
<h3 id="calling-with-jal-and-returning-with-jump">Calling with jal and returning with jump</h3>


<ul>
<li> — jal puts a pointer to the next instruction into R13</li>
<li>{return} — follow the pointer in R13</li>
</ul>
<p> (call1) to [out=180, in=175] (entry.west);  (return.east) to [out=10, in=0] (ret1.east);  (call2) to [out=2000, in=150] (entry.north west);  (return.north east) to [out=45, in=0] (ret2.east);</p>
<h3 id="parameter-passage">Parameter passage</h3>
<ul>
<li>There are several different conventions for passing argument to the function, and passing the result back</li>
<li>What is important is that the caller and the procedure agree on how information is passed between them</li>
<li>If there is a small number of arguments, the caller may put them in registers before calling the procedure</li>
<li>If there are many arguments, the caller builds an array or vector (sequence of adjacent memory locations), puts the arguments into the vector, and passes the address of the vector in a register (typically R1)</li>
<li>A simple convention: </li>
</ul>
<h3 id="functions">Functions</h3>
<ul>
<li><p>A  is a procedure that</p>
<ul>
<li>Receives a parameter (a word of data) from the caller</li>
<li>Calculates a result</li>
<li>Passes the result back to the caller when it returns</li>
</ul></li>
<li><p>A  is a function that doesn’t do anything else — it doesn’t change any global variables, or do any input/output</p></li>
</ul>
<h3 id="example-passing-argument-and-result-in-r1">Example: Passing argument and result in R1</h3>
<pre><code>; Main program
       load  R1,x[R0]       ; arg = x
       jal   R13,work[R0]   ; result = work (x)
       ...
       load  R1,y[R0]       ; arg = y
       jal   R13,work[R0]   ; result = work (y)
       ...

; Function work (x) = 1 + 7*x
work   lea   R2,7[R0]       ; R7 = 2
       lea   R3,1[R0]       ; R3 = 1
       mul   R1,R1,R2       ; result = arg * 7
       add   R1,R3,R1       ; result = 1 + 7*arg
       jump  0[R13]         ; return</code></pre>
<h3 id="procedure-calls-another-procedure">Procedure calls another procedure</h3>
<h3 id="what-if-a-procedure-calls-another-procedure">What if a procedure calls another procedure?</h3>
<ul>
<li><p>The simplest kind of procedure</p>
<ul>
<li>Call it with </li>
<li>It returns by executing </li>
</ul></li>
</ul>
<h3 id="limitations-of-basic-call">Limitations of basic call</h3>
<ul>
<li>If the procedure modifies any registers, it may destroy data belonging to the caller
<ul>
<li>If the procedure calls another procedure, it can’t use R13 again. Each procedure would need a dedicated register for its return address, limiting the program to a small number of procedures</li>
<li>The basic call mechanism doesn’t allow a procedure to call itself (this is called )</li>
</ul></li>
</ul>
<h3 id="r13-overwritten-proc1-returns-to-the-wrong-place">R13 overwritten: proc1 returns to the wrong place!</h3>

<h3 id="saving-state">Saving state</h3>
<ul>
<li><p>Calling a procedure creates new information</p>
<ul>
<li>The return address</li>
<li>Whatever values the procedure loads into the registers</li>
</ul></li>
<li>But this new information could overwrite essential information belonging to the caller</li>
<li><p>We need to  so the procedure won’t destroy it</p></li>
</ul>
<h3 id="the-wrong-way-to-save-state">The wrong way to save state</h3>
<ul>
<li>Suppose we just have a variable saveRetAdr</li>
<li>Store R13 into it in the procedure, load that when we return</li>
<li>Now it’s ok for proc1 to call proc2</li>
<li>But if proc2 calls proc3 we are back to the same problem: it doesn’t work!</li>
<li>The solution: a </li>
</ul>
<h3 id="saving-registers">Saving registers</h3>
<ul>
<li>Most procedures need to use several registers</li>
<li>It’s nearly impossible to do  without using some registers!</li>
<li>The first thing a procedure should do is to  it will use by copying them into memory (with store instructions).</li>
<li>The last thing it should do before returning is to  by copying their values back from memory (with load instructions).</li>
</ul>
<h3 id="where-can-the-registers-be-saved">Where can the registers be saved?</h3>
<ul>
<li>It won’t work to copy data from some of the registers to other registers!</li>
<li>It’s essential to save the data into memory</li>
<li><p>Two approaches</p></li>
<li>Allocate fixed variables in memory to save the registers into — simple but doesn’t allow recursion</li>
<li><p>Maintain a  in memory, and  the data onto the stack — this is the best approach and is used by most programming languages</p></li>
</ul>
<h3 id="who-saves-the-state-the-caller-or-the-procedure">Who saves the state: the caller or the procedure?</h3>
<ul>
<li>Two approaches:
<ul>
<li><p>Caller saves (used occasionally)</p></li>
<li>Before calling a procedure, the caller saves the registers, so all its essential data is in memory</li>
<li><p>After the procedure returns, the caller does whatever loads are needed</p></li>
<li><p>Callee saves (usually the preferred solution)</p></li>
<li>The caller keeps data in registers, and assumes that the procedure won’t disturb it</li>
<li>The first thing the procedure does is to save the registers it needs to use into memory</li>
<li><p>Just before returning, the procedure restores the registers by loading the data from memory</p></li>
</ul></li>
</ul>
<h3 id="stack-of-return-addresses">Stack of return addresses</h3>
<ul>
<li>To allow a large number of procedures, we can’t dedicate a specific register to each one for its return address</li>
<li><p>Therefore we</p></li>
<li>Always use the same register for the return address in a jal instruction (we will use R13)</li>
<li>The first thing a procedure does is to store its return address into memory</li>
<li>The last thing the procedure does is to load its return address and jump to it</li>
<li><p>The return addresses are pushed onto a , rather than being stored at a fixed address</p></li>
</ul>
<h2 id="stacks">Stacks</h2>
<ul>
<li>A  is a container</li>
<li>Initially it is empty</li>
<li>You can  a value onto the stack; this is now sitting on the top of the stack</li>
<li>You can  the stack; this removes the  value and returns it</li>
<li>A stack allows access only to the top value; you cannot access anything below the top</li>
<li>We can save procedure return addresses on a stack because return always needs the most recently saved return address</li>
</ul>
<h3 id="initially-the-stack-is-empty">Initially the stack is empty}</h3>

<h3 id="call-procedure-push-return-address-a">Call procedure, push return address <span class="math inline"><em>a</em></span></h3>

<h3 id="call-another-procedure-push-return-address-b">Call another procedure, push return address <span class="math inline"><em>b</em></span></h3>

<h3 id="return-pop-produces-return-address-b">Return: pop produces return address <span class="math inline"><em>b</em></span></h3>

<h3 id="call-some-procedure-push-return-address-c">Call some procedure, push return address <span class="math inline"><em>c</em></span></h3>

<h3 id="call-a-procedure-push-return-address-d">Call a procedure, push return address <span class="math inline"><em>d</em></span></h3>

<h3 id="the-call-stack">The call stack</h3>
<ul>
<li><p>Central technique for</p>
<ul>
<li>Preserving data during a procedure call</li>
<li>Holding most of your variables</li>
</ul></li>
<li><p>It goes by several names; these are all the same thing</p></li>
<li>call stack</li>
<li>execution stack</li>
<li><p>``The stack’’</p></li>
<li><p>It’s important!</p></li>
<li>Most programming languages use it</li>
<li>Computers are designed to support it</li>
<li><p>Often referred to (Stack Overflow web site, etc.)</p></li>
</ul>
<h3 id="stack-frames">Stack frames</h3>
<ul>
<li>There is a  or  that maintains complete information about all procedure calls and returns</li>
<li>Every ``activation’’ of a procedure pushes a </li>
<li>When the procedure returns, its stack frame is popped (removed) from the stack</li>
<li>R14 contains the address of the current (top) stack frame</li>
<li><p>The stack frame contains:</p></li>
<li>A pointer to the previous stack frame (this is required to make the pop work)</li>
<li>The return address (saved value of R13)</li>
<li>The saved registers (so the procedure can use the registers without destroying information)</li>
<li><p>Local variables (so the procedure can have some memory of its own to use)</p></li>
</ul>
<h3 id="implementing-the-call-stack">Implementing the call stack</h3>
<ul>
<li>Dedicate R14 to the </li>
<li>This is a programming convention, not a hardware feature</li>
<li>When the program is started, R14 will be set to point to an empty stack</li>
<li>When a procedure is called, the saved state will be pushed onto the stack: store a word at 0[R14] and add 1</li>
<li>When a procedure returns, it pops the stack and restores the state: subtract 1, load from 0[R14]</li>
<li>The program should never modify R14 apart from the push and pop</li>
</ul>
<h2 id="retrospective">Retrospective</h2>
<h3 id="what-is-a-computer-program">What is a computer program?</h3>
<ul>
<li><p>A beginner’s view</p>
<ul>
<li>The computer runs programs</li>
<li>A program is lines of code of (Python, C, whatever)</li>
</ul></li>
<li>The strange program shows how wrong that is!</li>
<li><p>A more sophisticated view</p></li>
<li>The lines of source code are input to the assembler (compiler) which generates the  value of the machine language</li>
<li>When the program is booted, the initial machine language is stored in memory</li>
<li><p>The computer executes the machine language instructions in memory; the original assembly language code (labels and all) no longer exists</p></li>
<li><p>Essential concepts:</p></li>
<li>Source code and object code</li>
<li><p>Compile time and run time</p></li>
</ul>
<h3 id="what-is-a-variable">What is a variable?</h3>
<ul>
<li><p>Beginner’s view</p>
<ul>
<li>A variable is a box with a name that holds a value</li>
<li>An expression can use the value in the box; an assignment can modify the value in the box</li>
<li>In assembly language, you define a variable with a data statement</li>
</ul></li>
<li><p>A more sophisticated view</p></li>
<li>Variables are distinct from variable names: many variables may have the same name</li>
<li>A variable has a scope in a program: a region where it corresponds to a particular box</li>
<li>Variables do not correspond to data statements: they are created and destroyed dynamically as a program runs</li>
<li><p>Initialising a variable is not the same as assigning a value to it</p></li>
</ul>
<h3 id="review-of-procedures-call-with-jal-return-with-jump">Review of procedures: Call with jal, return with jump</h3>
<ul>
<li><p>To call a procedure : </p>
<ul>
<li>The address of the instruction  the jal is placed in R13</li>
<li>The program jumps to the effective address, and the procedure starts executing</li>
</ul></li>
<li><p>To return when the procedure has finished: </p></li>
<li>The effective address is 0 + the address of the instruction after the jal</li>
<li><p>The program jumps there and the main program resumes</p></li>
</ul>
<h3 id="review-basic-calls-with-jal">Review: Basic calls with jal</h3>
<ul>
<li><p>The simplest kind of procedure</p>
<ul>
<li>Call it with </li>
<li>It returns by executing </li>
</ul></li>
</ul>
<h3 id="review-activation-records-a.k.a.-stack-frames">Review: Activation records, a.k.a. stack frames</h3>
<ul>
<li>There is a  or  that maintains complete information about all procedure calls and returns</li>
<li>Every ``activation’’ of a procedure pushes a </li>
<li>When the procedure returns, its stack frame is popped (removed) from the stack</li>
<li>R14 contains the address of the current (top) stack frame</li>
<li><p>The stack frame contains:</p></li>
<li>A pointer to the previous stack frame (this is required to make the pop work)</li>
<li>The return address (saved value of R13)</li>
<li>The saved registers (so the procedure can use the registers without destroying information)</li>
<li><p>Local variables (so the procedure can have some memory of its own to use)</p></li>
</ul>
<h3 id="review-sequence-of-stack-operations">Review: Sequence of stack operations</h3>

<p>empty; push a; push b, push c, pop returns c, push d, push e, pop returns e, pop returns d, <span class="math inline">…</span></p>
<h3 id="variables">Variables</h3>
<h3 id="access-to-variables">Access to variables</h3>
<ul>
<li>Depending on the programming language, there are several different ways that variables can be allocated</li>
<li>For each of these, there is a corresponding way to access the variable in memory</li>
<li><p>Three key issues:</p></li>
<li>The  of a variable: when it is created, when it is destroyed</li>
<li>The  of a variable: which parts of the source program are able to access the variable</li>
<li><p>The  of a variable: what its address in memory is</p></li>
<li><p>The compiler generates the correct object code to access each variable</p></li>
</ul>
<h3 id="three-classes-of-variable">Three classes of variable</h3>
<ul>
<li> (Sometimes called ) — visible through the entire program</li>
<li> (Sometimes called ) — visible only in a local procedure</li>
<li> (Sometimes called ) — used in object oriented and functional languages</li>
</ul>
<h3 id="static-variables">Static variables</h3>
<ul>
<li><p>The lifetime of a static variable is the entire execution of a program</p>
<ul>
<li>When the program is launched, its static variables are created</li>
<li>They continue to exist, and to retain their values, until the program is terminated</li>
</ul></li>
<li>In C, you can declare a variable to be static. In Pascal, all global variables (i.e. all variables that aren’t defined locally) are static</li>
<li><p></p></li>
</ul>
<h3 id="combining-static-variables-with-code">Combining static variables with code</h3>
<p>The simple way we have been defining variables makes them static</p>
<pre><code>     load  R1,x[R0]    ; R1 := x
   ...
     trap  R0,R0,R0    ; terminate

; Static variables

x    data    0
n    data  100</code></pre>
<p>These variables exist for the entire program execution. There is one variable x, and one variable n.</p>
<h3 id="disadvantages-of-combining-variables-and-code">Disadvantages of combining variables and code</h3>
<ul>
<li><p>The executable code cannot be shared.</p>
<ul>
<li>Suppose two users want to run the program.</li>
<li>Each needs to have a copy of the entire object, which contains both the instructions and the data</li>
<li>That means the instructions are duplicated in memory</li>
<li>This is inefficient use of memory</li>
</ul></li>
<li>To avoid the duplication of instructions, we need to separate the data from the code</li>
<li><p>Modern operating systems organise information into </p></li>
<li>A  is read-only, and can be shared</li>
<li><p>A  is read/write, and cannot be shared</p></li>
</ul>
<h3 id="local-variables">Local variables</h3>
<ul>
<li>Local variables are defined in a function, procedure, method, or in a begin…end block, or a {…} block</li>
<li>A local variable has one name, but there may be many instances of it if the function is recursive</li>
<li>Therefore local variables cannot be stored in the static data segment</li>
<li>They are kept in stack frames</li>
<li>The compiler (or assembler) works out the address of each local variable </li>
<li>The variables are accessed using the stack frame register</li>
</ul>
<h3 id="accessing-local-variables">Accessing local variables</h3>
<pre><code>      load  R1,x[R14]   ; access local variable x; R14 points to frame</code></pre>
<p>}</p>
<ul>
<li>The compiler (or the programmer) works out the exact format of the stack frame</li>
<li>Each local variable has a dedicated spot in the stack frame, and its address (relative to the frame) is used in the load instruction</li>
</ul>
<h3 id="dynamic-variables">Dynamic variables</h3>
<ul>
<li>A  is created explicitly (e.g. using  in Java)</li>
<li>It is not limited to use in just one function</li>
<li>The lifetime of a dynamic variable does not need to follow the order that stack frames are pushed or popped</li>
<li>So dynamic variables can’t be kept in the static data segment, and they can’t be kept on the stack</li>
</ul>
<h3 id="the-heap">The Heap</h3>
<ul>
<li>Languages that support dynamic variables (Lisp, Scheme, Haskell, Java) have a region of memory called the .</li>
<li>The heap typically contains a very large number of very small objects</li>
<li>The heap contains a , a data structure that points to all the free words of memory.</li>
<li>The heap is maintained by the language ``runtime system’’, not by the operating system.</li>
<li>When you do a , a (small) amount of memory is allocated from the heap and a pointer (address) to the object is returned</li>
<li>When the object is no longer required, the memory used to hold it is linked back into the free space list.</li>
</ul>
<h3 id="the-call-stack-1">The call stack</h3>
<ul>
<li>Each procedure call pushes information on the stack</li>
<li>The information needed by the procedure is in the stack frame (also called activation record)</li>
<li>Each procedure return pops information off the stack</li>
<li><p>A register is permanently used as the </p></li>
<li>For each computer architecture, there is a standard register chosen to be the stack pointer</li>
<li>In Sigma16, R14 is the stack pointer</li>
<li>When you call, you push a new stack frame and increase R14</li>
<li>As a procedure runs, it access its data via R14</li>
<li><p>When you return, you set R14 to the stack frame below</p></li>
</ul>
<h3 id="simplest-stack-return-addresses">Simplest stack: return addresses</h3>

<p>Just save the return address on the stack</p>
<h3 id="saved-registers">Saved registers</h3>

<p>Save the registers the procedure needs to use on the stack, and restore them before returning. This way the procedure won’t crash the caller</p>
<h3 id="dynamic-links">Dynamic links</h3>

<p> (dlink3.east) to [out=0, in=0] (dlink2.north east);  (dlink2.east) to [out=0, in=0] (dlink1.north east);</p>
<ul>
<li>Problem: since each activation record can have a different size, how do we pop the top one off the stack?</li>
<li>Simplest solution: each activation record contains a pointer (called dynamic link) to the one below</li>
</ul>
<h3 id="local-variables-1">Local variables</h3>

<p> (dlink3.east) to [out=0, in=0] (dlink2.north east);  (dlink2.east) to [out=0, in=0] (dlink1.north east);</p>
<p>The procedure keeps its local variables on the stack</p>
<h3 id="static-links-for-scoped-variables">Static links for scoped variables</h3>

<p> (dlink3.east) to [out=0, in=0] (dlink2.north east);  (dlink2.east) to [out=0, in=0] (dlink1.north east);</p>
<h3 id="accessing-a-word-in-the-stack-frame">Accessing a word in the stack frame</h3>
<ul>
<li>Work out a ``map’’ showing the format of a stack frame</li>
<li>Describe this in comments (it’s similar to the register usage comments we’ve been using)</li>
<li>Suppose local variable, say ``avacado’’, is kept at position 7 in the stack frame</li>
<li><p>To access the variable:</p></li>
<li>load R1,7[R14] ; R1 := avacado</li>
<li>store R1,7[R14] ; R1 := avacado</li>
<li>Also, we can define the symbol ``avacodo’’ to be 7, and write:</li>
<li>load R1,avacado[R14] ; R1 := avacado</li>
<li><p>store R1,avacado[R14] ; R1 := avacado</p></li>
<li><p>These are called  because every call to a procedure has its own private copy</p></li>
</ul>
<h3 id="example-from-factorial-program-see-below">Example from factorial program (see below)</h3>
<p>These comments document the structure of a stack frame for the program:</p>
<pre><code>; Structure of stack frame for fact function
;    6[R14]   origin of next frame
;    5[R14]   save R4
;    4[R14]   save R3
;    3[R14]   save R2
;    2[R14]   save R1 (parameter n)
;    1[R14]   return address
;    0[R14]   pointer to previous stack frame</code></pre>
<p>}</p>
<h3 id="recursive-factorial">Recursive factorial</h3>
<ul>
<li>In the Sigma16 examples, there is a program called </li>
<li>This program illustrates the full stack frame technique</li>
<li>It uses recursion — a function that calls itself</li>
<li>Note: the best way actually to compute a factorial is with a simple loop,  with recursion</li>
<li>But recursion is an important technique, and it’s better to study it with a simple example (like factorial) rather than a complicated ``real world’’ example</li>
</ul>
<h3 id="about-the-factorial-program">About the factorial program</h3>
<ul>
<li>Comments are used to identify the program, describe the algorithm, and document the data structures.
<ul>
<li>Blank lines and full-line comments organise the program into small sections.</li>
<li>The caller just uses jal to call the function.</li>
<li>The function is responsible for building the stack frame, saving and restoring registers.</li>
<li>The technique of using the stack for functions is general, and can be used for large scale programs.</li>
</ul></li>
</ul>
<h3 id="statement-of-problem-and-register-usage">Statement of problem, and register usage</h3>
<p>;———————————————————————– ; factorial.asm.txt ;———————————————————————–</p>
<p>; This program for the Sigma16 architecture uses a recursive function ; to compute x! (factorial of x), where x is defined as a static ; variable.</p>
<p>; The algorithm uses a recursive definition of factorial: ; if n &lt;=1 ; then factorial n = 1 ; else factorial n = n * factorial (n-1)</p>
<p>; Register usage ; R15 is reserved by architecture for special instructions ; R14 is stack pointer ; R13 is return address ; R2, R3, R4 are temporaries used by factorial function ; R1 is function parameter and result ; R0 is reserved by architecture for constant 0</p>
<h3 id="format-of-main-program-stack-frame">Format of main program stack frame</h3>
<p>;———————————————————————– ; Main program</p>
<p>; The main program computes result := factorial x and terminates.</p>
<p>; Structure of stack frame for main program ; 1[R14] origin of next frame ; 0[R14] pointer to previous stack frame = nil</p>
<h3 id="main-program-initialisation">Main program initialisation</h3>
<p>; Initialise stack lea R14,stack[R0] ; initialise stack pointer store R0,0[R14] ; previous frame pointer := nil</p>
<h3 id="main-program-calls-factorial">Main program calls factorial</h3>
<p>; Call the function to compute factorial x load R1,x[R0] ; function parameter := x store R14,1[R14] ; point to current frame lea R14,1[R14] ; push stack frame jal R13,factorial[R0] ; R1 := factorial x</p>
<h3 id="main-program-finishes">Main program finishes</h3>
<p>; Save result and terminate store R1,result[R0] ; result := factorial x trap R0,R0,R0 ; terminate</p>
<h3 id="description-of-factorial-function">Description of factorial function</h3>
<p>;———————————————————————– factorial ; Function that computes n! ; Input parameter n is passed in R1 ; Result is returned in R1</p>
<h3 id="format-of-stack-frame-for-factorial">Format of stack frame for factorial</h3>
<p>; Structure of stack frame for fact function ; 6[R14] origin of next frame ; 5[R14] save R4 ; 4[R14] save R3 ; 3[R14] save R2 ; 2[R14] save R1 (parameter n) ; 1[R14] return address ; 0[R14] pointer to previous stack frame</p>
<h3 id="factorial-build-stack-frame">Factorial: build stack frame</h3>
<p>; Create stack frame<br />
store R13,1[R14] ; save return address store R1,2[R14] ; save R1 store R2,3[R14] ; save R2 store R3,4[R14] ; save R3 store R4,5[R14] ; save R4 ~~~~ }</p>
<h3 id="factorial-check-for-base-or-recursion-case">Factorial: check for base or recursion case</h3>
<p>; Initialise lea R2,1[R0] ; R2 := 1</p>
<p>; Determine whether we have base case or recursion case cmpgt R10,R1,R2 ; R10 := n&gt;1 jumpt R10,recursion[R0] ; if n&gt;1 then go to recursion case</p>
<h3 id="factorial-base-case">Factorial: base case</h3>
<p>; Base case. n&lt;=1 so the result is 1 lea R1,1[R0] ; factorial n = 1 jump return[R0] ; go to end of function</p>
<h3 id="factorial-recursion-case">Factorial: recursion case</h3>
<p>; Recursion case. n&gt;1 so factorial n = n * factorial (n-1) recursion sub R1,R1,R2 ; function paramemter := n-1</p>
<p>; Call function to compute factorial (n-1) store R14,6[R14] ; point to current frame lea R14,6[R14] ; push stack frame jal R13,factorial[R0] ; R1 := factorial (n-1) load R2,2[R14] ; R2 := saved R1 = n mul R1,R2,R1 ; R1 := n * fact (n-1)</p>
<h3 id="factorial-restore-registers-and-return">Factorial: restore registers and return</h3>
<p>; Restore registers and return; R1 contains result return load R2,3[R14] ; restore R2 load R3,4[R14] ; restore R3 load R4,5[R14] ; restore R4 load R13,1[R14] ; restore return address load R14,0[R14] ; pop stack frame jump 0[R13] ; return</p>
<h3 id="static-data-area">Static data area</h3>
<p>;———————————————————————– ; Static data segment</p>
<p>x data 5 result data 0 stack data 0 ; stack extends from here on…</p>
<h3 id="summary">Summary</h3>
<ul>
<li><p>Variables defined with data statement are static</p>
<ul>
<li>Each static variable must have a unique name</li>
<li>Static variables exist through entire execution of program</li>
</ul></li>
<li><p>Variables defined in a procedure are local</p></li>
<li>Different procedures can use the same name for different variables</li>
<li>Local variables are kept in the stack frame</li>
<li>Call–push stack frame; return–pop stack frame</li>
<li><p>R14 points to current stack frame; local variables are accessed using R14</p></li>
</ul>
<h2 id="linked-lists">Linked lists</h2>
<h3 id="review-of-pointers">Review of pointers</h3>
<ul>
<li>p := &amp;x p is a pointer to x</li>
</ul>
<pre><code>    lea   R5,x[R0]   ; R5 := &amp;x</code></pre>
<ul>
<li>y := *p y is the value that p points to</li>
</ul>
<pre><code>    load   R6,0[R5]   ; R6 := *R5</code></pre>
<h3 id="nodes">Nodes</h3>
<ul>
<li>A linked list consists of a linear chain of </li>
<li><p>A node is a </p></li>
<li> is a word containing useful information, the  of the node. May be an integer, character, or even a pointer to something else.</li>
<li><p> is a word containing a pointer to the next node in the list</p></li>
<li>The last node in the list has a special value  in the  field</li>
<li><p> is represented by 0 (so you can’t have a pointer to memory location 0, but normally that’s where the program will be so you wouldn’t want that anyway)</p></li>
</ul>
<h3 id="accessing-the-fields-of-a-node">Accessing the fields of a node</h3>
<ul>
<li>Suppose p is a pointer to a node</li>
<li>load R1,p[R0] ; R1 := p</li>
<li>load R2,0[R1] ; R2 := (*p).value</li>
<li>load R3,1[R1] ; R3 := (*p).next</li>
</ul>
<h3 id="representing-a-linked-list">Representing a linked list</h3>

<p>p = 5, and the list p = [24, 37, 97, 42]</p>
<p> (ptr5.east) to [out=0, in=0] (addr2.east);  (ptr2.east) to [out=0, in=0] (addr6.east);  (ptr6.east) to [out=0, in=0] (addr3.east);</p>
<h3 id="basic-operations-on-lists">Basic operations on lists</h3>
<ul>
<li><p>Three key operations:</p>
<ul>
<li>Is a list p empty?</li>
<li>What’s the value in a node?</li>
<li>What’s the next node</li>
</ul></li>
<li>The following code assumes that all the pointer variables (p, q) are in memory, so they must be loaded and stored</li>
<li><p>In practice, we often keep the pointers in registers so you don’t need all those loads and stores</p></li>
</ul>
<h3 id="is-list-p-empty">Is list p empty?</h3>
<ul>
<li>Nil is 0, so the list that p points at is empty iff p=0</li>
<li>Generally it is unsafe to perform an action on a list p unless p actually points to a node, so this test is commonly needed</li>
</ul>
<pre><code>    load   R1,p[R0]
    cmpeq  R2,R1,R0
    jumpt  R2,pIsEmpty[R0]
; No, p is not empty
 ...
 ...
pIsEmpty
; Yes, p is empty</code></pre>
<h3 id="get-value-in-node-that-p-points-at-x-p.value">Get value in node that p points at: x := *p.value</h3>
<ul>
<li>x := *p.value</li>
<li>This is safe to do only if p is not empty</li>
<li>The value field of a node is at offset 0 in the node record</li>
</ul>
<pre><code>   load   R1,p[R0]    ; R1 := p
   load   R2,0[R1]    ; R2 := *p.value
   store  R2,x[R0]    ; x := *p.value</code></pre>
<h3 id="get-pointer-to-next-node-in-a-list-q-p.next">Get pointer to next node in a list: q := *p.next</h3>
<ul>
<li>q := *p.next</li>
<li>This is safe to do only if p is not empty</li>
<li>The next field of a node is at offset 1 in the node record</li>
</ul>
<pre><code>   load   R1,p[R0]    ; R1 := p
   load   R2,1[R1]    ; R2 := *p.next
   store  R2,q[R0]    ; q := *p.next</code></pre>
<h3 id="traversing-a-list">Traversing a list</h3>
<p>A while loop is the best looping construct for traversing a list</p>
<p>ListSum (p) { sum := 0; while p /= nil do { x := (<em>p).value; sum := sum + x; p := (</em>p).next; }</p>
<h3 id="search-a-list-p-for-a-value-x">Search a list p for a value x</h3>
<p>Again, the best looping construct is a while loop</p>
<pre><code>ListSearch (p, x)
  { found := False;
    while p /= nil &amp;&amp; not found do
      { found := x = (*p).value;
        p := (*p).next;
      }
    return found;
  }</code></pre>
<p>This is a good example of the proper use of a while loop</p>
<ul>
<li>The condition checks for end of data, and also for early completion</li>
<li>There is no break statement or goto</li>
<li>The loop works even if the original list p is nil</li>
</ul>
<h3 id="cons-constructing-a-list-be-consing-a-value-to-the-front">cons — constructing a list be consing a value to the front</h3>
<ul>
<li>Suppose p = [23, 81, 62]</li>
<li>q := cons (56, p)</li>
<li><p>After computing q, we have</p></li>
<li>q = [56, 23, 81, 62] </li>
<li><p>p = [23, 81, 62] </p></li>
</ul>
<h3 id="implementing-cons">Implementing cons</h3>
<pre><code>cons (x, p)
  { q := newnode ();
    (*q).value := x;
    (*q).next := p;
    return q;
  }</code></pre>
<ul>
<li>No change is made to p, or to the node p points to</li>
<li>A new node is allocated and set to point to p</li>
<li>A pointer to the new node is returned</li>
<li>A function like cons — which produces a new result but does not modify its arguments — is called a </li>
</ul>
<h3 id="getting-a-new-node-from-avail-list">Getting a new node from avail list</h3>
<pre><code>if avail = nil
  then { error &quot;fatal error: out of heap&quot; }
  else { newnode := avail;
         avail := (*avail).next;
         return newnode;
       }</code></pre>
<h3 id="inserting-a-node-with-x-where-p-points">Inserting a node with x where p points</h3>
<pre><code>r := newnode ();
(*r).value := x;
(*r).next := (*p).next;
(*p).next := r;</code></pre>
<ul>
<li>Notice that we can insert x  the node that p points to</li>
<li>But we cannot insert x  that node</li>
<li>It’s common, in list algorithms, to have two pointers moving along through the list, one lagging an element behind the other, to make insertion possible</li>
</ul>
<h3 id="list-header">List header</h3>
<ul>
<li>Suppose we have a list p and a value x</li>
<li>We want to insert x into the list p at an arbitrary point</li>
<li>Another pointer q points to the insertion position</li>
<li><p>A slightly awkward problem: the code to insert x at the front of the list is slightly different from the code to insert x after some element (*q)</p></li>
<li>If somewhere in the middle, we can insert x  the node that q points to</li>
<li>The insertion algorithm will change (*q).next</li>
<li><p>But if we need to insert x at the beginning of the list, we cannot do that; instead the pointer p needs to be changed</p></li>
<li><p>Solution: don’t use an ordinary variable for p; make a  whose next field points to the list</p></li>
</ul>
<h3 id="deleting-a-node">Deleting a node</h3>
<ul>
<li>Need a pointer p into the list; the node  p will be deleted</li>
<li>Just change (*p).next to skip over the next node, and point to the one after</li>
<li>The node being deleted should be returned to the avail list, so it can be reused</li>
</ul>
<h3 id="code-for-deleting-a-node">Code for deleting a node</h3>
<p>If p points to a node, delete the node after that, assuming it exists</p>
<pre><code>delete (p)
  { if p /= nil
    then { q := (*p).next;
           if q /= nil
             then { (p*).next := (*q).next;
                    (*q).next := avail;
                    avail := q;
                  }
         }
  }</code></pre>
<ul>
<li>We can’t delete the node p points to, we can only delete the following node, which q points at</li>
<li>If you know that p cannot be nil, the first test can be omitted</li>
<li>We do need to check whether q = nil; if it is, there’s no node to delete</li>
<li>It doesn’t matter whether (*q).next is nil</li>
<li>It’s important to check whether the operation we’re performing is actually possible!</li>
</ul>
<h3 id="space-leaks">Space leaks</h3>
<ul>
<li>If you return a deleted node to the avail list, it can be reused</li>
<li>If you don’t, this node becomes inaccessible: it doesn’t hold useful data, yet it can’t be allocated</li>
<li></li>
<li>Over time, as a program runs, more and more nodes may become inaccessible: a </li>
</ul>
<h3 id="memory-management">Memory management</h3>
<ul>
<li>It’s a bug if you delete a node that contains useful data</li>
<li>It’s a bug if you don’t delete a node that doesn’t contain useful data</li>
<li>With complicated data structures, this can be difficult</li>
<li><p>A common solution is </p></li>
<li>The program doesn’t explicitly return nodes to the avail list</li>
<li>Periodically, the  traverses all data structures and marks the nodes it finds</li>
<li><p>Then the GC adds all unmarked nodes to the avail list</p></li>
</ul>
<h3 id="sharing-and-side-effects">Sharing and side effects</h3>
<ul>
<li>Suppose p = [6, 2, 19, 37, 41]</li>
<li>Traverse a few elements, and set q to point to the 19 node</li>
<li>Now q = [19, 37, 41] and p is unchanged</li>
<li><p>Then delete the second element of q. The result is</p></li>
<li>q = [19, 41]</li>
<li><p>p = [6, 2, 19, 41] </p></li>
<li>This is called a </li>
<li><p>Sometimes you want this to happen, sometimes not, so it’s important to be careful about it!</p></li>
</ul>
<h2 id="comparing-lists-and-arrays">Comparing lists and arrays}</h2>
<ul>
<li>Lists and arrays are two different kinds of data structure that contain a sequence of data values</li>
<li>How do you decide which to use?</li>
<li>Consider the properties of lists and arrays, and the needs of your program</li>
<li>And there are many other data structures to choose from, which you’ll encounter as you learn computer science</li>
</ul>
<h3 id="accessing-elements">Accessing elements</h3>
<ul>
<li><p>Direct access to an element</p>
<ul>
<li>Array: gives direct access (``random access’’) to element with arbitrary index <span class="math inline"><em>i</em></span></li>
<li>List: gives direct access only to an element you have a pointer to; random access is inefficient</li>
</ul></li>
<li><p>Traversal</p></li>
<li>Array: initialise <span class="math inline"><em>i</em></span> to 0; repeatedly set ; terminate when <span class="math inline"><em>i</em> ≥ <em>n</em></span> (that’s the purpose of a  loop)</li>
<li><p>List: initialize <span class="math inline"><em>p</em></span> to point to the list; repeatedly set ; terminate when </p></li>
</ul>
<h3 id="usage-of-memory">Usage of memory</h3>
<ul>
<li><p>Memory needed per element</p>
<ul>
<li>Array: need just the memory required for the element itself (typically a word)</li>
<li>List: need a node for each element, which also requires space for the next pointer (typically a word)</li>
<li>So typically, an array with <span class="math inline"><em>n</em></span> elements needs <span class="math inline"><em>n</em></span> words, while a list requires <span class="math inline">2 × <em>n</em></span> words</li>
</ul></li>
<li><p>Flexibility</p></li>
<li>An array has fixed size and needs to be allocated fully</li>
<li><p>A list has variable size and needs only enough memory to hold its nodes</p></li>
</ul>
<h3 id="more-general-data-structures">More general data structures</h3>
<ul>
<li>We can put several pointer fields in each node, and produce an enormous variety of data structures, tailored for the needs of an application program</li>
<li><p>Just a few examples</p></li>
<li>Doubly linked list: each node contains two pointers, one to the previous node and one to the next. Allows traversal both directions.</li>
<li><p>Circular list: there is no <code>last'' node where next=nil;     instead, \emph{every} node points to the next node, and the list     loops back to itself.  There is no</code>first’’ or ``last’’ node.</p></li>
</ul>
<h2 id="abstract-data-type">Abstract data type}</h2>
<ul>
<li><p>A stack is an </p>
<ul>
<li>The idea: define the type by the  it supports, not by the code that implements it</li>
<li></li>
</ul></li>
<li>The stack ADT is defined by the  it supports: push, pop</li>
<li><p>There are several completely different ways to implement a stack</p></li>
<li>We have already seen how to implement a stack with an array</li>
<li><p>We can also do it with a linked list</p></li>
</ul>
<h3 id="linked-list-implementation-of-stack">Linked list implementation of stack</h3>
<ul>
<li>A linked list gives easy access to the front of the list, and a stack gives easy access to the top of the stack.</li>
<li>Represent Empty stack as nil</li>
<li>Push x is implemented by stack := cons (x, stack)</li>
<li>Pop x is implemented by stack := (*stack).next</li>
</ul>
<h3 id="array-implementation-of-stack">Array implementation of stack</h3>
<ul>
<li>We can implement a stack using an array</li>
<li>There is a variable  which gives the size of the array — this is the limit on the maximum number of elements that can be pushed</li>
<li>There is a variable  that gives the current number of elements in the stack</li>
</ul>
<h3 id="relationship-between-arrays-and-stacks">Relationship between arrays and stacks</h3>
<ul>
<li><p>Array</p>
<ul>
<li>A container that holds many elements</li>
<li>Each element has an index (which is an integer)</li>
<li>You can access any element x[i]</li>
<li>You can access the elements in any order</li>
</ul></li>
<li><p>Stack</p></li>
<li>A container that holds many elements</li>
<li>You can only access the top element, and you don’t need to know its index</li>
<li><p>You can (and must) access the elements in  order</p></li>
</ul>
<h3 id="pushing-x-onto-a-stack">Pushing x onto a stack</h3>
<pre><code>; push the x onto the stack
; stack[stTop] := R1; stTop := stTop + 1

push   load  R1,x[R0]       ; R1 := x
       load  R2,stTop[R0]   ; R2 := stTop
       store R1,stack[R2]   ; stack[stTop] := x
       lea   R3,1[R0]       ; R3 := constant 1
       add   R2,R2,R3       ; R2 := stTop + 1
       store R2,stTop[R0]   ; stTop := stTop + 1</code></pre>
<h3 id="pop-a-stack-returning-x">Pop a stack, returning x</h3>
<pre><code>; pop the stack, store top element into x
; stTop := stTop - 1; x := stack[stTop]

pop    load  R2,stTop[R0]   ; R2 := stTop
       lea   R3,1[R0]       ; R3 := constant 1
       sub   R2,R1,R3       ; R2 := stTop - 1
       load  R1,stack[R2]   ; R1 := stack[stTop-1]
       store R1,x[R0]       ; x := stack[stTop-1]
       store R2,stTop[R0]   ; stTop := stTop - 1</code></pre>
<h3 id="error-checking">Error checking</h3>
<h3 id="issues-with-simplest-implementation">Issues with simplest implementation}</h3>
<ul>
<li><p>It doesn’t check for errors!</p>
<ul>
<li>If push is called when stack is full, data will be written outside the array</li>
<li>If pop is called when stack is empty, a garbage result will be returned</li>
</ul></li>
<li><p>Either of these errors may cause the program to get wrong answers or to crash</p></li>
</ul>
<h3 id="robust-software">Robust software</h3>
<ul>
<li>Fragile software will respond to a minor problem by going haywire: might crash, or produce wrong answers</li>
<li> checks for all errors and does something appropriate; a minor problem doesn’t turn into a major one</li>
</ul>
<h3 id="error-checking-and-error-handling">Error checking and error handling</h3>
<ul>
<li><p>Software should not assume everything is ok — it should check for errors</p>
<ul>
<li>push (x) when the stack is full</li>
<li>x := pop () when the stack is empty</li>
</ul></li>
<li>If an error is detected, the error must be </li>
<li><p>There are many approaches</p></li>
<li>Produce a message and terminate the program</li>
<li>Return an error code to the calling program and let it decide what to do</li>
<li><p>Throw an exception, which will interrupt the calling program, and invoke its error handler</p></li>
</ul>
<p>For simplicity, we will terminate the program if an error occurs.</p>
<h3 id="error-checking-push">Error checking: push</h3>
<p>If the stack is full, there is no space to store the new element, so push fails</p>
<pre><code>; push (v)
; if stTop &gt;= stLim
;     then
;        terminate because the stack is full: cannot push
;     else
;        stack[stTop] := v
;        stTop := stTop + 1
;        return ()</code></pre>
<h3 id="error-checking-pop">Error checking: pop</h3>
<p>If the stack is empty, there is no element to return, so pop fails</p>
<pre><code>; v = pop ()
;   if stTop == 0
;     then
;       terminate because the stack is empty: cannot pop
;     else
;       stTop := stTop - 1
;       v := stack[stTop]
;       return (v)</code></pre>
<h2 id="programming-techniques">Programming techniques</h2>
<ul>
<li>Compound Boolean expressions: ``short circuit’’ evaluation</li>
<li>The condition code and ``cmp jumpgt’’ style comparisons</li>
<li>loops: for loop, while loop, repeat until loop</li>
<li>Input/Output: write characters, not numbers</li>
</ul>
<h3 id="compound-boolean-expressions">Compound Boolean expressions</h3>
<p>Notation: various programming languages use several slightly different notations are used for Boolean operators</p>
<pre><code>i&lt;n and x[i]&gt;0      i&lt;n &amp;&amp; x[i]&gt;0     i&lt;n &amp; x[i]&gt;0
i&lt;n or  j&lt;n         i&lt;n || j&lt;n        i&lt;n | x[i]&gt;0</code></pre>
<h3 id="short-circuit-expressions">``Short circuit’’ expressions</h3>
<ul>
<li>Suppose  is an array with  elements</li>
<li>Consider </li>
<li>If the first expression  is False, then the whole expression is False</li>
<li>In that case, there is no need to evaluate the second expression </li>
<li>We can ``short circuit’’ the evaluation</li>
<li>Big advantage: if  is False, then  does not exist and evaluating it could cause an error</li>
<li>So it is  not to evaluate the second expression if the first one is false</li>
</ul>
<h3 id="implementing-a-compound-boolean-expression">Implementing a compound boolean expression</h3>
<pre><code>while i&lt;n &amp;&amp; x[i]&gt;0 do S

; if not (i&lt;n &amp;&amp; x[i]&gt;0) then goto loopDone
    load   R1,i[R0]          ; R1 := i
    load   R2,n[R0]          ; R2 := n
    cmplt  R3,R1,R2          ; R3 := i&lt;n
    jumpf  R3,loopDone[R0]   ; if not (i&lt;n) then goto loopDone
    load   R3,x[R1]          ; R3 := x[i]   safe because i&lt;n
    cmpgt  R4,R3,R0          ; R4 := x[i]&gt;0
    jumpf  R4,loopDone[R0]   ; if not (x[i]&gt;0) then goto loopDone</code></pre>
<p>This is better than evaluating both parts of the expression and calculating logical and</p>
<h3 id="condition-code">Condition code</h3>
<ul>
<li>We have seen one style for comparison and conditional jump</li>
</ul>
<pre><code>   cmplt  R3,R8,R4
   jumpt  R3,someplace[R0]</code></pre>
<ul>
<li>There is also another way you can do it</li>
</ul>
<pre><code>   cmp    R8,R4           ; no destination register
   jumplt someplace[R0]   ; jump if less than</code></pre>
<ul>
<li>The cmp instruction sets a result (less than, equal, etc) in R15 which is called the </li>
<li>There are conditional jumps for all the results: jumpeq, jumplt, jumple (jump if less than or equal), etc</li>
<li>An advantage is that you don’t need to use a register for the boolean result</li>
</ul>
<h4 id="repeat-until-loop">Repeat-until loop</h4>
<p>This is similar to a while loop, except you decide whether to continue at the end of the loop</p>
<pre><code>repeat
  {S1; S2; S3}
until i&gt;n;</code></pre>
<p>This is equivalent to</p>
<pre><code>S1; S2; S3;
while not (i&gt;n) do
  {S1; S2; S3}</code></pre>
<p>The while loop is used far more often, but if you need to go through the loop at least one time, the repeat-until is useful</p>
<h3 id="inputoutput">Input/Output</h3>
<ul>
<li><p>A character is represented by a code using ASCII or Unicode</p>
<ul>
<li>http://www.asciitable.com/</li>
<li>https://unicode-table.com/en/</li>
</ul></li>
<li><p>digit characters 0..9 have codes (in decimal) 48..57</p></li>
<li><p>Example: ‘3’ is represented by the number 51, not by the number 3</p></li>
<li>lower case a..z have codes (in decimal) 97..122</li>
<li>upper case A..Z have codes (in decimal) 65..90</li>
<li><p>To print a number, we need to convert it to a string of characters</p></li>
</ul>
<h3 id="converting-a-number-to-a-string">Converting a number to a string</h3>
<ul>
<li>We actually need to do arithmetic to convert a binary number to decimal, and to a string of decimal digits</li>
<li>The lab exercise gives the algorithm to do this</li>
<li>It needs to divide the number by 10 to get the quotient and the remainder</li>
<li><p>div R1,R2,R3</p></li>
<li>Divides R2/R3</li>
<li>The quotient goes into R1 (the destination register)</li>
<li><p>The remainder goes into R15 (always R15, you cannot change this)</p></li>
<li><p>The algorithm repeatedly divides the number by 10; the remainder is used to get a digit character</p></li>
</ul>
<h3 id="arrays-and-pointers">Arrays and pointers</h3>
<p>We have seen how to access an array element using an index register</p>
<pre><code>; R5 := x[i]
    load   R2,i[R0]    ; R2 := i
    load   R5,x[R2]    ; R5 := x[i]</code></pre>
<h3 id="sum-of-an-array-x-using-index-high-level">Sum of an array x using index: high level</h3>
<p>Suppose x is an array of numbers, and sizeX is the number of elements. We want to add up all the elements of x.</p>

<p>A for loop is convenient (the whole purpose of the for loop is for writing this kind of loop):</p>
<pre><code>   sum := 0;
   for i := 0 to sizeX do
     { sum := sum + x[i]; }</code></pre>
<p>You can also use a while loop:</p>
<pre><code>   sum := 0;
   i := 0;
   while i &lt; sizeX do
     { sum := sum + x[i];
       i := i + 1; }</code></pre>
<h3 id="arrays-and-pointers-1">Arrays and pointers</h3>
<ul>
<li>There is also another way to access an array element, </li>
<li>To do this, we will perform </li>
</ul>
<h3 id="accessing-an-array-element-using-a-pointer">Accessing an array element using a pointer</h3>
<ul>
<li>Create a pointer p to the beginning of the array x, so p is pointing to x[0]\ </li>
<li>To access the current element, follow p:\ </li>
<li>To move on to the next element of the array, increment p\ </li>
<li>Notice that we are doing </li>
</ul>
<pre><code>x   data  34   ; first element of x
    data  82
    data  91
    data 29    ; last element of x
xEnd           ; address of first word after array x</code></pre>
<h3 id="sum-of-an-array-x-using-pointers-high-level">Sum of an array x using pointers: high level</h3>
<pre><code>   sum := 0;
   p := &amp;x;
   q := &amp;xEnd;
   while p&lt;q do
     { sum := sum + *p;
       p := p + 1; }</code></pre>
<ul>
<li>In assembly language, we can use lea to increment the pointer.</li>
<li>Suppose p is in R1, then\ </li>
<li>We are incrementing p by the size of an array element</li>
</ul>
<h3 id="sum-of-an-array-x-using-pointers-assembly-language">Sum of an array x using pointers: assembly language</h3>
<pre><code>;   R1 = p = pointer to current element of array x
;   R2 = q = pointer to end of array x
;   R3 = sum of elements of array x

    lea   R1,x[R0]      ; p := &amp;x
    lea   R2,xEnd[R0]   ; q := %xEnd
    add   R3,R0,R0      ; sum := 0
sumLoop
    cmplt R4,R1,R2      ; R4 := p&lt;q
    jumpf sumLoopDone   ; if not p&lt;q then goto sumLoopDone
    load  R4,0[R1]      ; R4 := *p  (this is current element of x)
    add   R3,R3,R4      ; sum := sum + *p
    lea   R1,1[R1]      ; p := p+1  (point to next element of x)
    jump  sumLoop[R0]   ; goto sumLoop
sumLoopEnd

x   data  23   ; first element of x
    data  42   ; next element of x
    data 19    ; last element of x
xEnd</code></pre>
<p>}</p>
<h3 id="comparing-the-two-approaches">Comparing the two approaches</h3>
<ul>
<li><p>Accessing elements of an array using index</p>
<ul>
<li>Get x[i] with load R5,x[R1] where R1=i</li>
<li>Move to next element of array by i := i+1</li>
<li>Determine end of loop with </li>
<li>Know in advance how many iterations: xSize</li>
<li>A for loop is convenient</li>
</ul></li>
<li><p>Accessing elements of an array using pointer</p></li>
<li>Initialize p with lea R1,x[R0]</li>
<li>Get x[i] with load R5,0[R1] where R1=p</li>
<li>Move to next element of array by </li>
<li>Determine end of loop with  (q points to end of array)</li>
<li>Don’t need to know in advance how many iterations</li>
<li><p>Need to use a while loop</p></li>
<li>Both techniques are important</li>
<li><p></p></li>
</ul>
<h3 id="records-2">Records</h3>
<pre><code>program Records
 { x, y :
     record
       { fieldA : int;
         fieldB : int;
         fieldC : int; }
   x.fieldA := x.fieldB + x.fieldC;
   y.fieldA := y.fieldB + y.fieldC;
 }</code></pre>
<p>Suppose we have an array of these records, and want to</p>
<ul>
<li>set fieldA := fieldB + fieldC in every record in the array</li>
<li>Calculate the sum of the fieldA in every record</li>
</ul>
<h3 id="traverse-array-of-records-with-indexing">Traverse array of records with indexing</h3>
<pre><code>sum := 0;
for i := 0 to nrecords do
  { RecordArray[i].fieldA :=
       RecordArray[i].fieldB + RecordArray[i].fieldC;
    sum := RecordArray[i].fieldA; }</code></pre>
<ul>
<li>This is ok</li>
<li>But it is a little awkward</li>
</ul>
<h3 id="traverse-array-of-records-with-pointers-high-level">Traverse array of records with pointers: high level</h3>
<pre><code>sum := 0;
p := &amp;RecordArray;
q := &amp;RecordArrayEnd;
while p &lt; q do
  { *p.fieldA := *p.fieldB + *p.fieldC;
    sum := sum + *p.fieldA;
    p := p + RecordSize; }</code></pre>
<p>In professional programming, this is often preferred because accessing the elements of the records is easier (it’s easier to access an ``element of an element’’ via pointer)</p>
<h3 id="traverse-array-of-records-with-pointers-low-level">Traverse array of records with pointers: low level</h3>
<pre><code>;    sum := 0;
;    p := &amp;RecordArray;
;    q := &amp;RecordArrayEnd;
; RecordLoop
;    if (p&lt;q) = False then goto recordLoopDone;
;    *p.fieldA := *p.fieldB + *p.fieldC;
;    sum := sum + *p.fieldA;
;    p := p + RecordSize;
;    goto recordLoop;
; RecordLoopDone</code></pre>
<h3 id="traverse-array-of-records-with-pointers-assembly-language">Traverse array of records with pointers: assembly language</h3>
<pre><code>;   R1 = sum
;   R2 = p (pointer to current element)
;   R3 = q (pointer to end of array)
;   R4 = RecordSize

    lea    R1,0[R0]                 ; sum := 0
    lea    R2,RecordArray[R0]       ; p := &amp;RecordArray;
    lea    R3,RecordArrayEnd[R0]    ; q := &amp;RecordArray;
    load   R4,RecordSize[R0]        ; R4 := RecordSize
RecordLoop
    cmplt  R5,R2,R3                 ; R5 := p&lt;q
    jumpf  R5,RecordLoopDone[R0]    ; if (p&lt;q) = False then goto RecordLoopDone
    load   R5,1[R2]                 ; R5 := *p.fieldB
    load   R6,2[R2]                 ; R6 := *p.fieldC
    add    R7,R5,R6                 ; R7 := *p.fieldB + *p.fieldC
    store  R7,0[R2]                 ; *p.fieldA := *p.fieldB + *p.fieldC
    add    R1,R1,R7                 ; sum := sum + *p.fieldA
    add    R2,R2,R4                 ; p := p + RecordSize
    jump   RecordLoop[R0]           ; goto RecordLoop
RecordLoopDone</code></pre>
<p>}</p>
<h3 id="stack-overflow">Stack overflow</h3>
<ul>
<li>The mechanism for calling a procedure and returning is fairly complicated</li>
<li>Rather than introducing all the details at once, we have looked at several versions, introducing the concepts one at a time</li>
<li><p>Now we introduce the next level:</p></li>
<li>Simplify calling a procedure</li>
<li><p>The procedure checks for stack overflow</p></li>
<li><p>We need two more registers dedicated to procedures</p></li>
<li>R12 holds stack top (the highest address in current stack frame)</li>
<li><p>R11 holds stack limit (the stack is not allowed to grow beyond this address)</p></li>
</ul>
<h3 id="register-usage">Register usage</h3>
<p>See the PrintIntegers program for examples</p>
<pre><code>; Global register usage
;   R0 = constant 0
;   R1, R2, R3 are used for parameters and return values
;   R4 - R10 are available for local use in a procedure
;   R11 = stack limit
;   R12 = stack top
;   R13 = return address
;   R14 = stack pointer
;   R15 is transient condition code</code></pre>
<h3 id="initialize-the-stack">Initialize the stack</h3>
<pre><code>; Structure of stack frame for main program, frame size=1
;    0[R14]  dynamic link is nil

; Initialize the stack
    lea    R14,CallStack[R0]  ; initialise stack pointer
    store  R0,0[R14]          ; main program dynamic link = nil
    lea    R12,1[R14]         ; initialise stack top
    load   R1,StackSize[R0]   ; R1 := stack size
    add    R11,R14,R1         ; StackLimit := &amp;CallStack + StackSize</code></pre>
<h3 id="calling-a-procedure">Calling a procedure</h3>
<ul>
<li><p>To call a procedure PROC:</p>
<ul>
<li>Place any parameters you’re passing to PROC in R1, R2, R3</li>
<li>jal R13,PROC[R0]</li>
</ul></li>
</ul>
<h3 id="structure-of-procedure-stack-frame">Structure of Procedure stack frame</h3>
<p>(This is procedure PrintInt, see lab exercise)</p>
<pre><code>; Arguments
;   R1 = x         = two&#39;s complement number to print
;   R2 = FieldSize = number of characters for print field
;        require FieldSize &lt; FieldSizeLimit

; Structure of stack frame, frame size = 6
;    5[R14]  save R4
;    4[R14]  save R3
;    3[R14]  save R2 = argument fieldsize
;    2[R14]  save R1 = argument x
;    1[R14]  return address
;    0[R14]  dynamic link points to previous stack frame</code></pre>
<h3 id="called-procedure-creates-its-stack-frame">Called procedure creates its stack frame</h3>
<pre><code>PrintInt
; Create stack frame
    store  R14,0[R12]          ; save dynamic link
    add    R14,R12,R0          ; stack pointer := stack top
    lea    R12,6[R14]          ; stack top := stack ptr + frame size
    cmp    R12,R11             ; stack top ~ stack limit
    jumpgt StackOverflow[R0]   ; if top&gt;limit then goto stack overflow
    store  R13,1[R14]          ; save return address
    store  R1,2[R14]           ; save R1
    store  R2,3[R14]           ; save R2
    store  R3,4[R14]           ; save R3
    store  R4,5[R14]           ; save R4</code></pre>
<h3 id="procedure-finishes-and-returns">Procedure finishes and returns</h3>
<pre><code>; return
    load   R1,2[R14]        ; restore R1
    load   R2,3[R14]        ; restore R2
    load   R3,4[R14]        ; restore R3
    load   R13,1[R14]       ; restore return address
    load   R14,0[R14]       ; pop stack frame
    jump   0[R13]           ; return</code></pre>
<h3 id="stack-overflow-1">Stack overflow</h3>
<p>If the stack is full and a procedure is called, this is a fatal error</p>
<pre><code>StackOverflow
    lea    R1,2[R0]
    lea    R2,StackOverflowMessage[R0]
    lea    R3,15[R0]   ; string length
    trap   R1,R2,R3    ; print &quot;Stack overflow\n&quot;
    trap   R0,R0,R0    ; halt

StackOverflowMessage
    data    83   ; &#39;S&#39;
    data   116   ; &#39;t&#39;
    data    97   ; &#39;a&#39;
    data    99   ; &#39;c&#39;
    data   107   ; &#39;k&#39;
...</code></pre>
<h3 id="blocks">Blocks</h3>
<ul>
<li>You’ll need to learn many programming languages, eventually</li>
<li>There are concepts that appear in most languages</li>
<li>It’s useful to focus on the general concept</li>
<li>One important concept is a block</li>
<li>A  or  is a single statement that contains several statements</li>
<li>The purpose is to let you have a group of statements in a loop, or controlled by a conditional</li>
<li><p>The  is the detailed punctuation used to indicate a block, and this varies in different languages</p></li>
<li>There are lots of small syntax differences between languages</li>
<li>Some languages use := to mean assign, = to mean equals</li>
<li><p>Some languages use = to mean assign, == to mean equals</p></li>
</ul>
<h4 id="syntax-for-blocks">Syntax for blocks</h4>
<h3 id="python-syntax-style-for-blocks-layout">Python syntax style for blocks: layout</h3>
<p>The layout (the indentation) determines what is inside the if statement</p>
<pre><code>a = 1
if  x &lt; y :
  b = 2
  c = 3
d = 4</code></pre>
<p>If you change the indentation, you change the meaning of the program</p>

<p>In Python, you write  to mean , and  to mean </p>
<h3 id="algolpascal-style-for-blocks-beginend">Algol/Pascal style for blocks: begin—end</h3>
<pre><code>a := 1;
if x&lt;y
  then begin b := 2;
             c := 3
       end
  else begin d := 4;
             e := 5
       end;
f := 6;</code></pre>
<p>You write  to mean , and  to mean </p>

<p>Statements must be separated by semicolon ;</p>
<h3 id="c-style-for-blocks-braces">C style for blocks: braces</h3>
<pre><code>a = 1;
if (x &lt; y) b = 2;
else
   { d = 4;
     e = 5; }
f = 6;</code></pre>
<p>In C you don’t write  at all, but this means the condition  must be enclosed in parentheses so the compiler can tell where the condition ends and the then-statement begins</p>
<h3 id="block-structured-style-for-blocks-matching-keywords">Block structured style for blocks: matching keywords</h3>
<pre><code>a := 1;
if x&lt;y
  then b := 2;
       while i&lt;n do
           sum := sum+x[i];
          i := i+1
       endwhile
  else d := 4
       e := 5
endif;
f := 6;</code></pre>
<p>This style introduces a lot of keywords (endif, endwhile, endfor, endrepeat) but you don’t need braces around a block. It makes code more readable and enables the compiler to produce better error messages</p>
<h3 id="enter-at-beginning-exit-at-end">Enter at beginning, exit at end</h3>
<ul>
<li><p>A common programming style is to require</p>
<ul>
<li>Each block enters only at the beginning of the block</li>
<li>Each block exits only at the end of the block</li>
</ul></li>
<li>This style is helpful in some programming languages, but in some languages it sometimes makes code less readable</li>
<li>In assembly language, and for compilation patterns, it is necessary to follow this style</li>
<li><p>In high level languages this style is sometimes helpful, but not always</p></li>
</ul>
<h3 id="single-entranceexit-for-compilation-patterns">Single entrance/exit for compilation patterns</h3>
<ul>
<li>It is straightforward to translate high level control constructs using the compilation patterns</li>
<li>These  that the blocks of code always start at the beginning and finish at the end</li>
<li><p>It’s bad to jump into the middle of a block, or exit out of the middle because</p></li>
<li>The compilation patterns won’t work correctly</li>
<li>You’ll have to duplicate a lot of code</li>
<li>Example: returning from a procedure requires restoring the registers, resetting the stack pointer, loading the return address</li>
<li><p>That code should not be duplicated in several places in a procedure</p></li>
</ul>
<h3 id="systematic-approach-to-programming">Systematic approach to programming?</h3>
<ul>
<li>Start by understanding what your program should do</li>
<li>Express the algorithm using high level language notation (and it’s ok to mix in some English too)</li>
<li><p>Translate the high level to the low level</p></li>
<li>Assignment statements: x := expression</li>
<li>I/O statements: Write string</li>
<li>goto L</li>
<li><p>if boolean then goto L</p></li>
<li>Translate the low level to assembly language</li>
<li>Retain the high and low level code as comments</li>
<li><p>Do hand execution at every level</p></li>
</ul>
<h3 id="why-use-this-systematic-approach-to-programming">Why use this systematic approach to programming?</h3>
<ul>
<li>It enables you to write correct code at the outset, and minimise debugging</li>
<li>If there is a bug, it helps you to catch it early (e.g. in translation to goto form)</li>
<li><p>If there’s a bug in an instruction, the comments enable you to find it quickly</p></li>
<li>A common error is to use a wrong register number: add R9,R3,R4</li>
<li>Poor comments don’t help: </li>
<li>Good comments help a lot: </li>
<li><p>Look at the register usage comments (oops, x is in R8, not R9, now I know how to fix it and I don’t have to read the entire program)</p></li>
<li><p>Professional software needs to be maintained; the comments make the software easier to read and more valuable</p></li>
</ul>
<h3 id="nested-conditionals">Nested conditionals</h3>
<h4 id="nested-if-then-else">Nested if-then-else</h4>
<p>Conditional statements can be nested deeply</p>
<pre><code>if b1
  then S1
       if b2
         then S3
         else S4
       S5
  else S6
       if b3
         then S7
       S8</code></pre>
<h3 id="special-case-of-nested-if-then-else">Special case of nested if-then-else</h3>
<p>Often the nesting isn’t random, but has this specific structure:</p>
<pre><code>if b1
  then S1
  else if b2
         then S2
         else if b3
                then S3
                else if b4
                       then S4
                       else if b5
                              then S5
                              else S6</code></pre>
<p>(Some languages require punctuation to avoid ambiguity)</p>
<h3 id="another-way-to-write-it">Another way to write it</h3>
<p>To avoid running off the right side of the window, it’s usually indented like this:</p>
<pre><code>if b1
  then S1
else if b2
  then S2
else if b3
  then S3
else if b4
  then S4
else if b5
  then S5
else S6</code></pre>
<h3 id="some-programming-languages-have-elsif-or-elif">Some programming languages have elsif or elif</h3>
<pre><code>if b1 then S1
  elif b2 then S2
  elif b3 then S3
  elif b4 then S4
  eleif b5 then S5
  else S6</code></pre>
<ul>
<li>It avoids ambiguity</li>
<li>It signals to the compiler and to a human programmer that this specific construct is being used</li>
<li>It allows good indentation layout without violating the basic principle of indentation</li>
<li>Some languages have this, some don’t</li>
</ul>
<h3 id="case-and-jump-tables">Case and jump tables</h3>
<h3 id="a-common-application-numeric-code">A common application: numeric code</h3>
<p>Nested if-then-else but the boolean conditions are not arbitrary: they are checking the value of a code:</p>
<pre><code>if code = 0
  then S1
else if code = 1
  then S2
else if code = 2
  then S3
else if code = 3
  then S4
else if code = 4
  then S5</code></pre>
<h3 id="the-case-statement">The case statement</h3>
<pre><code>case n of
   0 -&gt; Stmt
   1 -&gt; Stmt
   2 -&gt; Stmt
   3 -&gt; Stmt
   4 -&gt; Stmt
   5 -&gt; Stmt
   else -&gt; Stmt // handle error</code></pre>
<p>This means: execute the statement corresponding to the value of n</p>

<p>Many programming languages have this; the syntax varies a lot but that isn’t what’s important</p>
<h3 id="example-numeric-code-specifies-a-command">Example: numeric code specifies a command</h3>
<pre><code>; The input data is an array of records, each specifying an operation
;    Command : record
;       code : Int     ; specify which operation to perform
;       i    : Int     ; index into array of lists
;       x    : Int     ; value of list element

; The meaning of a command depends on the code:
;    0  terminate the program
;    1  insert x into set[i]
;    2  delete x from set[i]
;    3  return 1 if set[i] contains x, otherwise 0
;    4  print the elements of set[i]</code></pre>
<p>}</p>
<h3 id="selecting-the-command-with-a-case-statement">Selecting the command with a case statement</h3>
<p>; Initialize ; BuildHeap ()</p>
<p>; Execute the commands in the input data ; finished := 0 ; while InputPtr &lt;= InputEnd &amp;&amp; not finished ; CurrentCode := (<em>InputPtr).code ; p := set[*InputPtr] ; linked list ; x := (</em>InputPtr).x ; value to insert, delete, search</p>
<p>; case CurrentCode of ; 0 : <CmdTerminate> ; 1 : <CmdInsert> ; 2 : <CmdDelete> ; 3 : <CmdSearch> ; 4 : <CmdPrint> ; else : &lt;&gt; ; InputPtr := InputPtr + sizeof(Command) ; Terminate the program ; halt</p>
<h3 id="finding-a-numeric-code">Finding a numeric code</h3>
<ul>
<li><p>It’s tedious and inefficient to go through the possible values of a numeric code in sequence</p>
<ul>
<li>If you’re looking up Dr Zhivago in the phone book, do you look at Arnold Aardvark, and Anne Anderson, on on and on?</li>
<li>You go straight to the end of the book</li>
</ul></li>
<li><p>We want to find the statement corresponding to a numeric code directly, without checking all the other values</p></li>
</ul>
<h3 id="a-problem-with-efficiency">A problem with efficiency</h3>
<ul>
<li><p>The problem</p></li>
<li>There are many applications of case statements</li>
<li>They are executed frequently</li>
<li>The number of cases can be large (not just 4 or 5; can be hundreds)</li>
<li><p>The implementation of the if-then-else requires a separate compare and jump for each condition</p></li>
<li><p>The solution</p></li>
<li><p>A technique called </p></li>
</ul>
<h3 id="jump-tables-the-basic-idea">Jump tables: the basic idea</h3>
<ul>
<li>For each target statement (S1, S2, S3, etc) in the conditional, introduce a jump to it: jump S1[R0], jump S2[R0], etc</li>
<li>Make an  ``jt’’ of these jump instructions</li>
</ul>
<pre><code>   jt[0] = jump S0[R0]
   jt[1] = jump S1[R0]
   jt[2] = jump S2[R0]
   jt[3] = jump S3[R0]
   jt[4] = jump S4[R0]</code></pre>
<ul>
<li>Given the , Jump to jt[code]</li>
<li>Each element of the array is an instruction that requires two words</li>
<li>So jump to &amp;jt + 2 <span class="math inline">×</span> code</li>
</ul>
<h3 id="jump-table">Jump table</h3>
<p>; Jump to operation specified by code add R4,R4,R4 ; code := 2*code lea R5,CmdJumpTable[R0] ; R5 := pointer to jump table add R4,R5,R4 ; address of jump to operation jump 0[R4] ; jump to jump to operation CmdJumpTable jump CmdTerminate[R0] ; code 0: terminate the program jump CmdInsert[R0] ; code 1: insert jump CmdDelete[R0] ; code 2: delete jump CmdSearch[R0] ; code 3: search jump CmdPrint[R0] ; code 4: print</p>
<p>CmdDone load R5,InputPtr[R0] lea R6,3[R0] add R5,R5,R6 store R5,InputPtr[R0] jump CommandLoop[R0]</p>
<h3 id="we-have-to-be-careful">We have to be careful!</h3>
<ul>
<li>What if code is negative, or larger than the number of cases?</li>
<li>The jump to the jump table could go anywhere!</li>
<li>It might not even go to an instruction</li>
<li>But whatever is in memory at the place it goes to, will be interpreted as an instruction that will be executed</li>
<li>The program will go haywire</li>
<li>Debugging it will be hard: the only way to catch the error is to read the code and/or to single step</li>
<li>Solution: before jumping into the jump table, check to see if code is invalid (too big or too small)</li>
</ul>
<h3 id="checking-whether-the-code-is-invalid">Checking whether the code is invalid</h3>
<pre><code>CommandLoop
    load   R5,InputPtr[R0]     ; R1 := InputPtr
    load   R4,0[R5]            ; R4 := *InputPtr.code
; Check for invalid code    
    cmp    R4,R0               ; compare (*InputPtr).code, 0
    jumplt CmdDone[R0]         ; skip invalid code (negative)
    lea    R6,4[R0]            ; maximum valid code
    cmp    R4,R6               ; compare code with max valid code
    jumpgt CmdDone[R0]         ; skip invalid code (too large)

...
    
CmdDone
    load   R5,InputPtr[R0]
    lea    R6,3[R0]
    add    R5,R5,R6
    store  R5,InputPtr[R0]
    jump   CommandLoop[R0]

## What&#39;s the significance of root?


 *  Many \alert{processes} are running in the computer
 *  Each has its own set of privileges
 *  There is one special user ``root&#39;&#39; which has \emph{all}
  privileges: \alert{root can do anything at all}
 *  The effect of this change to the source code (a change of
  \emph{one character!} is
  
   *  If a user program calls this obscure function with just the
    right set of obscure options, \alert{it suddenly gains full
      control over the machine}
  
 *  Don&#39;t worry --- \alert{this faulty code never made it into the
    master copy of Linux}


## Example: Ordered lists program

Concepts used in the program:

Array of records, Representing a command as a records, Traversing an
array of records, Case statement and jump table

Traversing a list to print its elements, Insertion in list keeping the
elements in ascending order, Deletion from a list, Searching a list

### Ordered lists

There is an array of lists, initially empty.  There are nlists of them.
</code></pre>
<p>list[0] = [ ] list[1] = [ ] … list[nlists-1] = [ ] ~~~~</p>
<p>At all times as the program runs, the lists are ordered: their elements are increasing</p>
<pre><code>list[0] = [4, 9, 23, 51 ]
list[1] = [7, 102, 238 ]
...
list[nlists-1] = [2, 87, 89, 93, 103, 195 ]</code></pre>
<h3 id="commands">Commands</h3>
<p>The program executes commands:</p>
<ul>
<li>Terminate — the program finishes</li>
<li>Insert into list i the value x — modify list[i] so it contains x, while maintaining the ascending order</li>
<li>Delete from list i the value x — modify list[i] so x is removed, but don’t do anything if x isn’t in the list</li>
<li>Search list i for x — print Yes if x is in the list, No otherwise</li>
<li>Print i — the numbers in list[i] are printed</li>
</ul>
<h4 id="example-1">Example</h4>
<ul>
<li>Insert into list[3] the value 23 </li>
<li>Insert into list[3]the value 6 </li>
<li>Insert into list[3] the value 67 </li>
<li>Insert into list[3] the value 19 </li>
<li>Print list[3] </li>
</ul>
<h3 id="why-are-ordered-lists-useful">Why are ordered lists useful?</h3>
<ul>
<li>This is one way to arrange a database: think of the elements as persons’ names, or matriculation numbers</li>
<li>Sometimes you want to process all the data in a container in a specified order</li>
<li>If the data is ordered, it’s faster to find a particular item (on average you only have to check half of the items)</li>
<li>An ordered list can be used to represent a set</li>
</ul>
<h3 id="where-do-the-commands-come-from">Where do the commands come from?</h3>
<ul>
<li>In a real application, we would read the commands from input</li>
<li>But in this program, each command is represented as a record</li>
<li>The entire input is a static array of records defined with  statements</li>
<li><p>This is easier because</p></li>
<li>If you read from an input device, it’s necessary to convert the input character string to numbers</li>
<li>In testing a program, it’s convenient to have input data that is </li>
<li><p>Don’t want to have to type in the same input every time you run the program!</p></li>
</ul>
<h3 id="representing-a-command">Representing a command</h3>
<ul>
<li><p>Each command is a record with three fields</p>
<ul>
<li>A code indicating which kind of command</li>
<li>A number i indicating which list we’re operating on</li>
<li>A value x which might be inserted etc</li>
</ul></li>
<li>Each record must have these three fields</li>
<li>Some commands don’t use them all (e.g. Print just needs i, not</li>
</ul>
<ol start="24" type="a">
<li></li>
</ol>
<ul>
<li>The main program uses a  statement to handle each command, and implements this with a </li>
</ul>
<h3 id="reading-a-program-before-writing">Reading a program before writing</h3>
<ul>
<li><p>You should  the program before modifying it</p>
<ul>
<li>Reading a program is an important skill you will need throughout your career</li>
<li>The program is filled with examples so it is excellent revision material</li>
<li><p>You need to understand a program before you’ll be able to make changes to it</p></li>
<li><p>One of the aims of the exercise is to get experience with reading a longer program—don’t skip this!</p></li>
</ul></li>
</ul>
<h3 id="some-tips-on-testing-and-debugging">Some tips on testing and debugging</h3>
<ul>
<li>Debugging has two phases:
<ul>
<li>The most important point: don’t just make random changes to the code and hope for the best—instead, find out what the error is and fix it cleanly</li>
</ul></li>
</ul>
<h3 id="reading-and-testing-a-program">Reading and testing a program</h3>
<ul>
<li>A good way to understand a section of assembly language instructions is to step through it, one instruction at a time
<ul>
<li>Coverage \begin{enumerate}</li>
<li>You don’t need to step through a set of instructions a huge number of times</li>
<li>If there’s a loop, step through two or three iterations</li>
<li>If possible, arrange test data so the loop will terminate after just a few iterations</li>
<li>But try to step through as much of the program as possible</li>
<li>This is called : try to cover all of the program with your testing \end{enumerate}</li>
</ul></li>
</ul>
<h3 id="breakpoints">Breakpoints</h3>
<ul>
<li>It’s a good idea to step through a program one instruction at a time, so you understand clearly what each instruction is doing
<ul>
<li><p>However, in a longer program this isn’t always feasible</p></li>
<li><p>The OrderedLists program has to build the heap when it starts; this may take several thousand instructions before it even really gets going!</p></li>
<li><p>Solution: </p></li>
<li>Find the address of an instruction where you want to start single stepping</li>
<li>Enter this address as a breakpoint</li>
<li>Click Run to execute the program at full speed; when it reaches the breakpoint it will stop</li>
<li><p>Then you can single step to examine what the instructions are doing</p></li>
</ul></li>
</ul>
<h3 id="how-to-set-a-breakpoint">How to set a breakpoint</h3>
<ul>
<li>On the Processor pane, click Breakpoint. It will say <code>Breakpoint is off'' *  Enter the breakpoint command and click Set Breakpoint *  \texttt{BPeq BPpc (BPhex "01a6")} *  It will say</code>Breakpoint is on’’. Click Close
<ul>
<li>On Processor, click Run. It will stop when the pc register gets the value you specified</li>
</ul></li>
</ul>
<h2 id="trees">Trees</h2>
<h3 id="tree">Tree</h3>
<ul>
<li>A node doesn’t have to have two fields named  and  — it’s normal to define a specific node type for an application program.</li>
<li>Nodes with  and  can be connected into a .</li>
<li>Nodes can also have with several fields containing data, not just one ``value’’ field.</li>
<li>And a node can have several pointer fields<span class="math inline">…</span></li>
<li>Common case: a  has two pointers in each node, named  and .</li>
<li>Each of these can either contain nil, or point to another node.</li>
</ul>
<p>Node : record value ; the actual data in the node left ; left subtree is a pointer to a Node right ; right subtree is a pointer to a Node</p>
<ul>
<li>Similar to a node for a linked list, but with two pointers</li>
<li>There can also be several fields for data, not just one ``value’’ field</li>
<li>And we could have more than just two pointers</li>
</ul>
<h3 id="a-binary-tree">A binary tree</h3>


<p>In computer science, for some reason we draw trees upside down</p>

<p>Suppose p is a pointer to the tree</p>
<ul>
<li>(*p).left is the pointer to the left subtree</li>
<li>(*p).right is the pointer to the right subtree</li>
</ul>
<h3 id="applications-of-trees">Applications of trees</h3>
<p>Trees are used everywhere in programming</p>
<ul>
<li>To hold structured data</li>
<li>To make programs faster ( faster)</li>
</ul>
<h3 id="holding-structured-data">Holding structured data</h3>
<ul>
<li>A compiler reads in program text, which is just a character string: a sequence of characters.</li>
<li>It needs to represent the deep structure underlying that sequence of characters.</li>
<li>This is done by building a tree (the part of a compiler that takes a character string and produces a tree is called the ).</li>
</ul>
<h3 id="parsing">Parsing</h3>
<pre><code>x := a + b * c</code></pre>

<h3 id="another-application-of-jump-tables">Another application of jump tables!</h3>
<ul>
<li>In complicated applications, trees normally have </li>
<li>Examples: operations with 1 operand; operations with 2 operands; control constructs with a boolean expression and two statements, etc.</li>
<li>So there are several different kinds of record</li>
<li>Each record has a  in the first word</li>
<li>The value of the code determines how many more words there are in the record, and what they mean</li>
<li>When a program has a pointer to a node, it needs to examine the code and take different actions depending on what the code is</li>
<li>This is done with a jump table</li>
</ul>
<h3 id="searching">Searching</h3>
<ul>
<li>Suppose we have a large number of records (e.g. a database)</li>
<li>We want to search the database for an entry where a field has a certain value (e.g. search for a record where the MatricNumber field is 123456)</li>
<li>If you just have these records in an array, or a linked list, you have to search them one by one</li>
<li>On average, you have to look at half the entries in the database to find the one you want</li>
<li>If you double the size of the database, you double the average time to look up an entry</li>
<li>Terminology: this is called  or <span class="math inline"><em>O</em>(<em>n</em>)</span> complexity</li>
</ul>
<h3 id="a-better-approach">A better approach</h3>
<ul>
<li>Linear search is silly if you can place the records in order</li>
<li>You’re trying to find the telephone number of John Smith in the phone book</li>
<li>Would you do this? \begin{enumerate}</li>
<li>It isn’t Aardvark, Aaron</li>
<li>It isn’t Acton, Rebecca</li>
<li>It isn’t Anderson, Susan</li>
<li>It isn’t Atwater, James</li>
<li><span class="math inline">…</span> 8 million more unsuccsessful searches because this is the Los Angeles directory \end{enumerate}</li>
<li>That’s silly!</li>
<li>Open the book to the middle, notice that S is in the second half</li>
<li>Open the book to the middle of the second half <span class="math inline">…</span></li>
<li>Each time you look at an entry in the book, you discard </li>
</ul>
<h3 id="binary-search-tree">Binary search tree</h3>

<ul>
<li><p>At every level: if a node contains <span class="math inline"><em>x</em></span>, then</p>
<ul>
<li>every node in the left subtree is less than <span class="math inline"><em>x</em></span>, and</li>
<li>every node in the right subtree is greater than <span class="math inline"><em>x</em></span>.</li>
</ul></li>
<li><p>You can search the tree by starting at the root, and at every step you  whether to go left or right</p></li>
</ul>
<h3 id="algorithmic-complexity">Algorithmic Complexity</h3>
<ul>
<li>Complexity is concerned with </li>
<li>This is expressed as a function of the input size <span class="math inline"><em>n</em></span></li>
<li><p>Normally we don’t care about the  function, and we use O-notation. Instead of a funciton like <span class="math inline"><em>f</em>(<em>n</em>) = 4.823 × <em>n</em></span>, we just write <span class="math inline"><em>f</em>(<em>n</em>) = <em>O</em>(<em>n</em>)</span></p></li>
<li><span class="math inline"><em>O</em>(1)</span> — if input grows, the execution time remains unchanged. This is unrealistic: the program cannot even look at the input!</li>
<li><span class="math inline"><em>O</em>(<em>n</em>)</span> — if the input is 5 times bigger, the execution time is 5 times bigger. This is the best you can hope for</li>
<li><p><span class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span> — if the input is 5 times bigger, the time is 25 times bigger</p></li>
</ul>
<h3 id="algorithm-is-more-important-than-small-optimisation">Algorithm is more important than small optimisation</h3>
<ul>
<li><p>Some programmers spend lots of effort trying to save one or two instructions in a piece of a program</p>
<ul>
<li>But it doesn’t matter much whether a program takes 2.00032 seconds or 2.00031 seconds</li>
</ul></li>
<li><p>It’s much more important to use a suitable </p></li>
<li>On small data it doesn’t make much differnce</li>
<li><p>On large (realistic) data, a better algorithm makes a huge difference</p></li>
</ul>
<h3 id="complexity-for-search">Complexity for search</h3>
<ul>
<li><p>Ordered lists</p>
<ul>
<li>The Ordered Lists program has an operation to search a list for a value x</li>
<li>On average, you need to look through half of the data to find out whether x is present</li>
<li>If the list were  ordered, you would need to look through  of the data to determine whether x is present</li>
<li>So the ordered list makes the search about twice as fast</li>
<li>But in either case, this is <span class="math inline"><em>O</em>(<em>n</em>)</span> — if you double the data size, the average time is doubled</li>
</ul></li>
<li><p>Binary search tree</p></li>
<li>The number of comparisons needed is roughly the height of the tree</li>
<li><p>If the tree is , the time complexity is <span class="math inline"><em>O</em>(log <em>n</em>)</span></p></li>
</ul>
<h3 id="how-much-faster">How much faster?</h3>
<ul>
<li><p>With a linear data structure (array, linked list)</p>
<ul>
<li>Each time you compare a database entry with your key, you eliminate one possibility</li>
<li>The time is proportional to the size of the database</li>
<li>It’s called  — time = <span class="math inline"><em>O</em>(<em>n</em>)</span></li>
<li></li>
</ul></li>
<li><p>With a binary search tree</p></li>
<li>Each time you compare a database entry with your key, you eliminate (on average) half of the possibilities</li>
<li>The time is proportional to  of the database</li>
<li>It’s called  — time = <span class="math inline"><em>O</em>(log <em>n</em>)</span></li>
<li></li>
<li><p>There’s a saying: </p></li>
</ul>
<h3 id="a-common-pitfall">A common pitfall</h3>
<ul>
<li>When you’re writing a program, it’s natural to test it with small data</li>
<li>Even if the algorithm has bad complexity, the testing may be fast</li>
<li>But then, when you run the program on real data, the execution time is intolerable</li>
<li>That means going back and starting over again</li>
<li>So it’s a good idea to be aware of the complexity of your algorithm from the beginning</li>
</ul>
<h3 id="how-bad-can-complexity-be">How bad can complexity be?</h3>
<p>Order of magnitude estimate of time for input of size <span class="math inline"><em>n</em></span></p>

<p>Lots of real problems have data size larger than 1,000. Lots of algorithms have exponential complexity: <span class="math inline">2<sup><em>n</em></sup></span>.</p>
<h2 id="interrupts">Interrupts</h2>
<h3 id="control-constructs">Control constructs</h3>
<p>Control constructs determine the order of execution of statements</p>
<ul>
<li><p>We have seen some high level control constructs</p>
<ul>
<li>if b then S</li>
<li>if b then S1 else S2</li>
<li>while b do S</li>
<li>for var := expr1 to expr2 do S</li>
<li>procedure</li>
<li><p>And there are plenty more</p></li>
<li><p>These are implemented using just a couple of low level control constructs</p></li>
<li>goto L</li>
<li><p>if b then goto L</p></li>
<li><p>But there is one more low level primitive: </p></li>
</ul></li>
</ul>
<h3 id="another-kind-of-control-losing-control">Another kind of control: losing control!</h3>
<ul>
<li>Control constructs built on goto and if-then-goto let the program decide what to do next</li>
<li>Sometimes we want  — not the program — to decide what to do next</li>
</ul>
<h3 id="interrupts-1">Interrupts</h3>
<ul>
<li>The hardware provides  which are used to implement processes</li>
<li>An interrupt is an </li>
<li>It goes either to the operating system or to an error handler</li>
<li>But it is not the result of a jump instruction — it happens automatically when an external event occurs</li>
<li>The program that was running never jumped to the OS - the processor just stops executing its instructions, and starts executing the OS instead</li>
<li>It’s like talking to a group of people, and suddenly you get interrupted!</li>
</ul>
<h3 id="what-causes-an-interrupt">What causes an interrupt</h3>
<ul>
<li>An error in a user program: e.g. overflow (result of arithmetic is too large to fit in a registers)</li>
<li>A trap: this is an explicit jump to the operating system, but the program doesn’t specify the address</li>
<li>An external event: a disk drive needs attention , or the timer goes off</li>
</ul>
<h3 id="what-happens-when-an-interrupt-occurs">What happens when an interrupt occurs</h3>
<ul>
<li>The computer is a digital circuit</li>
<li>Without interrupts, it repeats forever \begin{enumerate}</li>
<li>Fetch the instruction at the address in the pc register</li>
<li>Execute the instruction \end{enumerate}</li>
<li>With interrupts, it repeats this forever: \begin{enumerate}</li>
<li>Check to see if there is an interrupt request</li>
<li>If there is, savepc := pc, </li>
<li>Fetch the instruction at the address in the pc register</li>
<li>Execute the instruction \end{enumerate}</li>
<li>Since the pc has been modified, the next instruction will not be part of the program that was interrupted — it will be the operating system</li>
</ul>
<h3 id="saving-state-1">Saving state</h3>
<ul>
<li>Remember, an interrupt is a jump to the OS</li>
<li>This requires setting the address of OS in the pc register</li>
<li>But if we simply assign a value to pc, the computer has forgotten where the interrupted program was</li>
<li>Therefore the hardware must ``save state’’: savepc := pc</li>
<li>The OS has a special instruction that enables it to get the value of savepc</li>
</ul>
<h3 id="how-interrupts-are-used">How interrupts are used</h3>
<ul>
<li><p>Interrupts can be used to  in a program, e.g. arithmetic overflow (the result is too big to fit in a register)</p>
<ul>
<li><p>If an overflow occurs (or divide by zero, or some other error) we want the program to jump to an error handler</p></li>
<li><p>Trap is similar to an interrupt, and is used to  from the operating system</p></li>
<li><p>User program can’t halt the machine, but uses trap to ask the OS to stop running the program</p></li>
<li><p>They can be used to provide  to an Input/Output device</p></li>
<li><p>A disk drive may generate an interrupt when the spinning platter reaches a certain point, and it needs service right away — within a tight deadline</p></li>
<li><p>Interrupts are used to implement </p></li>
<li><p>The operating system gives each process a  in round-robin order, so each process makes progress</p></li>
</ul></li>
</ul>
<h3 id="interrupts-and-programming-languages">Interrupts and programming languages</h3>
<ul>
<li>Most programming languages don’t provide the ability to work directly with interrupts
<ul>
<li><p>But many programming language provide </p></li>
<li>Without an exception handler, a division by 0 might terminate the program</li>
<li>In the program, you can set an exception handler: a procedure to execute if a division by 0 occurs</li>
<li><p>The compiler might implement this in several different ways:</p></li>
</ul>
<pre><code>*  It could put in explicit comparison and conditional jumps
 to check each division
*  Or it could set up an interrupt handler (this requires
 negotiation with the operating system)</code></pre></li>
</ul>
<h3 id="using-interrupts-to-catch-errors">Using interrupts to catch errors</h3>
<h3 id="catching-errors">Catching errors</h3>
<ul>
<li>As a program runs, it may accidentally produce an error</li>
<li><p>Two examples:</p></li>
<li>An arithmetic instruction produces a result that’s too large to fit in a register: this is called </li>
<li><p>A divide instruction attempted to divide by 0</p></li>
<li>It’s better to  the error and </li>
<li>This makes software </li>
<li>If the program just keeps going, it’s likely to produce wrong results and it won’t tell</li>
<li><p>Two approaches for catching errors (use one or the other):</p></li>
<li>Explicit error checking</li>
<li><p>Interrupts</p></li>
</ul>
<h3 id="explicit-error-checking">Explicit error checking</h3>
<ul>
<li>Most computers have a  with a bit indicating each kind of error</li>
<li>Sigma16 uses R15, and a bit in R15 indicates whether overflow occurred</li>
<li>Every time you do an add (or other arithmetic instruction), that bit is set to 0 if it was ok, and 1 if there was overflow</li>
<li>You can check for this with a conditional jump, and then take appropriate action</li>
<li>Of course, you have to decide what the appropriate action is!</li>
</ul>
<pre><code>   add      R2,R5,R4     ; x := a + b
   jumpovfl TooBig[R0]   ; if overflow then goto TooBig</code></pre>
<h3 id="problems-with-explicit-error-checking">Problems with explicit error checking</h3>
<ul>
<li>You have to put in the jumpovfl </li>
<li>This makes the program considerably longer</li>
<li>It’s also inefficient: those conditional jumps take time</li>
<li>It is ``fragile’’: if you forget the jumpovfl  in a big program, that program can malfunction</li>
</ul>
<h3 id="a-better-approach-interrupts">A better approach: interrupts!</h3>
<ul>
<li>Most computers (including Sigma16) can also perform an interrupt if an overflow (or other error) occurs</li>
<li>The digital circuit checks for overflow (or other error) </li>
<li>If the error occurred, the circuit performs an interrupt</li>
<li>The OS then decides what to do</li>
<li>User program can tell the OS in advance ``in case of overflow, don’t kill me, but jump to this address: TooBig’’</li>
<li>There is a special trap code for making this request</li>
<li>In some programming languages, this is called <code>setting an   exception handler'' or</code>catching exceptions’’</li>
<li>There is a special control register with a bit that specifies whether overflow should trigger an interrupt</li>
</ul>
<h3 id="why-are-interrupts-better-than-explicit-checking">Why are interrupts better than explicit checking?</h3>
<ul>
<li>Interrupts guarantee that  operation is checked</li>
<li>It is faster: the circuit can do this checking with essentially zero overhead</li>
<li>It is easier: the programmer doesn’t have to worry about it</li>
<li>The program is shorter: don’t need a jump after every arithmetic instruction</li>
</ul>
<h3 id="concurrent-processes">Concurrent processes</h3>
<h3 id="interrupts-and-processes">Interrupts and processes</h3>
<ul>
<li><p>One of the central features provided by an operating system is </p>
<ul>
<li>A process is a running program</li>
<li>Think of a program as a document: it’s just sitting there</li>
<li>A process is all the action that happens when a program is executed: it has its variables, the variables change over time, Input/Output happens, <span class="math inline">…</span></li>
<li>Several different processes may be running on the same program (e.g. multiple tabs on a web browser)</li>
<li><p>Each process has its own variables</p></li>
<li>Processes are implemented using interrupts</li>
<li>The idea: the OS gives a user program a </li>
<li><p>The user is interrupted, and the OS can then run a different program</p></li>
</ul></li>
</ul>
<h3 id="waiting-for-io-wasted-time">Waiting for I/O = wasted time</h3>
<ul>
<li>Motivation for processes comes from I/O</li>
<li><p>The problem:</p></li>
<li>Instructions execute quickly — typically about 0.3ns (about <span class="math inline">3 × 10<sup>9</sup></span> per second)</li>
<li>Input/output is much slower, especially if mechanical devices are involved</li>
<li>An I/O operation runs slower than an instruction by a factor ranging from <span class="math inline">10<sup>4</sup></span> to <span class="math inline">10<sup>8</sup></span></li>
<li><p>For comparison, a supersonic jet fighter is only <span class="math inline">10<sup>3</sup></span> times faster than a turtle.</p></li>
<li><p>If a program does  <span class="math inline">⋯</span>  <span class="math inline">⋯</span>  <span class="math inline">⋯</span> it is likely to spend a lot of time waiting for the I/O</p></li>
</ul>
<h3 id="a-process-must-sometimes-wait">A process must sometimes wait</h3>
<p></p>
<h3 id="dont-wait-switch-to-another-process">Don’t wait — switch to another process</h3>
<p></p>
<h3 id="dont-wait-switching-to-another-program">Don’t wait — switching to another program</h3>
<ul>
<li><p>When a program needs to perform I/O, it</p>
<ul>
<li>Requests the operating system to do the I/O</li>
<li>The OS  the I/O but doesn’t wait for it to finish</li>
<li>The OS then allows a  to run for a while</li>
<li>Eventually, when the I/O operation finishes, the OS allows the original program to resume</li>
</ul></li>
<li>This leads to an operating system running a large number of separate programs</li>
<li><p>Each running program is called a </p></li>
</ul>
<h3 id="concurrent-processes-1">Concurrent processes</h3>
<ul>
<li>A  is a running program</li>
<li>At an instant of time, the computer is physically executing just one instruction (which belongs to one process)</li>
<li>From time to time (around 100 or more times per second), the system will transfer control from one process to another one — this is called a </li>
<li><p>Time scale:</p></li>
<li>At the scale of a nanosecond (<span class="math inline">10<sup> − 9</sup></span> second) the computer is executing just one instruction belonging to a process; all other processes are doing nothing</li>
<li><p>At the scale of human perception (<span class="math inline">10<sup> − 2</sup></span> second) it appears that  the processes are making smooth processes</p></li>
<li><p>A motion picture is just a sequence of still photographs but displaying them rapidly gives the impression of continuous motion</p></li>
</ul>
<h3 id="operating-system-kernel">Operating system kernel</h3>
<ul>
<li>A process does not transfer control to another process</li>
<li>How could it? When you write a program, you don’t know what other programs will be running when this one is!</li>
<li><p>A process break means</p></li>
<li>Running process jumps to the operating system kernel</li>
<li>The kernel is the innermost, core, central part of the OS</li>
<li>The kernel has a table of all the processes</li>
<li>(On Windows: right-click the toolbar, launch the Task Manager, click Processes tab)</li>
<li><p>The kernel chooses another process to run and jumps to it</p></li>
</ul>
<h3 id="events-that-can-trigger-an-interrupt">Events that can trigger an interrupt</h3>
<ul>
<li>There is a timer that ``bings’’ periodically — each time it goes off it generates an interrupt</li>
<li>When an Input/Output device has competed a read or write, it generates an interrupt</li>
</ul>
<h3 id="interrupts-and-preemptive-scheduling">Interrupts and preemptive scheduling</h3>
<ul>
<li>When the operating system jumps to a user process, it sets a  which will ``go off’’ after a set amount of time (e.g. 1ms — <span class="math inline">10<sup> − 3</sup></span> second)</li>
<li><p>When does a running process jump to the operating system?</p></li>
<li>When the timer goes off</li>
<li><p>When the process makes an I/O request</p></li>
<li><p>This guarantees that the process won’t run forever and  even if it goes into an infinite loop</p></li>
</ul>
<h3 id="the-scheduler">The Scheduler</h3>
<ul>
<li>The core of an operating system is the scheduler</li>
<li>It maintains a list of all the processes</li>
<li><p>When an interrupt occurs:</p></li>
<li>The process that was running stops executing instructions: it has been interrupted</li>
<li>The OS takes any necessary action (e.g. service the I/O device)</li>
<li>Then the OS jumps to the scheduler</li>
<li>The scheduler chooses a different process to run</li>
<li><p>It sets the timer and jumps to that process</p></li>
</ul>
<h3 id="mouse">Mouse</h3>
<ul>
<li>The mouse isn’t connected to the cursor on the screen!</li>
<li>When you move the mouse, it generates an interrupt</li>
<li>The OS reads the mouse movement</li>
<li>Then it calculates where the cursor should be and redraws it</li>
<li>This happens many times per second, giving the illusion of smooth movement</li>
</ul>
<p>%  </p>
<h3 id="how-interrupts-are-implemented">How interrupts are implemented</h3>
<h3 id="how-interrupts-are-implemented-1">How interrupts are implemented</h3>
<ul>
<li>Interrupts cannot be implemented in software!
<ul>
<li>The processor (the CPU) repeatedly goes through a sequence of steps to execute instructions</li>
<li>This is the  and it’s performed by a digital circuit in the processor (the )</li>
<li>Interrupts are implemented by the control circuit</li>
</ul></li>
</ul>
<h3 id="control">Control</h3>
<ul>
<li>We have seen the RTM, which executes operations like reg[d] := reg[a] + reg[b]</li>
<li>This is the core of a processor!</li>
<li>We have seen the control registers: pc, ir, adr</li>
<li>The processor uses these to keep track of what it is doing</li>
</ul>
<h3 id="the-control-algorithm">The Control Algorithm</h3>
<ul>
<li>The behaviour of the entire processor is defined by a </li>
<li><p>We can describe this using a special notation (which looks like a simple programming language, but it is not a program)</p></li>
<li>Notations</li>
<li><p>The control algorithm</p></li>
<li><p>We can implement the control algorithm using flip flops and logic gates</p></li>
</ul>
<h3 id="registers">Registers</h3>
<ul>
<li>pc (program counter) contains address of the next instruction</li>
<li>ir (instruction register) contains the current instruction (or first word of an RX instruction)</li>
<li>adr (address register) holds the effective address for RX instructions</li>
<li>reg[a] (register file) contains 16 registers for use by user program</li>
</ul>
<h3 id="notation-1">Notation</h3>
<ul>
<li>pc, ir, adr — contents of these 16-bit registers</li>
<li>ir_op,ir_d, ir_a, ir_d — 4-bit fields in the ir</li>
<li>reg[x] — the register in the register file with address x</li>
<li>mem[x] — the memory location with address x</li>
</ul>
<h3 id="infinite-loop">Infinite loop</h3>
<ul>
<li>In hardware, we  infinite loops</li>
<li>The computer should never stop executing instructions!</li>
</ul>
<pre><code>repeat forever
  action
  action
  ...
  action</code></pre>
<h3 id="case-dispatch">Case dispatch</h3>
<ul>
<li>We often have an  — a binary number, with <span class="math inline"><em>k</em></span> bits (e.g. 4 bits)</li>
<li>There are <span class="math inline">2<sup><em>k</em></sup></span> alternative actions to take, depending on the value of the code</li>
</ul>
<pre><code>case opcode
  0: action
  1: action
  ...
  15: action</code></pre>
<h3 id="control-algorithm">Control algorithm</h3>
<pre><code>repeat forever
  if interrupt_request
    then savepc := pc
         pc := 0  ; address of interrupt handler in OS
    else ir := mem[pc],  pc := pc + 1            ; fetch instruction
         case ir_op
         0: reg[ir_d] := reg[ir_a] + reg[ir_b]   ; add
         1: reg[ir_d] := reg[ir_a] - reg[ir_b]   ; sub
         2: reg[ir_d] := reg[ir_a] * reg[ir_b]   ; mul
         ... more RRR instructions are similar
         ...
         15: adr := mem[pc], pc := pc + 1        ; displacement
             adr := adr + reg[ir_a]              ; effective address
             case ir_b
               0: reg[ir_d] := adr               ; lea
               1: reg[ir_d] := mem[adr]          ; load
               2: mem[adr] := reg[ir_d]          ; store
               3: pc := adr                      ; jump
               ... more RX instructions are similar
               ...</code></pre>
<h2 id="languages-and-systems">Languages and systems</h2>
<h3 id="advice-on-software-engineering">Advice on software engineering</h3>
<p>What should a software engineer study if they want to learn how to write efficient code?</p>
<p>Hyde, R. (2009). The Fallacy of Premature Optimization. , Association for Computing Machinery, February 2009. </p>
<h3 id="what-should-a-software-engineer-study">What should a software engineer study?</h3>
<p>Hyde says (quotation):</p>
<ul>
<li><p>The first subject to master is . Because all real programs execute on real machines, you need to understand how real machines operate if you want to write efficient code for those machines.</p></li>
<li><p>The second subject to study is . Though few programmers use assembly language for application development, assembly language knowledge is critical if you want to make the connection between a high-level language and the low-level CPU. <span class="math inline">…</span> It doesn’t really matter which assembly language you learn nor does it matter which CPU’s instruction set you study. What you really need to learn are the basic operational costs of computation.</p></li>
<li><p>The third important subject a software engineer should study is basic compiler construction, to learn .</p></li>
</ul>
<h3 id="syntax-semantics-compilation">Syntax, semantics, compilation</h3>
<ul>
<li><p>Primary aspects of a programming language</p>
<ul>
<li>Syntax is the  of a program</li>
<li>Semantics is the  of the program</li>
<li>Compilation (or interpretation) is how the language is implemented so it can run on a computer</li>
</ul></li>
</ul>
<h4 id="syntax-easier-but-less-important">Syntax — easier but less important</h4>
<ul>
<li>Syntax is the  of a program</li>
<li>Did you spell the keywords correctly? Is the punctuation right?</li>
<li><p>Syntax is easy</p></li>
<li>The rules are clear cut</li>
<li>If in doubt, just look it up</li>
<li><p>Example: various languages have different names for the same thing: ,, . These differences are superficial</p></li>
</ul>
<h3 id="syntax-errors">Syntax errors</h3>
<ul>
<li><p>Compilers insist that the syntax is right</p>
<ul>
<li><p>In English, if you spell a word wrong or have a missing comma you’ll (probably) still be understood</p></li>
<li><p>But — see  by Lynn Truss. Note the comma! What was meant was {<code>The panda eats shoots and leaves''}, not {\bluetext</code>The panda eats, shoots, and leaves’’}</p></li>
</ul></li>
<li><p>Can’t a compiler be equally forgiving?</p></li>
<li>There were experiments with compilers that guess what the programmer meant</li>
<li>It was a disaster: the compiler nearly always guessed correctly<span class="math inline">…</span></li>
<li><p>But occasionally it would guess wrong</p></li>
</ul>
<ul>
<li>
<ul>
<li>You have to debug code that is not in the file! And you cannot see it!</li>
<li>You  the compiler to insist that the syntax is absolutely correct</li>
</ul></li>
</ul>
<h3 id="example-of-syntax-operator-precedence">Example of syntax: operator precedence</h3>
<ul>
<li>Expressions can contain many operations, but the computer can do only one operation at a time</li>
<li>We can make the operations explicit by using parentheses around each operation</li>
<li>You don’t have to write the parentheses, but the compiler needs to know where they go!</li>
<li>a + b + c is parsed as (a + b) + c</li>
<li>a + b * c is parsed as a + (b * c)</li>
</ul>
<h3 id="deeper-example-of-syntax-ambiguity">Deeper example of syntax: ambiguity</h3>
<ul>
<li>A language is  if a sentence in the language can have two different meanings</li>
<li>English is full of ambiguity</li>
<li>Programming languages are designed to avoid ambiguity, most of the time</li>
<li>If ambiguity is possible, the compile needs to know how to resolve it, </li>
</ul>
<h3 id="ambiguity-in-if-then-else">Ambiguity in if-then-else</h3>
<p>This is ambiguous:  ~~~~ if b1 then if b2 then S1 else S2 ~~~~</p>
<p>There are two interpretations, and they lead to different results</p>
<pre><code>if b1 then { if b2 then S1 else S2 }
  b1 = true,  b2 = true     S1
  b1 = true,  b2 = false    S2
  b1 = false, b2 = true
  b1 = false, b2 = false

if b1 then { if b2 then S1 } else S2
  b1 = true,  b2 = true     S1
  b1 = true,  b2 = false
  b1 = false, b2 = true     S2
  b1 = false, b2 = false    S2</code></pre>
<h3 id="how-does-python-prevent-ambiguity">How does Python prevent ambiguity?</h3>
<ul>
<li><p>The structure of the program is determined by </p>
<ul>
<li>This means it is essential to indent the program properly</li>
<li>It makes the program structure highly visible to the programmer</li>
</ul></li>
<li><p>Some languages use braces to indicate structure (e.g. C, Java)</p></li>
<li>The compiler ignores the indentation, and uses the braces</li>
<li>Programmers tend to focus on the indentation and may overlook the braces</li>
<li><p>This is more error-prone</p></li>
</ul>
<h3 id="goto">goto</h3>
<ul>
<li>Usually programs are more readable and more reliable if written with while loops, if-then-elif-elif-else, for loops, and similar higher level constructs</li>
<li>Programs that jump around randomly with goto statements are harder to understand, and likely to contain bugs</li>
<li>This gave the goto statement a bad reputation</li>
<li><p>But</p></li>
<li>The goto statement is simply a jump instruction, and it is  for use at low level</li>
<li><p>There are some circumstances where goto may be the best solution, but these are rare</p></li>
</ul>
<h3 id="goto-spelled-differently">goto spelled differently</h3>
<ul>
<li><p>Some programming languages provide restricted forms of goto</p>
<ul>
<li>break</li>
<li>continue</li>
</ul></li>
<li><p>These are goto statements without a label, but with a predefined destination they go to</p></li>
<li>Advantage — you may recognise the pattern being used by a programmer</li>
<li><p>Disadvantage — you need to know for sure to where your goto goes</p></li>
</ul>
<h3 id="the-break-statement">The break statement</h3>
<ul>
<li>C and its descendants have break, as does Python</li>
<li>Break is a goto that goes to the end of the  loop it’s in</li>
<li>In Python you can have an else clause to execute when a for or while loop finishes, but this is skipped if you terminate the loop with break</li>
<li><p>What if you want to break out of several loops?</p></li>
<li>There is no good way to do this in Python</li>
<li><p>It’s best to restructure your program, to avoid break</p></li>
</ul>
<h3 id="where-does-break-go">Where does break go?</h3>
<pre><code>for i in range (1, 5):
    print (i)
    for j in range (20, 22):
        print (j)
        if i == 3:
            break
        for k in range (40, 43):
            print (k)
            if k == 41:
                break
            print (k)</code></pre>
<h3 id="the-continue-statement">The continue statement</h3>
<ul>
<li>In C and Python, continue goes to the end of the current loop which then continues executing</li>
<li>It’s a way of staying in the loop but skipping the statements after the continue</li>
<li>Warning! Several programming languages have a statement that is  continue — but it does nothing and is equivalent to the pass statement in Python</li>
</ul>
<h3 id="break-and-continue-translation-to-low-level">Break and continue: translation to low level</h3>
<pre><code>
loop1
   if (i&lt;n)=False then goto loop1done
   ...
   if ... then goto loop1      ; This is a continue statement
   ...
   if ... then goto loop1done  ; This is a break statement
   ...
   goto loop1
loop1done
</code></pre>
<ul>
<li>continue goes to the top of the innermost loop containing the continue: it skips the rest of 
<ul>
<li>break goes to right after the end of the innermost loop containing the break: it </li>
</ul></li>
</ul>
<h4 id="semantics-harder-but-more-important">Semantics — harder but more important</h4>
<h3 id="semantics">Semantics</h3>
<ul>
<li>Semantics means </li>
<li>The  of a language is </li>
<li><p>The semantics of a program is </p></li>
<li><p>Given its inputs, what are its outputs?</p></li>
</ul>
<h3 id="how-is-the-semantics-of-a-language-defined">How is the semantics of a language defined?</h3>
<ul>
<li><p>Using natural language to describe it</p>
<ul>
<li>Vague description in English of what each construct does</li>
<li>A carefully written description in English, written to be as precise as possible</li>
</ul></li>
<li><p>Using mathematics or program transformation</p></li>
<li>Denotational semantics: a precise mathematical specification. Given a program, it gives a mathematical function from program inputs to outputs</li>
<li>Operational semantics: gives a sequence of reduction rules that give a precise model of the program’s execution</li>
<li><p>Transformational semantics: a translation from a program into a simpler language, where the semantics is assumed to be clear</p></li>
</ul>
<h3 id="why-do-the-translation-from-high-to-low-level">Why do the translation from high to low level?</h3>
<ul>
<li>This is the semantics of the high level constructs</li>
<li>It explains precisely what the high level means</li>
<li>It shows what the compiler will do with the program (compilers do intermediate level translations like this; many compilers use several intermedate steps)</li>
<li>It makes explicit the execution time of the construct</li>
<li>The low level is very close to assembly language</li>
<li>It’s easier to go from high level to assembly language in two small steps, rather than one giant leap</li>
</ul>
<h3 id="watch-out-for-loose-explanations">Watch out for loose explanations</h3>
<ul>
<li><p>Here’s a quotation from https://docs.python.org/3.7/tutorial/introduction.html</p>
<ul>
<li><p>``The while loop executes as long as the condition (here: <span class="math inline"><em>a</em> &lt; 10</span>) remains true’’</p></li>
<li></li>
<li>It  that if <span class="math inline"><em>a</em></span> is changed in the middle of the loop, making it less than 10, the loop will stop executing</li>
<li>But the computer does not continuously monitor <span class="math inline"><em>a</em> &lt; 10</span> and break out of the loop as soon as it becomes false</li>
<li>To see what happens, </li>
<li><p>The while loop checks the boolean <span class="math inline"><em>a</em> &lt; 10</span> at the top of the loop; if false it exits the loop, and if true it executes  even if the boolean became false in the middle</p></li>
</ul></li>
</ul>
<h3 id="semantics-of-while">Semantics of while</h3>
<p>{ ~~~~ while b do S ~~~~ } is translated to { ~~~~ L1: if not b then goto L2 S goto L1 L2: ~~~~ }</p>
<ul>
<li>If you understand the meaning of :=, goto, if b then goto, you can understand the meaning of </li>
<li>b is an arbitrary boolean expression</li>
<li>S is an arbitrary statement</li>
<li>L1 and L2 are ``fresh’’ labels: they can’t be used anywhere else</li>
</ul>
<h3 id="lists-iterators-and-for-loops">Lists, +, +=, iterators, and for loops</h3>
<ul>
<li>How are lists represented?
<ul>
<li>What do the + and += operators do?</li>
<li>What is an iterator, and how does it work?</li>
<li>What does a for loop do? How does it compare with a while loop?</li>
</ul></li>
</ul>
<h3 id="lets-do-some-matrix-calculations">Let’s do some matrix calculations</h3>
<p>Set up a list of 5 elements</p>
<pre><code>coords = [[0,0]] * 5
print (&#39;coords = &#39;, coords)  # [[0,0], [0,0], [0,0], [0,0], [0,0]]</code></pre>
<p>The result is</p>
<pre><code>coords =  [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]</code></pre>
<p>Looks good! Now set some sub-elements:</p>
<pre><code>coords[3][1] = 7
coords[4][0] = 5</code></pre>
<p>{ Result may not be what we expected, or wanted: ~~~~ coords[2] = [5, 7] coords = [[5, 7], [5, 7], [5, 7], [5, 7], [5, 7]] ~~~~ }</p>
<p>What’s going on?</p>
<h3 id="what-does-mean-in-python">What does += mean in Python?</h3>
<ul>
<li><p>Google search for </p>
<ul>
<li><p>``, where a and b can be numbers, or strings, or tuples, or lists (but both must be of the same type).’’</p></li>
<li><p>Stack overflow search for </p></li>
<li>``+= adds another value with the variable’s value and assigns the new value to the variable.’’</li>
<li>``It adds the right operand to the left. x += 2 means x = x</li>
<li><ol start="2" type="1">
<li>It can also add elements to a list’’</li>
</ol></li>
<li><p></p></li>
</ul></li>
</ul>
<h3 id="is-a-b-shorthand-for-a-a-b">Is a += b shorthand for a = a + b?</h3>
<p>Try  ~~~~ print (‘Defining a = a + [3, 4]’) a = [1, 2] b = a print (‘a =’, a, ’ b = ‘, b) a = a + [3, 4] print (’a =’, a, ’ b = ’, b) ~~~~</p>
<p>The results: {a = [1, 2, 3, 4] b = [1, 2]}  Now try  ~~~~ print (‘Defining a += [3, 4]’) a = [1, 2] b = a print (‘a =’, a, ’ b = ‘, b) a += [3, 4] print (’a =’, a, ’ b = ’, b) ~~~~</p>
<p>The results: {a = [1, 2, 3, 4], b = [1, 2, 3, 4]}</p>
<p></p>
<h3 id="how-do-we-figure-out-problems-like-this">How do we figure out problems like this?</h3>
<ul>
<li>Need to understand all the fundamental concepts of the language
<ul>
<li>It’s best to study  source </li>
<li>Develop a clear  for what the language constructs really mean</li>
<li><p>And here’s some advice: from Stack Overflow</p></li>
<li><p><code>it's a basic operator for python (and many other languages    too), you should start with google, if you never read any python    references.</code></p></li>
<li>This may be ok if you already understand all the foundations and just want to look up a detail, but otherwise </li>
<li><p>Let’s look in more detail at lists<span class="math inline">…</span></p></li>
</ul></li>
</ul>
<h4 id="are-two-nodes-with-the-same-value-identical">Are two nodes with the same value identical?</h4>
<h3 id="are-two-nodes-with-the-same-value-identical-1">Are two nodes with the same value identical?}</h3>
<p>Define b = a </p>
<pre><code>a = [1, 2, 3, 4]
b = a
print (&#39;(1)  a = &#39;, a, &#39; b = &#39;, b)</code></pre>
<p>Both a and b have the value [1, 2, 3, 4], but are the actual nodes in their representations distinct, or shared? </p>
<p>Try modifying an element of a and see if it changes b, and vice versa</p>
<pre><code>a[1] = 100
b[3] = 300
print (&#39; a = &#39;, a, &#39; b = &#39;, b)
</code></pre>
<p>Run this, and you’ll see that changing an element of either a or b also changes the corresponding element of the other. The values of a and b are simply pointers, and .</p>
<h4 id="low-level-list-manipulation">Low level list manipulation</h4>
<h3 id="low-level-list-manipulation-1">Low level list manipulation</h3>
<ul>
<li>You can assign pointers: if a is a list, b = a makes b point to the same node a points to</li>
</ul>
<pre><code>; b = a,   where a is a list
   load   R1,a[R0]    ; R1 = a
   store  R1,b[R0]    ; b := a</code></pre>
<ul>
<li>You can write expressions that create a new list, but don’t modify any existing lists: 
<ul>
<li><p>You can modify an existing list structure</p></li>
<li>a.copy()</li>
<li>a.append(b)</li>
<li><p>a.extend(b)</p></li>
<li><p>All of these are implemented with while loops that traverse a</p></li>
</ul></li>
</ul>
<h3 id="b-a.copy">b = a.copy()</h3>
<p>Traverse a and make a new node for each node in a; link the new nodes together to form the result. The nodes in b have the same values as the nodes in a, but they are distinct nodes</p>
<pre><code>   p := a
   b := nil
   while p /= nil do
       nn := newnode()
       *nn.value := *p.value
       *nn.next := nil
       *b.next := nn
       p := *p.next</code></pre>
<p>(It’s a little more complicated, you have to remember the beginning of b — using a header node is helpful.) Now if you modify one of the lists (a, b) the other list is not affected</p>
<h3 id="list-is-represented-as-nodes">List is represented as nodes</h3>

<p></p>
<h3 id="appending-to-a-list">Appending to a list</h3>

<p></p>
<ul>
<li>a = [1, 2, 3]</li>
<li>b = [4, 5, 6]</li>
<li>a.append(b)</li>
<li>A new node is created: call newnode()</li>
<li>The newnode has value=b and next=nil</li>
<li>The last node in a had next=nil; that is changed to point to the new node</li>
<li>Result: </li>
</ul>
<h3 id="extending-a-list">Extending a list</h3>

<p></p>
<ul>
<li>a = [1, 2, 3]</li>
<li>b = [4, 5, 6]</li>
<li>a.extend(b)<br />
</li>
<li>The last node in a had next=nil</li>
<li>That nil pointer was changed to point to b</li>
<li>Result: </li>
</ul>
<h4 id="the-operator">The + operator</h4>
<ul>
<li>You can concatenate two lists a and b with 
<ul>
<li>The + operator does not modify either a or b</li>
<li>It creates a new list, with copies of the nodes in a, followed by b</li>
<li><p>Since it doesn’t modify existing containers, you can use + on both</p></li>
<li>mutable containers, e.g. lists</li>
<li><p>immutable containers, e.g. string</p></li>
</ul></li>
</ul>
<h4 id="the-operator-1">The += operator</h4>
<h3 id="the-operator-2">The + operator}</h3>
<ul>
<li>You can concatenate two lists a and b with 
<ul>
<li>The += operator does not copy a, it  a by extending it</li>
<li>Since += modifies existing containers, you cannot use += on immutable containers, e.g. strings</li>
</ul></li>
</ul>
<h3 id="list-with-and">List with + and +=</h3>
<ul>
<li>You can write a + b where a and b are lists; if either is a list, both must be lists
<ul>
<li><p>You can write a += b where</p></li>
<li>a is a list</li>
<li><p>b is either a list or an iterator</p></li>
</ul></li>
</ul>
<h3 id="iterators">Iterators</h3>
<ul>
<li>A container class can have an 
<ul>
<li>There are built-in default iterators for lists and numbers</li>
<li><p>You can define your own class and iterator</p></li>
<li>You define a method called  which creates a new iterator and initializes it</li>
<li>An iterator provides a method called  and you can invoke this with </li>
<li><p>The implementation of next</p></li>
</ul></li>
</ul>
<h3 id="defining-an-iterator-for-even-numbers">Defining an iterator for even numbers</h3>
<pre><code>class EvensClass:
  def __iter__(self):
    self.state = 0
    return self

  def __next__(self):
    x = self.state
    self.state += 2
    return x

Evens = EvensClass()
EvenIterator = iter(Evens)</code></pre>
<h3 id="using-the-iterator">Using the iterator</h3>
<pre><code>for i in EvenIterator:
    print (i)
    if i &gt; 15:  # Try commenting this out: the iterator is unbounded
        break

print (&#39;The for loop has finished, now call next directly&#39;)
print(next(EvenIterator))</code></pre>
<h3 id="running-the-even-iterator">Running the even iterator</h3>
<pre><code>Defining iterator for even numbers
0
2
4
6
8
10
12
14
16
The for loop has finished, now call next directly
18</code></pre>
<h3 id="extending-a-list-with-an-iterator">Extending a list with an iterator</h3>
<p>You can use += to extend a list with an iterator ~~~~ a = [1, 2, 3, 4] a += range(20,25) print (‘a =’, a) ~~~~</p>
<p>But you can’t use + on a list and an iterator: ~~~~ a = [1, 2, 3, 4]b = [1, 2, 3, 4] # b = b + range(20,25) # This line gives syntax error ~~~~</p>
<h4 id="for-loops-1">for loops</h4>
<h3 id="for-loops-in-algol-and-descendants">for loops in Algol and descendants</h3>
<pre><code>sum := 0
for i := 0 to n-1 do sum := sum+i
print (sum)</code></pre>
<p>The translation needs 4 machine language instructions for the loop control</p>
<pre><code>           sum := 0
           i := 0
avacodo    if i&gt;= n then goto avacododone
           S
           i := i + 1
           goto avacado
avacododone
           print (sum)</code></pre>
<h3 id="for-loops-in-python">for loops in Python</h3>
<ul>
<li>A Python for loop traverses a sequence defined by an iterator</li>
<li>If the iterator terminates, so does the for loop</li>
<li>The iterator could also go on forever</li>
<li>The iterator could give a sequence of numbers, or it could traverse a list, or some other container</li>
<li>This is convenient but it hides what’s actually going on</li>
</ul>
<h4 id="revisiting-the-mysteries">Revisiting the mysteries}</h4>
<p>Focus on:</p>
<ul>
<li>What low level operations are being used: pointer assignment? copy?
<ul>
<li>Know when you have two pointers to the same node</li>
<li>Know when newnode has been called</li>
</ul></li>
</ul>
<pre><code>a = [1, 2]
b = a
a = a + [3, 4]
print (&#39;a = &#39;, a, &#39;  b = &#39;, b)</code></pre>
<p>Here, the results are final values: a = [1, 2, 3, 4] b = [1, 2]</p>
<pre><code>a = [1, 2]
b = a
a += [3, 4]
print (&#39;a = &#39;, a, &#39;  b = &#39;, b)</code></pre>
<p>Now the results are: a = [1, 2, 3, 4], b = [1, 2, 3, 4]</p>
<p>In the second example,  modified the structure of a. Since b points to the same node as a, this change also affects b.</p>
<h3 id="compilers">Compilers</h3>
<ul>
<li>We have been writing algorithms in high level language notation and then translating it manually to assembly language</li>
<li>A  is a software application that performs this translation automatically</li>
<li>A  is a precisely defined high level language</li>
<li>The compiler makes programming easier by allowing you to think about your algorithm more abstractly, without worrying about all the details of the machine</li>
</ul>
<h3 id="source-and-object">Source and object</h3>
<ul>
<li>The original high level language program is called the  — it’s what the programmer writes</li>
<li>The final machine language program which the compiler produces is called the  — it’s what the machine executes</li>
</ul>
<h3 id="compilation">{Compilation</h3>
<ul>
<li><p>A compiler translates statements in a high level language into assembly language</p></li>
<li><p>In developing an assembly language program, it’s best to begin by writing high level pseudo-code (this becomes a comment) and then translate it</p></li>
<li><p>This approach helps keep the program readable, and reduces the liklihood of getting confused</p></li>
<li><p>Each kind of high level statement corresponds to a standard pattern in assembly language. </p></li>
</ul>
<h3 id="how-a-compiler-works">How a compiler works</h3>
<ul>
<li>Your high level source program is just a character string — the computer cannot execute it directly</li>
<li>The compiler reads the source program, checks its syntax, and analyses its structure</li>
<li>Then it checks the types of all the variables and procedures</li>
<li>Most advanced compilers translate the program to an intermediate ``goto form’’, just as we are doing</li>
<li>The program is finally translated to assembly language: </li>
<li>The assembler translates the assembly language to machine language (the Sigma16 application contains an assembler)</li>
</ul>
<h3 id="major-tasks-in-compilation">Major tasks in compilation</h3>
<ul>
<li> — check the source program for correct syntax and work out the program structure (similar to ``diagramming sentences’’ in English grammar)</li>
<li><p> — work out the data type of each variable (integer, character, etc.) — then</p></li>
<li>Make sure the variables are used consistently</li>
<li><p>Generate the right instructions for that data type</p></li>
<li> — analyse the program to find opportunities to rearrange the object code to make it faster</li>
<li><p> — produce the actual machine instructions</p></li>
</ul>
<h3 id="parsing-1">Parsing</h3>
<ul>
<li>The  of a language is its set of grammar rules</li>
<li><p>If the source program contains a , the compiler will not understand what you mean</p></li>
<li>{if x<span class="math inline">&lt;</span>y then a = 1} — ok, can be translated</li>
<li><p> — syntax errors! what does it mean?</p></li>
<li><p>If there is a syntax error,  — that leads to unreliable software</p></li>
</ul>
<h3 id="types">Types</h3>
<ul>
<li>Type checking is one of the most important tasks the compiler performs</li>
<li><p>There are many data types supported by a computer</p></li>
<li>Binary integer</li>
<li>Two’s complement integer</li>
<li>Floating point</li>
<li>Character</li>
<li><p>Instruction</p></li>
<li></li>
<li><p>It’s essential to use the right instruction, according to the data type</p></li>
</ul>
<h3 id="integer-and-floating-point">Integer and floating point</h3>
<ul>
<li>An integer is a whole number: <span class="math inline">23</span>, <span class="math inline"> − 47</span></li>
<li>A floating point number may have a fraction and exponent: <span class="math inline">7.43 × 10<sup>28</sup></span></li>
<li>We have seen how an integer is represented: two’s complement</li>
<li>Floating point representation is different from two’s complement</li>
<li><p>Most computers have separate instructions for arithmetic on integer and floating point</p></li>
<li> R1,R2,R3 — integer addition</li>
<li><p> R1,R2,R3 — floating point addition</p></li>
<li><p> — you must use the right instruction according to the data type</p></li>
</ul>
<h3 id="typechecking">Typechecking</h3>
<ul>
<li><p>The compiler checks that each variable in the source program is used correctly</p>
<ul>
<li>If you add a number to a string, it’s a type error</li>
</ul></li>
<li><p>Then it generates the correct instructions for the type</p></li>
<li>For integer variables it uses </li>
<li>For floating point variables it uses </li>
<li><p></p></li>
<li><p>This eliminates one of the commonest kinds of error in software</p></li>
</ul>
<h3 id="write-programs-at-a-high-level">Write programs at a high level</h3>
<p>Every rule has some rare exceptions, but almost always these are good principles:</p>
<ul>
<li>Write conditionals using if-then or if-then-else</li>
<li><p>Write loops using the most appropriate construct</p></li>
<li>Often, a while loop is best</li>
<li><p>To traverse an array, a for loop is best</p></li>
<li>Avoid goto statements (and if your language has break statements, avoid those)</li>
<li><p>Use a straightforward style that’s easy to read</p></li>
</ul>
<p></p>
<h3 id="use-patterns-to-translate-to-low-level">Use patterns to translate to low level</h3>
<ul>
<li><p>Low level algorithm contains just</p>
<ul>
<li>Assignment statements</li>
<li>goto label</li>
<li>if b then goto label</li>
</ul></li>
<li><p>Each high level construct is translated to low level using a fixed pattern</p></li>
</ul>
<p></p>
<h3 id="translate-low-level-to-assembly-language">Translate low level to assembly language</h3>
<ul>
<li><p>Each low level statement should be a full line comment, followed by the instructions needed to implement that statement</p>
<ul>
<li> <span class="math inline"> ⇒ </span>\</li>
</ul>
<pre><code>; x := y + z
 load    R1,y[R0]    ; R1 := y
 load    R2,z[R0]    ; R2 := z
 add     R1,R1,R2    ; R1 := y + z
 store   R1,x[R0]    ; x := y + z</code></pre>
<ul>
<li> <span class="math inline"> ⇒ </span>\</li>
</ul>
<pre><code>; goto phase2
 jump    phase2[R0]  ; goto phase2</code></pre>
<ul>
<li> <span class="math inline"> ⇒ </span></li>
</ul>
<pre><code>; if x&lt;y then goto phase3
 load    R1,x[R0]    ; R1 := x
 load    R2,y[R0]    ; R2 := y
 cmp     R1,R2       ; compare x, y
 jumpge  phase3[R0]  ; if x&lt;y then goto phase3</code></pre></li>
</ul>
<h3 id="practical-programming-tip">Practical programming tip</h3>

<h2 id="architecture-1">Architecture</h2>
<h3 id="instructions-2">Instructions</h3>
<ul>
<li><p>You need to know what the basic instructions do and how to use them</p>
<ul>
<li>Memory and addresses: </li>
<li>Arithmetic: </li>
<li>Comparison: </li>
<li>Jumps: </li>
<li><p>System:  (just for halting, not for I/O)</p></li>
<li><p>Instruction representation</p></li>
<li>You should understand the </li>
<li><p>But you do not need to remember the details: the exam does not ask you to convert any instructions from assembly language to machine language</p></li>
</ul></li>
</ul>
<h3 id="addresses-and-data-structures">Addresses and data structures</h3>
<ul>
<li>Effective addresses: sum of displacement and register
<ul>
<li>Accessing an element of an array</li>
<li>Accessing an element of a record</li>
<li>Pointers: the (*p) and (&amp;x) operators</li>
<li>Linked list traversal</li>
</ul></li>
</ul>
<h4 id="compilation-patterns-3">Compilation patterns</h4>
<h3 id="high-and-low-level-programming-constructs">High and low level programming constructs</h3>
<ul>
<li><p>High level</p>
<ul>
<li><p>if then, if then else, case, while loops, for loops</p></li>
<li><p>Low level</p></li>
<li><p>assignment, goto, if then goto</p></li>
</ul></li>
</ul>
<h3 id="high-and-low-level-programming-constructs-1">High and low level programming constructs</h3>
<ul>
<li>The low level statements correspond to machine instructions
<ul>
<li><p>Assignment statement</p></li>
<li>Load the operands in the expression into registers</li>
<li>Do the arithmetic</li>
<li>Store the result into a variable in memory</li>
<li><p>You can also keep variables in registers over a larger block of code</p></li>
<li><p>goto label</p></li>
<li><p>jump label[R0]</p></li>
<li><p>if b then goto label</p></li>
<li>Evaluate the boolean expression, put it in a register</li>
<li><p>conditional jump: either jumpt or jumpf</p></li>
</ul></li>
</ul>
<h3 id="compliation-patterns">Compliation patterns</h3>
<ul>
<li>Systematic pattern for translating each high level construct into low level statements
<ul>
<li>Most high level constructs contain a Boolean expression</li>
<li>Translate this into goto and if-then-goto statements that cause the right blocks of instructions to be executed</li>
<li>Check that the translation is correct by hand executing with both values of the Boolean: True, False</li>
<li>Case statements use a jump table</li>
</ul></li>
</ul>
<h3 id="programming-fundamentals">Programming fundamentals</h3>
<h4 id="how-do-you-learn-programming">How do you learn programming</h4>
<ul>
<li>The approach to learning programming has changed over the years</li>
<li><p>First programming languages</p></li>
<li>Learn the statements and what they do</li>
<li><p>Statements are low level</p></li>
<li><p>Large scale software</p></li>
<li>Software becoming complex</li>
<li><p>goto considered harmful</p></li>
<li><p>Problem solving</p></li>
<li>Programming languages have complex statements, control structures and data structures</li>
<li>Teach ``problem solving’’</li>
<li><p>Use vague English and some examples to explain what the language constructs do</p></li>
</ul>
<h3 id="connections-with-other-subjects">Connections with other subjects</h3>
<p>Similar debates occur in many subjects</p>
<ul>
<li><p>Natural language</p>
<ul>
<li>A popular idea: learning grammar impedes creativity</li>
<li>Alternative view: knowing grammar  the ability to express your ideas</li>
</ul></li>
<li><p>Arts and crafts and music</p></li>
<li>Should you learn how to use the tools of the trade?</li>
<li><p>Or just pick up how to use them while ``expressing’’ yourself?</p></li>
</ul>
<h3 id="basic-list-operations-extend-and-append">Basic list operations: extend and append</h3>
<pre class="[commandchars=\\\{\}]"><code>a = [1, 2]
a.extend([3,4])
b = [1, 2]
b.append([3,4])

\redtext{a =  [1, 2, 3, 4]}
\redtext{b =  [1, 2, [3, 4]]}</code></pre>
<h3 id="effect-of-extend-and-append-on-data-structures">Effect of extend and append on data structures</h3>
<p></p>
<ul>
<li>Need to be able to read a ``box and arrow’’ diagram and work out what the lists are</li>
<li>a = [1, 2, 3, 4]</li>
<li>b = [1, 2, [3, 4]]</li>
</ul>
<p>%—————————————————————————–</p>
<h3 id="make-some-lists">Make some lists}</h3>
<p></p>
<p>%—————————————————————————–</p>
<h3 id="xx-changed-a-yy-changed-c.">XX changed a, YY changed c.\</h3>
<p>Which is append, which extend?}</p>
<p></p>
<p>%—————————————————————————– [fragile]</p>
<h3 id="list-manipulation-abc-foobarbaz">List manipulation: abc foobarbaz</h3>
<p>a = [1, 2] b = a c = [3, 4] a = a + c c.append(5)</p>

<ul>
<li></li>
<li>b still points to the nodes that comprised the  value of a</li>
<li>Here the lists are mutable, but you could also use a = a + c on  data (like strings) because the + operator , it just creates a  value</li>
</ul>
<h3 id="list-manipulation-abc-initial-values">List manipulation abc: initial values</h3>
<p></p>
<h3 id="list-manipulation-abc-after-and-append">List manipulation abc: after + and append</h3>
<p></p>
<h3 id="list-manipulation-def">List manipulation: def</h3>
<pre class="[commandchars=\\\{\}]"><code>d = [1, 2]
e = d
f = [3, 4]
d.append(f)
f.append(5)

\redtext{d =  [1, 2, [3, 4, 5]]}
\redtext{e =  [1, 2, [3, 4, 5]]
  \qquad\textrm{\emph{\textbf{Almost half answered [1,2]}}}}
\redtext{f =  [3, 4, 5]}</code></pre>
<ul>
<li>append modifies the data structure, it doesn’t produce a new list</li>
<li>After the appends, e and f still point to the same nodes they did before, but those nodes now point to lists with changed data</li>
<li>append can only be used on a mutable value such as a list, but not on an immutavle value such as a string</li>
</ul>
<h3 id="list-manipulation-def-initial-values">List manipulation: def initial values</h3>
<p></p>
<h3 id="list-manipulation-def-after-appends">List manipulation: def after appends</h3>
<p></p>
<h3 id="list-manipulation-ghi">List manipulation: ghi</h3>
<pre class="[commandchars=\\\{\}]"><code>g = [1, 2]
h = g
i = [3, 4]
g += i
i.append(5)

\redtext{g =  [1, 2, 3, 4]}
\redtext{h =  [1, 2, 3, 4]
  \qquad\textrm{\emph{\textbf{A majority answered [1,2]}}}}
\redtext{i =  [3, 4, 5]}</code></pre>
<ul>
<li>g += i modifies the representation of g (unlike g+i).</li>
<li>g (and h) still point to the same node, but the list is changed</li>
<li>The list that i points to is copied into the end of g, extending it, but these nodes are copies of the nodes in i</li>
<li>i.append(5) modifies the representation of i, but not g (or h)</li>
</ul>
<h3 id="list-manipulation-ghi-initial-values">List manipulation: ghi initial values</h3>
<p></p>
<h3 id="list-manipulation-ghi-after-and-append">List manipulation: ghi after += and append</h3>
<p></p>
<h3 id="for-loop">For loop</h3>
<pre class="[commandchars=\\\{\}]"><code>student_marks = [[9,7,8], [2,5,1], [7,4,3], [9,7,6]]
for student in student_marks:
    for mark in student:
        if mark &lt;= 5:
            break
print (&#39;mark = &#39;, mark)

\redtext{mark =  6}</code></pre>
<h3 id="data-structure-used-in-for-loop">Data structure used in for loop</h3>
<p></p>
<h3 id="a-flowchart">A flowchart</h3>
<p></p>
<h3 id="if-statement">If statement</h3>
<pre class="[commandchars=\\\{\}]"><code>a = [2,3,5,7,11]
b = 3
c = 2
result = 0

if a[b] == 5:
    result += 2
elif a[c+c] &gt; 3 or a[b-c] &lt; 3:
    result +=3
elif a[c-c] &gt;= 2 and a[b-b] &lt;= 2:
    result += 7
elif a[b+c] &gt;= 11:
    result += 11
print (&#39;If statement result = &#39;, result)

\redtext{If statement result =  3}</code></pre>
<h3 id="data-structure-for-the-if-statement">Data structure for the if statement</h3>
<p></p>
<h3 id="flowchart-for-the-if-statement">Flowchart for the if statement</h3>
<p></p>
<h3 id="while-loop">While loop</h3>


<ul>
<li>Many got this wrong, and there were several different errors</li>
<li>Some treated <span class="math inline"><em>a</em> ≥ <em>b</em></span> as if it meant <span class="math inline"><em>a</em> &gt; <em>b</em></span></li>
<li>Some thought the while loop terminates as soon as <span class="math inline"><em>a</em> ≥ <em>b</em></span> becomes true </li>
</ul>
<h3 id="question-continue-statement">Question: Continue statement</h3>
<pre class="[commandchars=\\\{\}]"><code>i = 1
j = 5
while i &lt; j:
    i = i + 1
    if i == 3:
        \redtext{continue}
    print (&#39;i = &#39;, i)
\redtext{i =  2}
\redtext{i =  4}
\redtext{i =  5}</code></pre>
<p>} </p>
<ul>
<li>Answers were all over the place</li>
<li>That’s ok </li>
<li>The danger is when you aren’t aware</li>
<li>Continue is dangerous because it’s a goto statement that doesn’t say explicitly where to go — you need to know how to figure it out</li>
<li>Continue should be used rarely if at all, just like goto</li>
</ul>
<h3 id="question-break-statement">Question: Break statement</h3>
<pre class="[commandchars=\\\{\}]"><code>i = 1
j = 5
while i &lt; j:
    i = i + 1
    if i == 3:
        \redtext{break}
    print (&#39;i = &#39;, i)

\redtext{i =  2}</code></pre>
<p>} </p>
<ul>
<li>Similar to continue: lots of answers, mostly wrong</li>
<li>Again, that’s ok </li>
<li>Break is dangerous because it’s a goto statement that doesn’t say explicitly where to go — you need to know how to figure it out</li>
<li>Break should be used rarely if at all, just like goto</li>
</ul>
<h3 id="a-note-about-the-break-statement">A note about the break statement</h3>
<ul>
<li>In Python, you can only break out of the innermost loop that contains the break
<ul>
<li>If you are in several nested loops, and you want to break out of several of them, </li>
<li>Break and continue should be used rarely if at all</li>
<li>Break and continue are just goto statements, spelled differently</li>
<li>The disadvantages of goto statements apply to break and continue, only more so</li>
<li>(Break is commonly used in the C language, because the switch (case) statement in C doesn’t work the way you normally want.)</li>
</ul></li>
</ul>
<h3 id="results">Results</h3>
<ul>
<li>Some of the primitive operations on lists are widely misunderstood
<ul>
<li><p>There are some misconceptions on what operators + and += mean when applied to lists</p></li>
<li><p>Textbooks, web pages, and Stack Overflow also get this wrong quite often</p></li>
<li>Some misunderstandings about how nested conditionals work</li>
<li>The break and continue statements are goto statements where you don’t say  to go, and this leads to confusion</li>
<li><p></p></li>
</ul></li>
</ul>
<h3 id="example-writevalchar">Example: WriteValChar</h3>
<h3 id="a-simple-procedure-writevalchar">A simple procedure: WriteValChar</h3>
<ul>
<li>The procedure takes an argument—a character—and prints it.</li>
<li>To use the procedure: Load a character into R1</li>
<li>This is a word, and it should be a valid printing Unicode character</li>
<li>Call the WriteValChar procedure, and it will print this character</li>
</ul>
<h3 id="calling-writevalchar">Calling WriteValChar</h3>
<ul>
<li>Suppose R5 contains p, a pointer to a node</li>
<li>We want to print the value in that node</li>
<li>We are in a procedure where the stack frame has size 1 (the main program)</li>
</ul>
<pre><code>   load   R1,0[R5]              ; R1 := (*p).value (to be written)
   store  R14,1[R14]            ; point to current frame
   lea    R14,1[R14]            ; push stack frame
   jal    R13,WriteValChar[R0]  ; write character</code></pre>
<ul>
<li>If the call is made from a procedure with 23 words in the stack frame, then the store and lea instructions would use 23[R14]</li>
</ul>
<h3 id="definition-of-writevalchar-1">Definition of WriteValChar (1)</h3>
<pre><code>WriteValChar
; Write a character in R1
; Structure of stack frame
;    6[R14]  origin of next frame
;    5[R14]  local variable c
;    4[R14]  save R3
;    3[R14]  save R2
;    2[R14]  save R1
;    1[R14]  return address
;    0[R14]  pointer to previous stack frame

; Create stack frame
    store   R13,1[R14]           ; save return address
    store   R1,2[R14]            ; save R1
    store   R2,3[R14]            ; save R2
    store   R3,4[R14]            ; save R3</code></pre>
<p>}</p>
<h3 id="definition-of-writevalchar-2">Definition of WriteValChar (2)</h3>
<pre><code>    store   R1,5[R14]        ; local c := R1 = char to write
    lea     R1,2[R0]         ; trap write code
    lea     R2,5[R14]        ; address of character to write
    lea     R3,1[R0]         ; one char
    trap    R1,R2,R3         ; trap write

    load    R1,2[R14]        ; restore R1
    load    R2,3[R14]        ; restore R2
    load    R3,4[R14]        ; restore R3
    load    R13,1[R14]       ; restore return address
    load    R14,0[R14]       ; pop stack frame
    jump    0[R13]           ; return</code></pre>
<p>}</p>
<h3 id="static-variables-in-a-data-segment">Static variables in a data segment</h3>
<ul>
<li>The variables are not placed in memory right after the instructions</li>
<li>The program makes a request to the operating system to allocate a block of memory for data (the static data segment)</li>
<li>A register is dedicated to point to the static data segment</li>
<li>Variables are accessed using the static data segment register</li>
</ul>
<h3 id="implementing-static-data-segment">Implementing static data segment</h3>
<pre><code>     ... set up registers to request a
          data block of n words...

     trap  R1,R2,R3
     ... R3 is set to the address of the data block
     add   R12,R0,R3    ; R12 = address of static data segment

   ...
     load  R2,n[R12]    ; R2 := n (access static variable)

     segment            ; subsequent labels will access segment
n    data
x    data</code></pre>
<p>}</p>
<h3 id="practical-tip---editing">Practical tip - editing</h3>
<ul>
<li>Recommend that you use Notepad to edit program; copy and paste it into Sigma16 editor pane</li>
<li>The assembly language program should contain ASCII characters (the characters on your keyboard)</li>
<li>Don’t edit your program using Word (it will use lots of non-ASCII characters)</li>
<li>If you click Run to run a program at full speed, you need to click Refresh (otherwise the memory display won’t be correct). Remember: Run, then Refresh.</li>
<li>But it’s recommended that you execute the program by clicking Step repeatedly, and each instruction check that it did what you intend.</li>
</ul>
<h2 id="linking">Linking}</h2>
<h3 id="subroutines">Subroutines</h3>
<p>There are many programming language variations</p>
<ul>
<li>Reentrant code</li>
<li>Recursion</li>
<li>Coroutines</li>
</ul>
<p>Architecture support</p>
<ul>
<li>Ability to jump to a location and save return address</li>
<li>Ability to save all the state of caller</li>
<li>Support for efficient stack access</li>
</ul>
<h3 id="calling-conventions">Calling conventions</h3>
<ul>
<li>Software comes from many authors, written in many languages</li>
<li>To be able to work, standard calling conventions are needed</li>
<li>These are specified by the OS, and used by OS libraries</li>
</ul>
<h3 id="linking-1">Linking</h3>
<ul>
<li>Large programs are written in many modules, compiled separately</li>
<li>They need to communicate via : names of subroutines, names of global variables.</li>
<li>Compiling a source module (in any language) produces an object module (in a fixed notation specified by OS)</li>
<li>Object module contains machine code, definitions of exported global names, and relocation information</li>
<li> (part of OS) combines multiple object modules, replaces global names by their values, and (maybe) relocates code</li>
</ul>
<h3 id="interrupts-an-unrequested-jump">Interrupts — an unrequested jump</h3>
<ul>
<li>A jump (to the operating system) initiated by an event other than a jump instruction</li>
<li>Provide a mechanism for a program to request OS services</li>
<li>Prevent user program from executing prohibited instructions</li>
<li>Foundation for implementation by OS of concurrent processes and threads</li>
</ul>
<h3 id="implementing-interrupts">Implementing interrupts</h3>
<ul>
<li>The control algorithm implements interrupts</li>
<li><p>At the beginning of the instruction fetch/execute loop, the control checks the interrupt request (an input to the processor)</p></li>
<li>If 0 (no interrupt request) the control algorithm executes the next instruction normally</li>
<li><p>If 1, the control algorithm saves the PC and updates the PC with the address of the interrupt handler. The next instruction to execute will then be the beginning of the interrupt handler.</p></li>
</ul>
<h3 id="basic-interrupt-control">Basic interrupt control</h3>
<p>Control algorithm without interrupts:</p>
<pre><code>repeat forever
   ir := mem[pc], pc++;
   case ir_op of
     0 -&gt; -- add instruction
     ...</code></pre>
<p>}</p>
<p>With interrupt_request signal</p>
<pre><code>repeat forever
   case interrupt_request of
     1 -&gt;
       savepc := pc, pc := handler_address
     0 -&gt; -- normal instruction execution follows...
        ir := mem[pc], pc++;
        case ir_op of
           0 -&gt; -- add instruction
     ...</code></pre>
<p>}</p>
<h3 id="saving-the-pc">Saving the PC</h3>
<ul>
<li>A principle of interrupts is that </li>
<li>The essence of an interrupt is to assign a new value to the PC</li>
<li>Therefore the PC must be saved before its old value is destroyed</li>
<li>The hardware has to do this! It is absolutely impossible to do it in software</li>
</ul>
<h3 id="where-to-save-the-pc">Where to save the PC?</h3>
<p>There are several possibilities, many of which have been tried in real computers</p>
<ul>
<li>Have a special register whose sole purpose is to save the PC during an interrupt. The interrupt handler needs to copy that register someplace more permanent before another interrupt can occur!</li>
<li>Store the PC into memory, at a fixed address. Again, the interrupt handler would need to copy it to a permanent place before another interrupt.</li>
<li>Push the PC into a stack in memory. This requires either a fixed location for the stack, or a register pointing to the stack. What happens if there is a stack overflow?</li>
</ul>
<h3 id="saving-state-2">Saving state</h3>
<ul>
<li>All the registers that hold state belonging to the user program need to be saved.</li>
<li><p>Two approaches to this:</p></li>
<li>Require the interrupt handler to do it (i.e. use software instructions to save the state). Flexible, requires instructions that can access all of the state.</li>
<li><p>Save all state in the control algorithm (OS doesn’t need to do it). Simple, reliable.</p></li>
</ul>
<h3 id="disabling-interrupts">Disabling interrupts</h3>
<ul>
<li>If any state-saving is done by software, the interrupt handler is  for a number of clock cycles while it is executing the instructions to save state.</li>
<li>If another interrupt occurs while the handler is vulnerable, the state of the first interrupted process will be lost. At best the process has been destroyed; if the process is an OS service, the entire system may crash.</li>
<li>To prevent this, interrupts are  while the handler is vulnerable.</li>
<li>The datapath contains a flip flop , which is normally 0.</li>
<li>The control algorithm performs an interrupt if </li>
<li>When an interrupt occurs, the control sets enable to 0</li>
<li>There is an instruction that sets enable to 1</li>
</ul>
<h3 id="missing-interrupts">Missing interrupts</h3>
<ul>
<li>If a new interrupt request is made while interrupts are disabled, the interrupt simply has to wait</li>
<li><p>Some external events are  — there is an absolute deadline by which they must be processed</p></li>
<li>In some systems, a disk generates an interrupt request when the data is about to pass under the read head. If an interrupt is delayed too long, the disk must rotate fully before the data can be accessed</li>
<li><p>The time of day clock is implemented by counting timer interrupts; if one of these is missed, the clock will run slow</p></li>
<li>It is the responsibility of the interrupt handler (OS) to save state quickly and enable interrupts</li>
<li><p>Some operating systems (e.g. Linux) organise interrupt handlers in two parts</p></li>
<li>A short part that saves state, and saves an indication in memory of what work needs to be done</li>
<li><p>A longer part that does the actual work, but this can be delayed until other interrupts are processed</p></li>
</ul>
<h3 id="architecture-must-support-os">Architecture must support OS</h3>
<h3 id="some-historical-examples">Some historical examples</h3>
<p>As computers developed, some architectures had to be abandoned because they didn’t support new ideas in programming and operating systems.</p>
<ul>
<li>\ Some early machines needed self-modifying code to iterate over arrays. When the disadvantages were recognised, and index registers with effective address calculation were invented, those machines became obsolete.</li>
<li>\ Early machines had a library of I/O routines, rather than a full operating system, and lacked the ability to save  state on an interrupt. This made an OS scheduler impossible.</li>
<li>\ Memory was expensive until the 1970s, and machines used short addresses to keep code tight. The PDP 10 computer had 18-bit addresses, and went from dominant to dead when memory hardware grew.</li>
</ul>
<h3 id="more-recent-examples">More recent examples</h3>
<ul>
<li> Virtual memory is implemented partly in hardware, and partly in software. The relevant parts of the architecture and operating system must be designed together.</li>
<li> To be efficient, virtual memory needs information about usage patterns (``least recently used’’, etc.). This information is needed by the operating system but must be gatherd by the hardware.</li>
<li> It is theoretically possible to implement mutex in software, but to be efficient it needs hardware support (test and set, etc.).</li>
<li> Virtual machines require the ability to emulate key parts of code while running other parts at full speed, without losing control. This places a number of constraints on the architecture.</li>
</ul>
<h3 id="speed-of-cache-memory">Speed of cache memory</h3>
<ul>
<li>Cache is a small fast memory that mirrors the most commonly used words of the primary memory.
<ul>
<li>Cache may run at full processor speed.</li>
<li>The datapath and control need to determine, for each memory access, whether the effective address refers to a word in the cache. If so, the access is quick and the primary memory is not used.</li>
<li>The test for cache residency must be ! It happens on every memory access (more than once per instruction, on average).</li>
<li>Extra registers are needed to give fast access to information about which addresses are in the cache.</li>
</ul></li>
</ul>
<h3 id="whats-in-the-cache">What’s in the cache</h3>
<ul>
<li>Since the cache contains recently used data, it does not contain a sequence of words at consecutive locations</li>
<li><p>Therefore each location in the cache contains two parts:</p></li>
<li>A word of data</li>
<li><p>A tag: the actual address of this data in the primary memory</p></li>
<li><p>This enables the machine to identify whether an arbitrary address refers to data that’s already in the cache, and if so, where it is</p></li>
</ul>
<h3 id="cache-lines">Cache lines</h3>
<ul>
<li><p>In practice, we don’t just keep individual memory locations (bytes or words) in the cache</p></li>
<li>The cache is organised by ``large words’’ called cache lines; e.g. 16 bytes at an address which is a multiple of 16.</li>
<li>A memory access to an address <span class="math inline"><em>a</em>, <em>a</em> + 1, …, <em>a</em> + 15</span> will actually refer to the same cache line (where <span class="math inline"><em>a</em></span> is a multiple of 16).</li>
<li><p>Size of a cache line varies: making it bigger increases probability of cache hit but also increases penalty of a cache hit</p></li>
</ul>
<h3 id="searching-the-cache">Searching the cache</h3>
<ul>
<li>The cache has to be searched on each memory access, so this search must be fast!</li>
<li>The quickest approach:  requires each address to go into a specific cache entry.</li>
<li><p>The most general approach: </p></li>
<li>Each cache line has a dedicated comparitor that checks the memory address against the tag for this line</li>
<li><p>The comparisons are done by hardware, in parallel</p></li>
<li><p>There are also various compromises which require less hardware but offer less improvement in performance</p></li>
</ul>
<h3 id="fully-associative-cache">Fully associative cache</h3>
<ul>
<li><p>Direct mapping is inflexible: it can cause a sequence of memory operations to induce a sequence of cache misses (similar to thrashing in virtual memory).</p></li>
<li><p>An alternative approach is to allow a word of memory to be placed in any different cache location—this is called  cache.</p></li>
<li><p>The hardware must search the tags of the set of possible cache locations corresponding to a memory location.</p></li>
</ul>
<h3 id="associative-memory">Associative memory</h3>
<p>Also called content-addressable memory.</p>
<ul>
<li><p>Each word contains several fields</p></li>
<li><p>Data is not accessed by its address</p></li>
<li><p>To fetch data, a field value is specified, and the memory returns the rest of the word that matches this field</p></li>
<li><p>If it is possible for several matches to occur, the memory must resolve this.</p></li>
</ul>
<h3 id="searching-in-associative-memory">Searching in associative memory</h3>
<ul>
<li><p>Each location has some logic as well as state</p></li>
<li><p>On a memory access, the specified field value is broadcast</p></li>
<li><p>In parallel, each location compares the broadcast field with its local field value, resulting in a Boolean </p></li>
<li><p>A tree of or-gates can determine in logarithmic time whether a match exists.</p></li>
<li><p>If there are multiple matches, a tree circuit can also determine a unique responder in logarithmic time.</p></li>
</ul>
<h3 id="a-compromise-set-associative-cache">A compromise: Set associative cache</h3>
<ul>
<li>Instead of allowing a block of memory to go into any location of the cache, restrict it to just a subset of the cache locations.</li>
<li>You can think of direct mapped as a special case where the subset has one element, and fully associative as a special case where the subset is the entire set.</li>
<li>This reduces the number of comparitors needed to check tags, and the size of the tree circuit to resolve matches.</li>
<li>Many real machines use set associative cache.</li>
</ul>
<h3 id="reducing-cache-misses">Reducing cache misses</h3>
<ul>
<li>Increasing the cache size helps, but the fixed direct mapping can cause a sequence of memory operations to induce a sequence of cache misses (similar to thrashing in virtual memory).</li>
<li>An alternative approach is to allow a word of memory to be placed in a set of different cache locations.</li>
<li>The hardware must then do a search through the set of possible cache locations corresponding to a memory location.</li>
<li>This requires searching the tags. What matters is not the location of the cache entry, but the association between the tag and the value.</li>
</ul>
<h3 id="processor-after-load-x">Processor: after load x</h3>
<p></p>
<h3 id="processor-after-load-y">Processor: after load y</h3>
<p></p>
<h3 id="processor-after-add">Processor: after add</h3>
<p></p>
<h3 id="processor-after-store">Processor: after store</h3>
<p></p>
<h3 id="processor-after-termination">Processor: after termination</h3>
<p></p>
<h2 id="data-types">Data types</h2>
<ul>
<li>A word of memory contains a string of bits</li>
<li>The hardware has no idea what data type this string of bits has</li>
<li>If you execute an instruction that treats the bits as an integer, then it’s an integer </li>
<li>The same holds for all other data types</li>
<li>If the machine executes a word (i.e. the pc register points to that word), it will be interpreted as an instruction</li>
<li>It is the responsibility of the programmer to use each word consistently</li>
<li>Programming languages and compilers help by associating a  with every data value</li>
<li>A common error: accidentally executing a variable (e.g. jumping into the area of memory where your variables reside)</li>
</ul>
<h3 id="many-kinds-of-procedure">Many kinds of procedure</h3>
<ul>
<li><p>Many related programming constructs:</p>
<ul>
<li>Procedures</li>
<li>Subroutines</li>
<li>Functions</li>
<li>Coroutines</li>
<li>Methods</li>
</ul></li>
<li>They are , perform some computation, and  to the caller.</li>
<li><p>Many variations: how parameters are passed, how variables are allocated, whether there are restrictions on usage</p></li>
</ul>
<h3 id="about-those-jumps-call-and-return">About those jumps (call and return)</h3>
<ul>
<li><p>There is a minor issue that often isn’t worth worrying about:</p>
<ul>
<li>It costs an extra jump to call, and an extra jump to return</li>
<li>These jumps take a (very small) amount of execution time</li>
</ul></li>
<li>If a procedure is very small, it may be worthwhile plug in in its code wherever it’s called — this is a compiler optimisation called </li>
<li><p>But usually the space you save by having just one copy of the procedure’s instructions in memory is more important than the time required for the call and return</p></li>
</ul>
<h3 id="characters">Characters</h3>
<ul>
<li>‘a’, ‘b’, and so on</li>
<li>Some computers represent characters using ASCII — an 8-bit code for each character</li>
<li><p>Sigma16 uses Unicode</p></li>
<li>Each character has a 16-bit code</li>
<li>Each possible 16-bit word corresponds to some character</li>
<li><p>Lots of characters are available: "u  "o <span class="math inline"><em>α</em></span></p></li>
<li><p>There are tables giving the codes for all the characters</p></li>
</ul>
<h3 id="calling-conventions-1">Calling conventions</h3>
<ul>
<li>The machine architecture doesn’t force any particular way to pass arguments to a function, or to pass the result back to the caller</li>
<li>The program just has to do this in a consistent way</li>
<li>It’s good practice to establish  — standard ways for functions and procedures to operate</li>
</ul>
<h3 id="programming-tips-1">Programming tips</h3>
<h3 id="how-to-program-efficiently">How to program efficiently</h3>
<p>If you don’t want to spend forever getting your program working, but prefer to go out for a pizza with your friends, here’s how:</p>

<h3 id="how-to-waste-time">How to waste time</h3>
<p>If you want to drag out a program, so it takes a  to get it working:</p>

<p>A tip! Write the comments before the code!</p>
<h2 id="using-the-instruction-set">Using the instruction set</h2>
<ul>
<li>You need to know what each instruction does, and how to use it</li>
<li>A table of the instruction set helps to get an overview</li>
</ul>
<h3 id="part-of-the-instruction-set">Part of the instruction set</h3>
<p>Soon we will see some changes in this table, as well as some new instructions.</p>
<pre><code>load   R1,x[R0]     ; R1 := x
lea    R1,123[R0]   ; R1 := 123
store  R1,x[R0]     ; x := R1
jumpf  R1,x[R0]     ; if R1=0 then goto x
jumpt  R1,x[R0]     ; if R1/=0 then goto x

add    R1,R2,R3     ; R1 := R2+R3
sub    R1,R2,R3     ; R1 := R2-R3
mul    R1,R2,R3     ; R1 := R2*R3
cmplt  R1,R2,R3     ; R1 := R2&lt;R3
cmpeq  R1,R2,R3     ; R1 := R2=R3
cmpgt  R1,R2,R3     ; R1 := R2&gt;R3</code></pre>
<h3 id="closed-source-open-source-free">Closed source, open source, free</h3>
<ul>
<li> — the software is proprietary, the company doesn’t publish it (you can get the machine language code but not the high level language code)</li>
<li> — the source code is published, although the owner has control</li>
<li> — You can make a copy of the code and modify it</li>
<li><p>Much controversy!</p></li>
<li>One view: a large company can ensure high quality, and needs to ensure it gets paid for its work</li>
<li><p>Another view: ``with many eyes studying code, every bug is visible’’ — open source and free software can be more reliable</p></li>
</ul>
<h2 id="operating-systems">Operating Systems</h2>
<ul>
<li>An operating system provides </li>
<li><p>An OS is organised in layers, like an onion</p></li>
<li>Kernel: essential services without which no program can execute (e.g. calling conventions, memory protection, processes)</li>
<li>Intermediate level: networking (e.g. TCP/IP)</li>
<li><p>Higher level: optional services for convenience (e.g. graphical user interfaces, browsers, media players)</p></li>
</ul>
<h3 id="essential-services">Essential services</h3>
<ul>
<li><p>Procedures</p>
<ul>
<li>Standard rules for which register to use as , which register to use for </li>
<li>These conventions are sometimes defined by the Operating System, sometimes by the compiler</li>
</ul></li>
<li><p>Preparing and starting programs</p></li>
<li> separate modules into an executable program</li>
<li><p> a program</p></li>
<li><p>Services for a running program</p></li>
<li>Input/Output and memory allocation</li>
<li>Concurrency</li>
<li><p>Virtual memory</p></li>
</ul>
<h3 id="requests-to-the-os">Requests to the OS</h3>
<ul>
<li>Many operations cannot be performed directly by a user program.</li>
<li>The program requests the operating system to perform them</li>
<li>An OS request is performed by executing a  instruction, such as </li>
<li>The  is a number, placed in R1, and  (if any) are in R2, R3</li>
<li>The specific codes used to make a request are defined by the operating system, not by the hardware</li>
<li>This is a major reason why compiled programs run only on one operating system</li>
</ul>
<h3 id="the-trap-instruction">The trap instruction</h3>
<ul>
<li>trap R1,R2,R3</li>
<li>It doesn’t matter which registers you use; all that matters is the content of the first, second, and third operand</li>
<li>R1 contains a code indicating which request</li>
<li>R2, R3 contain additional information depending on the type of request</li>
</ul>
<h3 id="trap-is-like-jump-but-different">trap is like jump, but different</h3>
<ul>
<li> causes the machine to jump to the operating system, so it’s similar to </li>
<li>The OS has a way to jump back to the user program later, so trap is analogous to </li>
<li><p>But trap is different from jump/jal:</p></li>
<li>A trap does not specify the address to jump to: this is defined by the hardware</li>
<li><p>A trap also sets the computer into ; this is needed for system security (we’ll discuss it later)</p></li>
</ul>
<h3 id="typical-os-requests-1">Typical OS requests</h3>
<ul>
<li>Terminate execution of the program</li>
<li>Read from a file</li>
<li>Write to a file</li>
<li>Allocate a block of memory</li>
</ul>
<h3 id="memory-allocation">Memory allocation</h3>
<ul>
<li>The operating system maintains a map of the entire memory, organised as a set of blocks</li>
<li>A running program often needs to allocate a block of memory dynamically</li>
<li>When a program requests memory, it asks for a  of block that it needs, and the operating system returns with the  of a block</li>
</ul>
<h3 id="adding-a-character-to-a-string">Adding a character to a string</h3>
<ul>
<li>Use a variable <span class="math inline"><em>k</em></span> that gives the current length of the string </li>
<li><span class="math inline"><em>k</em></span> is also the index into  where we can insert another character</li>
</ul>
<pre><code>; out[k] = &#39;*&#39;
     load   R8,k[R0]          ; R8 = k
     load   R10,star[R0]      ; R10 = &#39;*&#39;
     store  R10,out[R8]       ; out[k] = &#39;*&#39;
; k = k + 1
     lea    R4,1[R0]          ; R4 = 1
     add    R8,R8,R4          ; R8 = k + 1
     store  R8,k[R0]          ; k = k + 1

star data   $002a             ; code for &#39;*&#39;</code></pre>
<h3 id="memory-allocation-1">Memory allocation</h3>
<ul>
<li>The operating system maintains a map of the entire memory, organised as a set of blocks</li>
<li>A running program often needs to allocate a block of memory dynamically</li>
<li>When a program requests memory, it asks for a  of block that it needs, and the operating system returns with the  of a block</li>
</ul>
<h3 id="part-of-the-instruction-set-1">Part of the instruction set</h3>
<pre><code>load   R1,x[R2]   R1 := mem[x+R2]
lea    R1,x[R2]   R1 := x+R2
store  R1,x[R2]   mem[x+R2] := R1
jump   x[R2]      pc := x+R2
jumpf  R1,x[R2]   if R1=0 then pc := x+R2
jumpt  R1,x[R2]   if R1/=0 then pc := x+R2
jal    R1,x[R2]   R1 := pc, pc := x+R2

add    R1,R2,R3   R1 := R2+R3
sub    R1,R2,R3   R1 := R2-R3
cmplt  R1,R2,R3   R1 := R2&lt;R3
cmpeq  R1,R2,R3   R1 := R2=R3
cmpgt  R1,R2,R3   R1 := R2&gt;R3</code></pre>
<h2 id="pointers-1">Pointers</h2>
<ul>
<li>We often need a variable that contains the </li>
<li>This is called a </li>
<li><p>Example: to write a string with trap R1,R2,R3:</p></li>
<li>R1 contains the code indicating a write request</li>
<li>R2 contains a  (address of the first character in the string)</li>
<li><p>R3 contains the length of the string</p></li>
</ul>
<h3 id="three-key-instructions-lea-load-store">Three key instructions: lea, load, store</h3>
<p>These are the most important instructions dealing with memory and memory addresses</p>
<ul>
<li><p>lea (load effective address) calculates the effective address and loads that into the destination register</p>
<ul>
<li></li>
</ul></li>
<li><p>load calulates the effective address, fetches the word from memory at that address, and loads it into the destination register</p></li>
<li></li>
<li><p>store is the opposite of load: copies a word from the destination register into memory at the effective address</p></li>
<li></li>
</ul>
<h3 id="applications-of-the-instructions">Applications of the instructions</h3>
<ul>
<li><p>load and store</p>
<ul>
<li>Use load to copy a variable (either ordinary variable x or array element a[i]) from memory to register</li>
<li>Use store to copy from register to memory</li>
</ul></li>
<li><p>lea</p></li>
<li>Use it to get the  in a register</li>
<li>Example: to write a string, you need to (1) put the code for write in R1, (2) put the address of the string in R2 , (3) put the length of the string in R3, then trap R1,R2,R3</li>
<li>Use it to put a constant into a register: </li>
<li><p>Use it to add a constant to a register: </p></li>
</ul>
<h3 id="a-computer-is-a-digital-circuit">A computer is a digital circuit!}</h3>
<ul>
<li>It isn’t a magic box with a little man inside!</li>
<li>A computer is a  constructed from  and </li>
</ul>
<h3 id="philosophical-question-finding-the-ultimate-cause">Philosophical question: finding the ultimate cause}</h3>
<ul>
<li><p>A computer does lots of different things</p>
<ul>
<li>Arithmetic</li>
<li>Sequences of calculations</li>
<li>Decisions</li>
<li>Goto</li>
</ul></li>
<li>Yet it’s just a digital circuit made of logic gates and flip flops, which </li>
<li><p>The interesting behaviours  from the way the basic components are connected</p></li>
</ul>
<h3 id="some-examples-of-emergent-ultimate-causes">Some examples of emergent ``ultimate causes’’}</h3>
<ul>
<li><p>Arithmetic</p>
<ul>
<li>Full adder uses logic gates to calculate sum and carry</li>
<li>Ripple carry adder transfers carry bits to get binary sum</li>
</ul></li>
<li><p>Sequences of calculations</p></li>
<li><p>The pc register points to next instruction, and is incremented as each instruction is executed</p></li>
<li><p>Decisions</p></li>
<li>If statements are translated to </li>
<li><p>Control algorithm uses a multiplexer to take different actions based on cond</p></li>
<li><p>Goto</p></li>
<li><p>Goto is just loading the pc with the effective address</p></li>
</ul>
<h3 id="summary-1">Summary</h3>
<ul>
<li>Register circuits hold the state of a processor</li>
<li>Combinational logic circuits perform calculations</li>
<li>Multiplexers allow control over where data moves</li>
<li>A control algorithm sets the multiplexers, determining what register changes will occur at the next clock tick</li>
<li>Everything (address calculation, jumps, etc.) is implemented by loading the right value into a register</li>
<li>The control algorithm is an  for the instruction set</li>
</ul>
<h4 id="booleans">Booleans</h4>
<ul>
<li>A Boolean is a data type with two values:  and </li>
<li>A Boolean expression has the value True or False: </li>
<li>Conditional control structures use a Boolean to decide what to do</li>
<li><p>In assembly language, we will</p></li>
<li>Calculate a Boolean value in a register</li>
<li><p>Use it to control a ``conditional goto’’ (called a )</p></li>
</ul>
<h3 id="booleans-in-machine-language">Booleans in machine language</h3>
<ul>
<li>A Boolean is represented as a word (16 bits)</li>
<li>The canonical representation is False=0 and True=1 (these are 16 bit integers).</li>
<li>Comparison instructions produce Booleans in the canonical representation</li>
<li>Conditional jumps treat , and </li>
</ul>
<h3 id="example-program-findmax">Example: program findmax}</h3>
<p>The program searches an array of natural numbers for the maximal element, and the loop terminates when a negative element is encountered.</p>
<pre><code>{-
Register usage:
  R0 = constant 0
  R1 = maximum value found so far
  R2 = loop index i
  R3 = constant -1, indicates end of list
  R4 = x[i]
  R5 = constant 1, for incrementing i
  R6 = temp Bool value
-}</code></pre>
<p>}</p>
<p>%———————————————————————–</p>
<p>{ ~~~~ load R1,x[R0] ; max := x[0] lea R2,1[R0] ; i := 1 lea R3,-1[R0] ; R3 := -1 lea R5,1[R0] ; R5 := 1 (for counter) loop load R4,x[R2] ; R4 := x[i] cmpgt R6,R4,R3 ; R6 := (x[i] &gt;= -1) jumpf R6,done ; goto done if not cmpgt R6,R4,R1 ; R6 := (x[i] &gt; max) jumpf R6,skip[R0] ; goto skip if not add R1,R4,R0 ; max := x[i] skip add R2,R2,R5 ; i := i+1 jump loop[R0] ; goto loop done store R1,max[R0] ; save max trap R0,R0,R0 ; terminate execution</p>
<p>x data 2 data 42 data 224 data 19 data 4 data -1 max data $0000 ; 0 ~~~~ }</p>
<h3 id="trap-1">Trap</h3>
<ul>
<li>The trap instruction has three register operands (it’s an RRR instruction)
<ul>
<li>Trap R2,R3,R5</li>
<li>It requests the operating system to perform a service, such as input/output</li>
<li>The first register contains a  that tells the operating system what the program is requesting; the other registers may contain further data</li>
<li>A trap code of 0 terminates the program</li>
<li>You can stop a program by executing trap R0,R0,R0</li>
</ul></li>
</ul>
<h2 id="addresses">Addresses</h2>
<ul>
<li>An address is specified in two parts: an  and a .</li>
<li>The constant is a 16 bit integer which constitutes a second word of the instruction.</li>
<li><p>The machine calculates an , which is the sum of the constant and the index register</p></li>
<li>lea R1,const[R2]  R1 := const+R2</li>
<li>load R1,const[R2] R1 := mem[const+R2]</li>
<li><p>store R1,const[R2] mem[const+R2] := R1</p></li>
</ul>
<p>The lea instruction is ``load effective address’’; the load and store instructions use to effective address to fetch/update a word in memory</p>
<h3 id="accessing-data">Accessing data</h3>
<p>The index-constant scheme offers several ways to access data , which simplifies the hardware:</p>
<ul>
<li> gives the address of a scalar <span class="math inline"><em>x</em></span> (because R0 contains 0)</li>
<li> uses a variable address in the register</li>
<li><p> gives the element of the array, <span class="math inline"><em>a</em><sub><em>i</em></sub></span> where <span class="math inline"><em>i</em></span> is the index in R2.</p></li>
<li><p>Unassessed exercise: Complete the truth table for the mux1 circuit, by simulating it for all input combinations. Try to describe, at a more abstract and intuitive level, how it works.</p></li>
</ul>
<h3 id="the-multiplexer-circuit">The multiplexer circuit}</h3>
<p>THIS ONE IS REDUNDANT, HAVE A BETTER tikz DIAGRAM</p>
<p></p>
<pre><code>mux1 c x y =
   or2  (and2 (inv c) x)
        (and2 c y)</code></pre>
<h4 id="characteristics-of-combinational-circuits">Characteristics of combinational circuits}</h4>
<h3 id="two-kinds-of-circuit">Two kinds of circuit}</h3>
<ul>
<li><p>Combinational circuits</p>
<ul>
<li>Consist entirely of logic gates</li>
<li>No feedback loops</li>
</ul></li>
<li><p>Sequential circuits</p></li>
<li>May contain logic gates and flip flops</li>
<li><p>Feedback loops are allowed</p></li>
</ul>
<h3 id="hexadecimal-numbers">Hexadecimal Numbers}</h3>
<h2 id="hexadecimal-numbers-1">Hexadecimal Numbers</h2>
<ul>
<li>Base-16 numbers</li>
<li>Don’t worry! Hexadecimal numbers are used only when they are easier than binary!</li>
<li>Used as a notation to make it easier to read and write bytes and words</li>
<li>A small investment in learning Hex will save lots of time later</li>
<li>Used routinely in  and </li>
</ul>
<h3 id="hexadecimal-digits">Hexadecimal Digits</h3>

<h3 id="hexadecimal-numbers-hex-numbers">Hexadecimal numbers (``hex numbers’’)</h3>
<ul>
<li>Hex is used to write bit strings more concisely</li>
<li>The bit string needs to have a multiple of 4 bits</li>
<li>Modern computers use ``nibbles’’ (4 bits), bytes (8 bits), short words (16 bits), full words (32 bits), long words (64 bits), and sometimes 128-bit words</li>
<li>Break up the word into groups of 4 bits</li>
<li>Replace each group with the corresponding hex digit</li>
</ul>

<h3 id="hexadecimal-is-easier-to-read-than-bits">Hexadecimal is easier to read than bits</h3>
<ul>
<li>Like binary, hex is for nonnegative integers</li>
<li>But we can write out any word as hex digits</li>
<li>Each hex digit corresponds to 4 bits: Hex is 4 times more concise</li>
<li>Long strings of bits are hard to read: it’s hard to keep your place</li>
</ul>
<h3 id="black-boxes">Black boxes</h3>
<ul>
<li>We can define a circuit as a black box by giving it a name, and specifying its ports (inputs and outputs)</li>
<li>This is analogous to using abstraction in a programming language by defining a function for a commonly used computation</li>
<li>It is a box, with inputs, outputs, and internal components and signals</li>
</ul>
<pre><code>circuit_name input1 input2 = (output1,output2)
  where
    output1 = ...
    output2 = ...
    x = ... (internal signals...)
    y = ...</code></pre>
<h2 id="jumping-2">Jumping</h2>
<p>All jumps refer to effective addresses.</p>
<ul>
<li>jumpf R1,const[R2] \ If R1 false then goto mem[R2+const]</li>
<li>jumpt R1,const[R2] \ If R1 true then goto mem[R2+const]</li>
</ul>
<h3 id="instruction-set-1">Instruction set</h3>
<pre><code>load   R1,x[R2]   R1 := mem[x+R2]
lea    R1,x[R2]   R1 := x+R2
store  R1,x[R2]   mem[x+R2] := R1
jumpf  R1,x[R2]   if R1=0 then pc := x+R2
jumpt  R1,x[R2]   if R1/=0 then pc := x+R2
jal    R1,x[R2]   R1 := pc, pc := x+R2

add    R1,R2,R3   R1 := R2+R3
sub    R1,R2,R3   R1 := R2-R3
cmplt  R1,R2,R3   R1 := R2&lt;R3
cmpeq  R1,R2,R3   R1 := R2=R3
cmpgt  R1,R2,R3   R1 := R2&gt;R3</code></pre>
<h3 id="what-can-we-learn-from-this">What can we learn from this?</h3>
<ul>
<li><p>To be a good programmer you need to</p>
<ul>
<li>Know your programming language</li>
<li>Be meticulous</li>
<li> your code carefully</li>
<li>Do thorough testing</li>
</ul></li>
<li><p>It was very helpful that Apple published the source code for this bug</p></li>
</ul>
<h3 id="closed-source-open-source-free-1">Closed source, open source, free</h3>
<ul>
<li> — the software is proprietary, the company doesn’t publish it (you can get the machine language code but not the high level language code)</li>
<li> — the source code is published, although the owner has control</li>
<li> — You can make a copy of the code and modify it</li>
<li><p>Much controversy!</p></li>
<li>One view: a large company can ensure high quality, and needs to ensure it gets paid for its work</li>
<li><p>Another view: ``with many eyes studying code, every bug is visible’’ — open source and free software can be more reliable</p></li>
</ul>
<h3 id="processor-organisation">Processor organisation}</h3>
<h3 id="a-computer-is-a-digital-circuit-1">A computer is a digital circuit!</h3>
<ul>
<li>It isn’t a magic box with a little man inside!</li>
<li><p>A computer is a  constructed from  and </p></li>
<li> — the entire computer is implemented down to the level of inv, and2, dff, etc.</li>
<li>Today we’ll take a brief overview</li>
<li>Some more detail in CS2</li>
<li><p>Computer Architecture 4 covers the full system, along with advanced techniques: pipelining, superscalar, combinators, parallel scan, synchronisers, circuit parallelism, and more</p></li>
</ul>
<h3 id="processor-organisation-1">Processor organisation</h3>
<ul>
<li><p>The RTM circuit (register transfer machine)</p></li>
<li>Contains a register file, and adder, and a multiplexer</li>
<li><p>It can execute a sequence of Sigma16 add instructions</p></li>
<li><p>We can extend this circuit to handle the entire architecture!</p></li>
</ul>
<h3 id="control-registers-2">Control registers</h3>
<ul>
<li>The circuit needs to </li>
<li><p>This is done using </p></li>
<li>The  contains the instruction currently being executed</li>
<li><p>The  contains the address of the next instruction</p></li>
<li><p>You can see these registers in the emulator window</p></li>
</ul>
<h3 id="the-control-algorithm-1">The control algorithm</h3>
<ul>
<li>Actions performed by the machine are </li>
<li><p>The choice of  action to perform is determinted by the </p></li>
<li>This is described as an ordinary algorithm, using pseudocode</li>
<li>It determines which values get loaded into which registers at each clock tick</li>
<li><p>The algorithm is implemented using flip flops and logic gates</p></li>
<li><p>The algorithm is an </p></li>
<li><p>Each iteration fetches the next instruction, decodes it, and executes it</p></li>
</ul>
<h3 id="structure-of-the-control-algorithm">Structure of the control algorithm</h3>
<pre><code>repeat forever
  ir := mem [pc],  pc := pc+1
  case ir.op of
    0 -&gt; reg [ir.d] := reg [ir.sa] + reg [ir.sb]    ; add
    1 -&gt; reg [ir.d] := reg [ir.sa] - reg [ir.sb]    ; sub
       ...
    4 -&gt; reg [ir.d] := reg [ir.sa] &lt; reg [ir.sb]     ; cmplt
       ...
   15 -&gt; case ir.sb of
               0 -&gt; adr := mem [pc],  pc = pc + 1    ; lea
                       adr := adr + reg [ir.sa]
                       reg [ir.d] := adr
               1 -&gt; adr := mem [pc],  pc = pc + 1    ; load
                       adr := adr + reg [ir.sa]
                       dat := mem [adr]
                       reg [ir.d] := dat</code></pre>
<h3 id="a-closer-look-at-lea">A closer look at lea</h3>
<ul>
<li>Fetch the second word of the instruction (the displacement) and put it in adr; also increment the pc</li>
<li>Calculate the effective address: displacement + index register</li>
<li>Load the effective address into the destination register \end{enumerate}</li>
</ul>
<pre><code>        0 -&gt; adr := mem [pc],  pc = pc + 1    ; lea
             adr := adr + reg [ir.sa]
             reg [ir.d] := adr</code></pre>
<h3 id="lea-and-load-similar-but-not-identical">Lea and Load: similar but not identical!</h3>
<ul>
<li>Load starts the same as lea: it calculates the effective address</li>
<li>Then it  and loads that into the destination register</li>
<li>The difference is that lea just loads the effective address into the destination register</li>
</ul>
<pre><code>        0 -&gt; adr := mem [pc],  pc = pc + 1    ; lea
             adr := adr + reg [ir.sa]
             reg [ir.d] := adr

        1 -&gt; adr := mem [pc],  pc = pc + 1    ; load
             adr := adr + reg [ir.sa]
             dat := mem [adr]
             reg [ir.d] := dat</code></pre>
<h3 id="a-jump-is-just-a-load">A jump is just a load!</h3>
<ul>
<li>Calculate the effective address</li>
<li>Load the effective address into the pc</li>
<li>The next instruction to be executed is whatever is at that address</li>
</ul>
<pre><code>        3 -&gt; adr := mem [pc],  pc = pc + 1    ; jump
             adr := adr + reg [ir.sa]
             pc := adr</code></pre>
<h3 id="processor-organisation-2">Processor organisation</h3>
<p>A computer is a digital circuit!</p>
<ul>
<li>It isn’t a magic box with a little man inside!</li>
<li><p>A computer is a  constructed from  and </p></li>
<li> — the entire computer is implemented down to the level of inv, and2, dff, etc.</li>
<li>Today we’ll take a brief overview</li>
<li>Some more detail in CS2</li>
<li><p>Computer Architecture 4 covers the full system, along with advanced techniques: pipelining, superscalar, combinators, parallel scan, synchronisers, circuit parallelism, and more</p></li>
</ul>
<h3 id="processor-organisation-3">Processor organisation</h3>
<ul>
<li><p>The RTM circuit (register transfer machine)</p></li>
<li>Contains a register file, and adder, and a multiplexer</li>
<li><p>It can execute a sequence of Sigma16 add instructions</p></li>
<li><p>We can extend this circuit to handle the entire architecture!</p></li>
</ul>
<h3 id="control-registers-3">Control registers</h3>
<ul>
<li>The circuit needs to </li>
<li><p>This is done using </p></li>
<li>The  contains the instruction currently being executed</li>
<li><p>The  contains the address of the next instruction</p></li>
<li><p>You can see these registers in the emulator window</p></li>
</ul>
<h3 id="the-control-algorithm-2">The control algorithm</h3>
<ul>
<li>Actions performed by the machine are </li>
<li><p>The choice of  action to perform is determinted by the </p></li>
<li>This is described as an ordinary algorithm, using pseudocode</li>
<li>It determines which values get loaded into which registers at each clock tick</li>
<li><p>The algorithm is implemented using flip flops and logic gates</p></li>
<li><p>The algorithm is an </p></li>
<li><p>Each iteration fetches the next instruction, decodes it, and executes it</p></li>
</ul>
<h3 id="structure-of-the-control-algorithm-1">Structure of the control algorithm</h3>
<pre><code>repeat forever
  ir := mem [pc],  pc := pc+1
  case ir.op of
    0 -&gt; reg [ir.d] := reg [ir.sa] + reg [ir.sb]    ; add
    1 -&gt; reg [ir.d] := reg [ir.sa] - reg [ir.sb]    ; sub
       ...
    4 -&gt; reg [ir.d] := reg [ir.sa] &lt; reg [ir.sb]     ; cmplt
       ...
   15 -&gt; case ir.sb of
               0 -&gt; adr := mem [pc],  pc = pc + 1    ; lea
                       adr := adr + reg [ir.sa]
                       reg [ir.d] := adr
               1 -&gt; adr := mem [pc],  pc = pc + 1    ; load
                       adr := adr + reg [ir.sa]
                       dat := mem [adr]
                       reg [ir.d] := dat</code></pre>
<h3 id="a-closer-look-at-lea-1">A closer look at lea</h3>
<ul>
<li>Fetch the second word of the instruction (the displacement) and put it in adr; also increment the pc</li>
<li>Calculate the effective address: displacement + index register</li>
<li>Load the effective address into the destination register</li>
</ul>
<pre><code>        0 -&gt; adr := mem [pc],  pc = pc + 1    ; lea
             adr := adr + reg [ir.sa]
             reg [ir.d] := adr</code></pre>
<h3 id="lea-and-load-similar-but-not-identical-1">Lea and Load: similar but not identical!</h3>
<ul>
<li>Load starts the same as lea: it calculates the effective address</li>
<li>Then it  and loads that into the destination register</li>
<li>The difference is that lea just loads the effective address into the destination register</li>
</ul>
<pre><code>        0 -&gt; adr := mem [pc],  pc = pc + 1    ; lea
             adr := adr + reg [ir.sa]
             reg [ir.d] := adr

        1 -&gt; adr := mem [pc],  pc = pc + 1    ; load
             adr := adr + reg [ir.sa]
             dat := mem [adr]
             reg [ir.d] := dat</code></pre>
<h3 id="a-jump-is-just-a-load-1">A jump is just a load!</h3>
<ul>
<li>Calculate the effective address</li>
<li>Load the effective address into the pc</li>
<li>The next instruction to be executed is whatever is at that address</li>
</ul>
<pre><code>        3 -&gt; adr := mem [pc],  pc = pc + 1    ; jump
             adr := adr + reg [ir.sa]
             pc := adr</code></pre>
<h3 id="programming-guidelines">Programming Guidelines</h3>
<ul>
<li>The program file should contain the following, in this order:</li>
</ul>
<h3 id="identify-the-program">Identify the program</h3>
<pre><code>; Program Max (Sigma16 assembly language)
; Author: John O&#39;Donnell, 2017

; Max: find the maximum element of an array
;
; The program is given
;   *  a natural number n, assume n&gt;0
;   *  an n-element array x[0], x[1], ..., x[n-1]
;  It calculates
;   * max = the maximum element of x</code></pre>
<p>Write this first, and put it at the start of the file, as full ine comments. Say what the program is and what it does.</p>
<h3 id="high-level-algorithm-as-pseudocode">High level algorithm as pseudocode</h3>
<pre><code>; Since n&gt;0, the array x contains at least one element,
; and a maximum element is guaranteed to exist.
;
;   max := x[0]
;   for i := 1 to n-1
;       if x[i] &gt; max
;         then max := x[i]</code></pre>
<p>}</p>
<p>Put this after the program identification comments.</p>
<h3 id="middle-level-the-goto-form">Middle level: the ``goto form’’</h3>
<ul>
<li><p>The algorithm is written in high level language notation</p>
<ul>
<li>It just uses variables, without specifying whether they are currently in registers or memory</li>
<li>It doesn’t need instructions like load, store, lea</li>
<li>It can use expressions like  which would require several instructions to implement</li>
</ul></li>
</ul>
<p>It may use</p>
<ul>
<li>Assignment statements, e.g 
<ul>
<li>goto statements, e.g. </li>
<li>if - then - goto, e.g. </li>
</ul></li>
<li>It does not contain complex control constructs: while, for, if-then-else</li>
<li>In an  statement, only a goto is allowed after </li>
</ul>
<h3 id="translate-high-level-code-to-low-level-goto-form-1">Translate high level code to low level ``goto form’’</h3>
<pre><code>;         i = 1
;         max = x[0]
; 
; loop:   if not (i&lt;n) then goto done
;         if x[i] &lt;= max then goto next
;         max = x[i]
; next:   i = i + 1
;         goto loop
; 
; done:   terminate</code></pre>
<p></p>
<h3 id="specify-how-the-registers-are-used-1">Specify how the registers are used</h3>
<p>If you keep any variables or constants in registers, document this in comments</p>
<pre><code>; Register usage
;   R1 = constant 1
;   R2 = n
;   R3 = i
;   R4 = max</code></pre>
<p>}</p>
<p>\alert{</p>
<ul>
<li>This makes it easier to check that you used the right register.</li>
<li>A bug like  is easy to spot: just compare the instruction with the register usage.</li>
<li>Without the register usage comments, you have to read a large part of the program to catch this one little bug. }</li>
</ul>
<h3 id="lowest-level-commented-assembly-language">Lowest level: Commented assembly language</h3>
<ul>
<li>The code should be organised in sections.</li>
<li>Separate the sections with a blank line - makes it easier to read</li>
<li>Each section corresponds to one statement in the goto-form algorithm</li>
<li>That statement appears as a full line comment before the instructions</li>
<li>Each instruction has a comment explaining what that instruction does, at the highest level possible (e.g. i := i + 1, not R3 := R3 + R7)</li>
</ul>
<h3 id="block-of-statements-to-initialise-registers-1">Block of statements to initialise registers</h3>
<pre><code>; Initialise

       lea   R1,1[R0]          ; R1 = constant 1
       load  R2,n[R0]          ; R2 = n
       lea   R3,1[R0]          ; R3 = i = 1
       load  R4,x[R0]          ; R4 = max = x[0]</code></pre>
<p>}</p>
<p>These instructions implement what the Register Usage comments say</p>
<h3 id="assembly-language-code">Assembly language code</h3>
<pre><code>; Top of loop, determine whether to remain in loop
; if not (i&lt;n) then goto done
loop
       cmp    R3,R2            ; compare i, n
       jumpge R5,done[R0]      ; if i&gt;=n then goto done

; if x[i] &lt;= max  then goto next
       load   R5,x[R3]         ; R5 = x[i]
       cmp    R5,R4            ; compare x[i], max
       jumple next[R0]         ; if x[i] &lt;= max then goto next

; max := x[i]
       add   R4,R5,R0          ; max := x[i]</code></pre>
<p>}</p>
<h3 id="assembly-language-continued">Assembly language, continued</h3>
<pre><code>; Bottom of loop, increment loop index
;   i = i + 1
;   goto loop

next   add   R3,R3,R1          ; i = i + 1
       jump  loop[R0]          ; go to top of loop

; Store max and terminate
done   store R4,max[R0]        ; max = R4
       trap  R0,R0,R0          ; terminate</code></pre>
<p>}</p>
<h3 id="data-definitions-1">Data definitions</h3>
<pre><code>; Data area
n        data   6
max      data   0
x        data  18
         data   3
         data  21
         data  -2
         data  40
         data  25</code></pre>
<p>}</p>
<h3 id="static-variables-in-a-data-segment-1">Static variables in a data segment</h3>
<ul>
<li>The variables are not placed in memory right after the instructions</li>
<li>The program makes a request to the operating system to allocate a block of memory for data (the static data segment)</li>
<li>A register is dedicated to point to the static data segment</li>
<li>Variables are accessed using the static data segment register</li>
</ul>
<h3 id="implementing-static-data-segment-1">Implementing static data segment</h3>
<pre><code>     ... set up registers to request a
          data block of n words...

     trap  R1,R2,R3
     ... R3 is set to the address of the data block
     add   R12,R0,R3    ; R12 = address of static data segment

   ...
     load  R2,n[R12]    ; R2 := n (access static variable)

     segment            ; subsequent labels will access segment
n    data
x    data</code></pre>
<p>}</p>
<h2 id="a-digital-circuit-for-sigma16">A digital circuit for Sigma16</h2>
<ul>
<li>There is a complete digital circuit for Sigma16</li>
<li>It’s too complicated for a schematic diagram</li>
<li>It is fully specified in Hydra</li>
<li>Executing the specification simulates the circuit</li>
<li>{}</li>
</ul>
<h3 id="emergent-behaviour">Emergent behaviour</h3>
<ul>
<li><p>A computer does lots of different things</p>
<ul>
<li>Arithmetic</li>
<li>Sequences of calculations</li>
<li>Decisions</li>
<li>Goto</li>
</ul></li>
<li>Yet it’s just a digital circuit made of logic gates and flip flops, which </li>
<li><p>The interesting behaviours  from the way the basic components are connected</p></li>
</ul>
<h3 id="some-examples-of-emergent-ultimate-causes-1">Some examples of emergent ``ultimate causes’’</h3>
<ul>
<li><p>Arithmetic</p>
<ul>
<li>Full adder uses logic gates to calculate sum and carry</li>
<li>Ripple carry adder transfers carry bits to get binary sum</li>
</ul></li>
<li><p>Sequences of calculations</p></li>
<li><p>The pc register points to next instruction, and is incremented as each instruction is executed</p></li>
<li><p>Decisions</p></li>
<li>If statements are translated to </li>
<li><p>Control algorithm uses a multiplexer to take different actions based on cond</p></li>
<li><p>Goto</p></li>
<li><p>Goto is just loading the pc with the effective address</p></li>
</ul>
<h2 id="a-multi-level-systems-programming-language">A multi-level systems programming language</h2>
<ul>
<li>Our focus is on , not on details of any specific programming language</li>
<li><p>We’ll describe algorithms using a language that</p></li>
<li>Illustrates features from several real languages</li>
<li>Avoids some of the irrelevant complicated features that appear only in one language</li>
<li>Encourages a good, expressive programming style</li>
<li>Can express algorithms at both a high level and a low level</li>
<li><p>Supports  — that means it can do things that ordinary programming languages can’t do</p></li>
</ul>
<h3 id="features-of-sigma-so-far">Features of Sigma (so far)</h3>
<ul>
<li><p>Data values</p>
<ul>
<li>Integer constants, variables, expressions</li>
<li>Boolean expressions</li>
</ul></li>
<li><p>Low level statements</p></li>
<li>Assignment statement</li>
<li>goto statement</li>
<li><p>if bexp then goto statement</p></li>
<li><p>High level statements</p></li>
<li>if b then S1</li>
<li>if b then S1 else S2</li>
<li><p>while b do S1</p></li>
</ul>
<h2 id="assembly-language-3">Assembly language</h2>
<p>This section describes the syntax rules for assembly language</p>
<h3 id="assembly-language-notation">Assembly language notation</h3>
<ul>
<li>Each statement has four fields</li>
<li>The assembler uses a very simple rule: it just looks for groups of non-space characters, separated by spaces</li>
</ul>
<h3 id="fields-separated-by-spaces-1">Fields separated by spaces</h3>
<ul>
<li><p>An assembly language statement has </p>
<ul>
<li>label (optional) – if present, must begin in leftmost character</li>
<li>operation load, add, etc.</li>
<li>operands: R1,R2,R3 or R1,x[R0]</li>
<li>comments: ; x = 2 * (a+b)</li>
</ul></li>
<li><p></p></li>
<li>R1,R12,R5 is ok</li>
<li><p>R1, R12,R5 is wrong</p></li>
</ul>
<p>{ ~~~~ loop load R1,count[R0] ; R1 = count add R1,R1,R2 ; R1 = R1 + 1 ~~~~ }</p>
<p>The assember first breaks each statement into the four fields; then it looks at the operation and operands.</p>
<h3 id="correct-form-of-operand-field-1">Correct form of operand field</h3>
<ul>
<li><p>RRR</p>
<ul>
<li>Exactly three registers separated by commas</li>
<li>Example: </li>
</ul></li>
<li><p>RX</p></li>
<li>Two operands: first is a register, second is an address</li>
<li>Address is a name or constant followed by [register]</li>
<li><p>Example: </p></li>
</ul>
<h3 id="each-of-these-statements-is-wrong-1">Each of these statements is wrong!</h3>
<pre><code>    add   R2, R8, R9     Spaces in the operand field
    store x[R0],R5       First operand must be register, second is address
  loop load R1,x[R0]     Space before the label
    jumpt R6,loop        Need register after address:  loop[R0]
    jal   R14, fcn[R0]   Space in operand field</code></pre>
<p>}</p>
<p>If you forget some detail, look at one of the example programs</p>
<h3 id="writing-constants-1">Writing constants</h3>
<ul>
<li><p>In assembly language, you can write constants in either decimal or hexadecimal</p>
<ul>
<li> 50</li>
<li> $0032</li>
</ul></li>
</ul>
<p>Examples:</p>
<pre><code>   lea   R1,40[R0]      ; R1 = 40
   lea   R2,$ffff[R0]   ; R2 = -1

x  data  25
y  data  $2c9e</code></pre>
<h3 id="good-style-1">Good style</h3>
<ul>
<li>It isn’t enough just to get the assembler to accept your program without error messages</li>
<li>Your program should be </li>
<li>This requires good style</li>
<li></li>
<li>A sloppy program looks unprofessional</li>
</ul>
<h3 id="comments-2">Comments</h3>
<ul>
<li>In Sigma16, a semicolon  indicates that the rest of the line is a comment</li>
<li>You can have a full line comment: just put ; at the beginning</li>
<li>You should use good comments in all programs, regardless of language</li>
<li>But they are even more important in machine language, because the code needs more explanation</li>
<li>At the beginning of the program, use comments to give the name of the program and to say what it does</li>
<li>Use a comment on every instruction to explain what it’s doing</li>
</ul>
<h3 id="indent-your-code-consistently-1">Indent your code consistently</h3>
<p>Each field should be lined up vertically, like this:</p>
<pre><code>    load   R1,three[R0]  ; R1 = 3
    load   R2,x[R0]      ; R2 = x
    mul    R3,R1,R2      ; R3 = 3*x
    store  R3,y[R0]      ; y = 3*x
    trap   R0,R0,R0      ; stop the program</code></pre>
<p>}</p>
<p>Not like this:</p>
<pre><code>    load   R1,three[R0]     ; R1 = 3
  load  R2,x[R0] ; R2 = x
       mul R3,R1,R2           ; R3 = 3*x
 store         R3,y[R0]      ; y = 3*x
   trap  R0,R0,R0      ; stop the program</code></pre>
<p>}</p>
<p>{The exact number of spaces each field is indented isn’t important; what’s important is to }</p>
<h3 id="use-spaces-not-tabs-1">Use spaces, not tabs</h3>
<ul>
<li>To indent your code, always use spaces</li>
<li>Don’t use tabs!</li>
<li><p>In general,  except in the (rare) cases they are actually required</p></li>
<li>The tab character was introduced to try to mimic the tab key on old mechanical typewriters</li>
<li>But </li>
<li><p>If you use tabs, your can look good in one application and a mess in another</p></li>
<li><p>It’s easy to indent with spaces, and it works everywhere!</p></li>
</ul>
<h2 id="programming-techniques-1">Programming techniques</h2>
<p>Notes on how to use the instructions effectively</p>
<h3 id="programming-tip-copying-one-register-to-another-1">Programming tip: Copying one register to another</h3>
<ul>
<li>Here’s a useful tip — a standard programming technique</li>
<li><p>Sometimes you want to copy a value from one register to another</p></li>
<li><p>R3 := R12</p></li>
<li><p>There’s a standard way to do it:</p></li>
<li><p></p></li>
<li>The idea is that R12 + 0 = R12!</li>
<li><p>Why do it this way? </p></li>
</ul>
<h3 id="using-load-and-store-1">Using load and store</h3>
<ul>
<li>A common error is to confuse load and store</li>
<li><p>The main points to remember:</p></li>
<li>We need to keep variables in memory (most of the time) because memory is big — there aren’t enough registers to hold all your variables</li>
<li>The computer hardware can do arithmetic on data in registers, but it cannot do arithmetic on data in memory</li>
<li>Therefore, to do arithmetic on variables, you must</li>
</ul>
<h3 id="a-useful-convention-1">A useful convention</h3>
<ul>
<li><p>The instruction set is designed to be regular, and to follow consistent conventions</p>
<ul>
<li>This makes programming easier</li>
<li>It also helps with the hardware design!</li>
</ul></li>
<li><p>For most instructions, the operands follow the pattern of an assignment statement: information goes right to left</p></li>
<li>Assignment statement: </li>
<li>Add instruction: </li>
<li>The two operands on the right (R2, R3) are added, and placed in the destination on the left (R1)</li>
<li><p>Load instruction:  means </p></li>
<li><p></p></li>
<li> means x := R1: the information goes from left to right</li>
<li><p>Why? Doing it this way makes the digital circuit (the processor) a little bit faster</p></li>
</ul>
<h3 id="development-by-transformation">Development by transformation}</h3>
<ul>
<li>In typical ``real world’’ situations a programmer just uses a high level language</li>
<li>To produce assembly language, a typical programmer is tempted to hack out code randomly and debug it randomly</li>
<li><p>We are insisting on a systematic approach</p></li>
<li>Start with algorithm in a high level language</li>
<li>Transform it to low level via systematic patterns</li>
<li>Transform that to assembly language</li>
<li>Test each stage by hand execution</li>
<li><p>The worst bugs usually appear in the high to low transformation</p></li>
</ul>
<h3 id="high-level">High level</h3>
<pre><code>   sum := 0;
   p := &amp;RecordArray;
   q := &amp;RecordArrayEnd;
   while p &lt; q do
     { *p.fieldA := *p.fieldB + *p.fieldC;
       sum := sum + *p.fieldA;
       p := p + RecordSize; }</code></pre>
<h3 id="low-level">Low level</h3>
<pre><code>   sum := 0;
   p := &amp;RecordArray;
   q := &amp;RecordArrayEnd;
RecordLoop
   if (p&lt;q) = False then goto recordLoopDone;
   *p.fieldA := *p.fieldB + *p.fieldC;
   sum := sum + *p.fieldA;
   p := p + RecordSize;
   goto recordLoop;
RecordLoopDone</code></pre>
<h3 id="assembly">Assembly</h3>
<pre><code>    lea    R1,0[R0]                 ; sum := 0
    lea    R2,RecordArray[R0]       ; p := &amp;RecordArray;
    lea    R3,RecordArrayEnd[R0]    ; q := &amp;RecordArray;
    load   R4,RecordSize[R0]        ; R4 := RecordSize
RecordLoop
    cmplt  R5,R2,R3                 ; R5 := p&lt;q
    jumpf  R5,RecordLoopDone[R0]    ; if (p&lt;q) = False then goto RecordLoopDone
    load   R5,1[R2]                 ; R5 := *p.fieldB
    load   R6,2[R2]                 ; R6 := *p.fieldC
    add    R7,R5,R6                 ; R7 := *p.fieldB + *p.fieldC
    store  R7,0[R2]                 ; *p.fieldA := *p.fieldB + *p.fieldC
    add    R1,R1,R7                 ; sum := sum + *p.fieldA
    add    R2,R2,R4                 ; p := p + RecordSize
    jump   RecordLoop[R0]           ; goto RecordLoop
RecordLoopDone</code></pre>
<h4 id="basic-types-and-statements">Basic types and statements}</h4>
<h3 id="basic-expressions-and-statements">Basic expressions and statements</h3>
<ul>
<li><p>Expressions</p>
<ul>
<li>integer and natural</li>
<li>boolean</li>
</ul></li>
<li><p>assignments</p></li>
<li><p>lhs := expression</p></li>
</ul>
<h3 id="exposing-the-architecture">Exposing the architecture</h3>
<ul>
<li>Low level language constructs expose the architecture</li>
<li>The lowest level language constructs correspond directly to instructions</li>
<li><p>Registers</p></li>
<li><p>Register variables R0, R1, <span class="math inline">…</span>, R15</p></li>
<li><p>Instructions</p></li>
<li>load </li>
<li>store </li>
<li>add </li>
<li>jump </li>
<li>jumpt </li>
<li><p>jumpf </p></li>
<li><p>Interface to operating system</p></li>
</ul>
<h3 id="relations-between-the-levels">Relations between the levels</h3>
<ul>
<li>We could have completely separate high and low level languages</li>
<li>Hypothesis: it’s better to allow mixing where the semantics is clear</li>
<li><p>This allows you to</p></li>
<li>Transform from high to low level in stages, rather than in one gigantic leap</li>
<li><p>Focus on the low level for a particularly interesting part of the program, while keeping the boilerplate at a high level</p></li>
<li><p>Disallow mixing levels where semantics is unclear</p></li>
<li><p>R4 := R2 - (x*y)</p></li>
</ul>
<h4 id="data-types-and-data-structures">Data types and data structures</h4>
<h3 id="data-types-1">Data types</h3>
<ul>
<li><p>Basic types</p>
<ul>
<li>integer, natural, pointer, boolean, character</li>
</ul></li>
<li><p>Compound types</p></li>
<li>array, record, linked lists, trees</li>
<li>Call stack, stack frame</li>
<li><p>Static variables, local variables, heap variables</p></li>
</ul>
<h3 id="records-3">Records</h3>
<pre><code>program Records
 { x, y :
     record
       { fieldA : int;
         fieldB : int;
         fieldC : int; }
   x.fieldA := x.fieldB + x.fieldC;
   y.fieldA := y.fieldB + y.fieldC;
 }</code></pre>
<h3 id="traverse-array-of-records-with-indexing-1">Traverse array of records with indexing</h3>
<pre><code>sum := 0;
for i := 0 to nrecords do
  { RecordArray[i].fieldA :=
       RecordArray[i].fieldB + RecordArray[i].fieldC;
    sum := RecordArray[i].fieldA; }</code></pre>
<h3 id="traverse-array-of-records-with-pointers">Traverse array of records with pointers</h3>
<pre><code>sum := 0;
p := &amp;RecordArray;
q := &amp;RecordArrayEnd;
while p &lt; q do
  { *p.fieldA := *p.fieldB + *p.fieldC;
    sum := sum + *p.fieldA;
    p := p + RecordSize; }</code></pre>
<h3 id="high-level-control-structures-1">High level control structures</h3>
<ul>
<li>if bexp then S
<ul>
<li>if bexp then S else S</li>
<li>if bexp then S elsif bexp then S elsif … else S</li>
<li>case exp of {S; S; …}</li>
<li>while bexp do S</li>
<li>repeat S until bexp</li>
<li>procedure P (var:type, …)</li>
<li>function F (var:type, …) : type</li>
</ul></li>
</ul>
<h3 id="low-level-control-structures">Low level control structures</h3>
<ul>
<li>goto label</li>
<li>if bexp then goto label</li>
<li>if not bexp then goto label</li>
</ul>
<h3 id="compilation-patterns-4">Compilation patterns</h3>
<ul>
<li>Each programming construct can be translated according to a standard pattern</li>
<li><p>It’s useful to translate in two steps:</p></li>
<li>First, translate complex statements to simple high level statements (go to label, if b then goto label)</li>
<li>The ``goto form’’ of the algorithm corresponds closely to machine instructions</li>
<li><p>Then it’s straightforward to complete the translation to assembly language</p></li>
<li>Assignment statements — loads, then arithmetic, then store</li>
<li>goto label — jump label[R0]</li>
<li>if b then goto label — jumpt R5,label[R0] where R5 contains b</li>
<li><p>if not b then goto label — jumpf R5,label[R0] where R5 contains b</p></li>
<li><p>This approach clarifies how the algorithm works</p></li>
</ul>
<h3 id="if-bexp-then-s-2">if bexp then S</h3>
<pre><code>if x&lt;y
  then {statement 1;}
statement 2;</code></pre>
<p></p>
<pre><code>   R7 := (x &lt; y)
   jumpf R7,skip[R0]
   instructions for statement 1
skip
   instructions for statement 2 </code></pre>
<h3 id="if-bexp-then-s1-else-s2-2">if bexp then S1 else S2</h3>
<pre><code>if x&lt;y
  then { S1 }
  else { S2 }
S3</code></pre>
<p>Compiled into: ~~~~ R5 := (x&lt;y) jumpf R5,else[R0] ; then part of the statement instructions for S1 jump done[R0] ; else part of the statement else instructions for S2 done instructions for statement S3 ~~~~</p>
<h3 id="while-b-do-s-1">while b do S</h3>
<pre><code>while i&lt;n do
  { S1 }
S2</code></pre>
<p>Compiled into: ~~~~ loop R6 := (i&lt;n) jumpf R6,done[R0] … instructions for the loop body S1 … jump loop[R0] done instructions for S2 ~~~~</p>
<h3 id="implementing-compilation-patterns">Implementing compilation patterns</h3>
<ul>
<li>All the language constructs correspond to constructors in an algebraic data type</li>
<li>Use pattern matching definitions, here’s a sketch</li>
</ul>
<pre><code>transform (IfThenElse b s1 s2) = do
  elseLabel &lt;- newlabel
  doneLabel &lt;- newlabel
  bcode &lt;- transform b
  testJump &lt;- ifnot bcode elseLabel
  thenCode &lt;- transform s1
  elseCode &lt;- transform s2
  return $
     bcode &lt;+&gt; testJump
       &lt;+&gt; thenCode &lt;+&gt; skipelse
       &lt;+&gt; elseLabel &lt;+&gt; elseCode
       &lt;+&gt; doneLabel</code></pre>
<h3 id="some-interesting-points">Some interesting points</h3>
<p>%———————————————————————</p>
<h3 id="opportunities">Opportunities</h3>
<ul>
<li>Normally we think of a machine language as being limited in expressiveness</li>
<li><p>But few programming languages expose some very important techniques that are available in a well-designed machine language</p></li>
<li>multiple word arithmetic</li>
<li>jump tables</li>
<li>arithmetic on data addresses</li>
<li><p>arithmetic on instruction addresses</p></li>
</ul>
<h3 id="opportunity-for-multiple-execution-models">Opportunity for multiple execution models</h3>
<ul>
<li><p>There are several ways to handle procedure calls</p>
<ul>
<li>Call stack vs. heap</li>
<li>Caller saves vs. callee saves</li>
<li>General recursion vs. tail recursion</li>
</ul></li>
<li><p>Plan to explore some of these</p></li>
<li>This requires transforming procedure calls into statements at the level of instructions</li>
<li><p>Some support by compiler analysis is needed</p></li>
</ul>
<h3 id="tricky-issues">Tricky issues</h3>
<ul>
<li><p>Syntax</p>
<ul>
<li>Explicit or implicit compound statements?</li>
<li> b  {S; S;}  {S; S;}</li>
<li> b  S; S  S; S </li>
<li>Also affects scoping rules</li>
<li>Could be interesting to allow/illustrate both styles</li>
<li>Prefix operators:  or  or </li>
</ul></li>
<li><p>Semantics</p></li>
<li>Some low level statements have side effects</li>
<li><p>Interrupts cause unexpected jumps</p></li>
</ul>
<h2 id="stacks-1">Stacks</h2>
<p>A stack is represented as a block of words with consecutive addresses sb, sb+1, sb+2, …, sl. There are three instructions that operate on stacks: push, pop, and top. Each of these instructions checks to ensure that the operation is valid, and indicates an error condition of not. Four variables are needed to use a stack:</p>
<ul>
<li><p>sb (stack base) = address of the first word in the block</p></li>
<li><p>sl (stack limit) = address of the last word in the block; for the stack to function properly it is necessary that sb &lt; sl.</p></li>
<li><p>st (stack top) = pointer to the top element. There are three cases. If the stack contains at least one element, then st is its address and sb &lt;= st &lt;= sl. If the stack is empty, then st=sb-1. If the stack is full, then st=sl.</p></li>
<li><p>x (data) = value to be pushed onto the stack, or result of a pop or top operation</p></li>
</ul>
<p>There are three instructions that operate on stacks: push, pop, and top. Push inserts the value in the destination register at the top of the stack, pop removes the top of the stack and loads it into the destination register, and top loads the top element into the destination register without removing it from the stack. For all three instructions, if the operation is impossible then an error is signaled in the condition code register and the interrupt request register.</p>
<h1 id="circuit">Circuit</h1>
<ul>
<li><p>Download Hydra and save it in your workspace. Suppose its location is /c/Users/me/a/b/c/Hydra.</p></li>
<li><p>Open a shell and enter circuit/M1. Run a test program, e.g. ArrayMax.hs, as follows:</p></li>
</ul>
<pre><code>ghci -i/c/Users/me/a/b/c/Hydra/src/haskell/ ArrayMaxRun</code></pre>
<p>The command can be simplified by defining a .ghci file, which will be loaded automatically when you invoke ghci. You can put the .ghci file in your $HOME directory. See the GHC User Guide for more details about configuring ghci.</p>
<pre><code>:set -i/c/Users/a/b/c/Hydra/src/haskell/</code></pre>
<p>On development machine (Spectre) use this path:</p>
<pre><code>ghci -i/c/Users/johnt/OneDrive/home/docs/research/Hydra/current/Hydra/src/haskell/
ArrayMaxRun</code></pre>
<p>$HOME/.ghci contains:</p>
<pre><code>:set -iC:\Users\johnt\OneDrive\home\docs\research\Hydra\current\Hydra\src\haskell</code></pre>
<h2 id="m1-circuit">M1 circuit</h2>
<p>M1 is a relatively simple digital circuit that implements a subset of the Sigma16 instruction set architecture. M1 uses sequential control and does not have instruction level parallelism. The circuits comprising M1 are defined in <strong>circuit/M1</strong>.</p>
<p>A few Sigma16 machine language programs, prepared to run on M1, are defined in <strong>circuit/examples/M1examples</strong>. To run these, you need to ensure that both Hydra and M1 are in the ghci search path. See above for making Hydra available. The M1 circuit is placed on the search path by including the following file circuit/examples/M1examples/.ghci:</p>
<p>:set -i../../M1</p>
<p>Enter the directory and enter these commands:</p>
<p>ghci :load ArrayMaxRun :main</p>
<p>These will execute the ArrayMax program on the digital circuit, and that will produce a lot of detailed simulation output showing the values in key registers, flip flops, and signals.</p>
<h1 id="installation">Installation</h1>
<h2 id="browser-compatibility">Browser compatibility</h2>
<p>The application currently works with Chrome and Firefox, and possible Edge.</p>
<h2 id="where-to-find-the-software">Where to find the software</h2>
<p>The software is available on the Internet at the <a href="https://jtod.github.io/Sigma16/">Sigma16 home page</a>, which contains a link to the latest version, some previous versions, related documents, and more information about the project.</p>
<h2 id="how-to-run-sigma16">How to run Sigma16</h2>
<p>There are a number of ways to run the software, but it’s recommended that you try the easiest way.</p>
<h3 id="the-easiest-way-just-click-a-link">The easiest way: just click a link</h3>
<p>Run the app with two clicks:</p>
<ol type="1">
<li>Visit the <a href="https://jtod.github.io/Sigma16/index.html">Sigma16 homepage</a></li>
<li>Click on <em>Launch the latest release</em></li>
</ol>
<p>This will run the app in your browser, and you don’t need to download or install anything. For most users this is the recommended method.</p>
<h3 id="download-and-open-file-in-browser">Download and open file in browser</h3>
<p>If you don’t always have Internet access, you can download the files and ope the app in your browser. This is easy to do and allows you to run Sigma16 even when you don’t have access to the Internet. However, it is a little more awkward to run the example programs.</p>
<p>You can also download the software onto your computer and run it locally. This exactly like the first method, except the web pages are coming from your computer’s files rather than the Internet.</p>
<p>Visit the <a href="https://jtod.github.io/Sigma16/index.html">Sigma16 home page</a> and download the zip file for the latest release. Unzip and click on index.html in the folder and follow the directions.</p>
<p>You might also be able to launch it by <a href="../../Sigma16.html">clicking this link</a> although that might not work; it depends on whether all the necessary files are accessible.</p>
<h3 id="run-locally-with-npm-and-electron">Run locally with npm and electron</h3>
<p>The previous methods run the app in a browser. There are some security restrictions on what a browser can do, and these make it slightly awkward for the program to read and write files. You can perform a local installation which will run Sigma16 as a standalone app on your computer, rather than in a browser, and this makes it a little more convenient to use.</p>
<p>If you don’t want to bother with downloading some software tools and running an installation script, you can skip to the next method, which is to download a precompiled executable for your platform. But it’s straightforward to build Sigma16 on your computer:</p>
<ul>
<li><p>You need a shell such as bash or Windows PowerShell. Every computer will have one.</p>
<ul>
<li><p>Install the npm package manager for JavaScript, available at <a href="https://www.npmjs.com/get-npm">https://www.npmjs.com/get-npm</a>. Download the installer and follow the instructions.</p></li>
<li><p>Install the <em>electron</em> package. In your shell, enter <em>npm install electron –save-dev</em>. (Why is it called “electron”? Originally, there was a text editor named <em>Atom</em> written in JavaScript, and it needed a shell. So it’s the electron shell for atom…</p></li>
<li><p>Download the source for Sigma16. Unzip it, and cd into the app directory. Enter <em>make all</em>.</p></li>
<li><p>To launch Sigma16, enter <em>npm run start</em>. Now you’ll have enhanced file access, as well as a few other minor enhancements, and you don’t need Internet access.</p></li>
</ul></li>
</ul>
<h3 id="compiling-a-standalone-executable">Compiling a standalone executable</h3>
<p>First install npm, which also gives you Node.js. Use npm to install electron.</p>
<p>cd src npm install npm start</p>
<p>Clone this repository, then enter the repository, install dependencies, and run the program:</p>
<p>git clone https://github.com/electron/electron-quick-start cd electron-quick-start npm install npm start</p>
<h2 id="workflow-for-development">Workflow for development</h2>
<h3 id="making-a-release-on-github-pages">Making a release on github pages</h3>
<p>make a local directory for editing the project page on github pages. cd into this directory.</p>
<p>git clone https://github.com/jtod/jtod.github.io git add jtod.github.io cd jtod.github.io git branch adds16dir git checkout adds16dir git status mkdir Sigma16 using emacs, create index.html and Sigma16/index.html</p>
<p>To build a release, the necessary files in the current version need to be copied from the development directory into the web page directory in jtod.github.io/Sigma16. However, it doesn’t work very well simply to copy the contents of the Sigma16 development directory into the release directory because all the .gitignore files should be skipped. Consequently a script is used to automate the construction of a release, and the script will copy exactly the required files.</p>
<p>git remote add webpage https://github.com/jtod/jtod.github.io git remote git status git push webpage adds16dir adds16dir is the local branch</p>
<p>On github page, made a pull request and selected adds1dir. There were no merge conflicts and the pull request was executed and cleared. The home page seems to come from the README file but refreshing it gives my index.html.</p>
<p>To build standalone version using Node.hs and electron. In the src/app directory, use the following commands. They create a file package-lock.json and a directory node_modules, both in src/app.</p>
<p>npm install npm start</p>
<p>The pkg program can generate a native executable which doesn’t require the user to have npm installed.</p>
<p>npm install -g pkg pkg –help pkg main.js</p>
<p>Maybe the bin entry in package.json would allow the command to be just pkg . ? In src directory tried this:</p>
<p>$ pkg -t win-x64 app</p>
<p>Lots of warnings:</p>
<blockquote>
<p>Warning Cannot include directory %1 into executable. The directory must be distributed with executable as %2. app_modules path-to-executable/electron/dist</p>
</blockquote>
<blockquote>
<p>Warning Cannot include file %1 into executable. The file must be distributed with executable as %2. app_modules.js path-to-executable/node_modules/sliced/index.js</p>
</blockquote>
<blockquote>
<p>Warning Cannot include file %1 into executable. The file must be distributed with executable as %2. app_modules-defaults.js path-to-executable/node_modules/deep-defaults/index.js</p>
</blockquote>
<p>Turns out that to build an app with electron one of the following specific tools is needed:</p>
<p>electron-forge electron-builder electron-packager</p>
<p>Trying electron-builder</p>
<p>npm install electron-builder –save-dev in src/app npm run mkdist</p>
<h3 id="version-number">Version number</h3>
<p>The version number is needed in several places. To keep it consistent, there is only one primary place where it should be specified manually: in the version property in app/package.json.</p>
<p>The makefile extracts the version number from that file, and (1) defines a make variable; (2) writes the Sigma16/VERSION file with just the version number, and (3) writes Sigma16/app/version.js which is just defines the version number as a global constant.</p>
<h3 id="running-in-a-browser.">Running in a browser.</h3>
<h3 id="running-a-standalone-pre-compiled-executable">Running a standalone pre-compiled executable</h3>
<h1 id="about-sigma16">About Sigma16</h1>
<h2 id="author">Author</h2>
<p>The architecture and software tools were designed by John O’Donnell.</p>
<h2 id="license">License</h2>
<p>This is free and open source software and is distributed under the GPL License, either version 3 or (at your option) any later version. See the LICENSE and LICENSE_GPL3 files. This program is experimental software, and is under development.</p>
<p>See the README and LICENSE files in the Sigma16 directory.</p>
<ul>
<li><a href="file:README.html">README</a>
<ul>
<li><a href="file:LICENSE.html">LICENSE</a></li>
<li><a href="file:LICENSE_GPL3.html">Full text of GPL3 license</a></li>
</ul></li>
</ul>
<h2 id="implementation-of-sigma16">Implementation of Sigma16</h2>
<p>The program is written in JavaScript, and normally uses a web browser to display the graphical user interface.</p>
<p>The circuits that implement Sigma16 are defined using the Hydra hardware description language, which is an embedded domain specific language implemented in Haskell.</p>
<p>The documentation is written in markdown and prepared for a web browser using pandoc.</p>
<h2 id="changes-underway">Changes underway</h2>
<p>Support relocatable code</p>
<ul>
<li>Change jump, jumpt, jumpf, jal to use pc-relative addressing</li>
<li>Introduce a jalext that uses indexed absolute address, for external</li>
</ul>
<p>Arithmetic Add/subtract with carry</p>
<p>Input/Output dma channels Ready Ack</p>
</body>
</html>
