<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>User Guidefoobar!</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="doc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">User Guide</h1>
</header>
Version 3.0.27
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#tutorial">Tutorial</a><ul>
<li><a href="#the-user-interface">The user interface</a></li>
<li><a href="#r-running-a-simple-program">R running a simple program</a></li>
</ul></li>
<li><a href="#tutorial-run-an-example-program">Tutorial: Run an example program</a></li>
<li><a href="#using-the-user-interface">Using the user interface</a><ul>
<li><a href="#editor">Editor</a></li>
<li><a href="#assembly-language">Assembly language</a></li>
<li><a href="#processor">Processor</a></li>
</ul></li>
</ul></li>
<li><a href="#programs-modules-and-files">Programs, modules, and files</a><ul>
<li><a href="#simple-standalone-programs">Simple standalone programs</a></li>
<li><a href="#programs-with-multiple-modules">Programs with multiple modules</a></li>
</ul></li>
<li><a href="#architecture-of-the-computer">Architecture of the computer</a><ul>
<li><a href="#data-representation">Data representation</a></li>
<li><a href="#register-file">Register file</a></li>
<li><a href="#control-registers">Control registers</a></li>
<li><a href="#condition-codes">Condition codes</a></li>
<li><a href="#processor-status-flags">Processor status flags</a></li>
<li><a href="#memory">Memory</a></li>
<li><a href="#exceptions">Exceptions</a></li>
<li><a href="#instruction-formats">Instruction formats</a><ul>
<li><a href="#rrr-format">RRR format</a></li>
<li><a href="#rx-format">RX format</a></li>
<li><a href="#exp-format">EXP format</a></li>
</ul></li>
</ul></li>
<li><a href="#instruction-set">Instruction set</a><ul>
<li><a href="#arithmetic">Arithmetic</a><ul>
<li><a href="#add">add</a></li>
<li><a href="#mul-multiply-signed-integers">mul (multiply signed integers)</a></li>
</ul></li>
<li><a href="#memory-instructions">Memory instructions</a><ul>
<li><a href="#load">load</a></li>
<li><a href="#store">store</a></li>
</ul></li>
<li><a href="#control">Control</a></li>
<li><a href="#summary-of-the-instruction-set">Summary of the instruction set</a></li>
</ul></li>
<li><a href="#assembly-language-1">Assembly Language</a><ul>
<li><a href="#notation">Notation</a></li>
<li><a href="#assembly-instruction-fields">Assembly instruction fields</a></li>
<li><a href="#expressions">Expressions</a></li>
<li><a href="#assembly-language-statements">Assembly language statements</a><ul>
<li><a href="#instructions">Instructions</a></li>
<li><a href="#directives">Directives</a></li>
</ul></li>
<li><a href="#object-language-statements">Object language statements</a></li>
<li><a href="#assembly-listing">Assembly listing</a></li>
</ul></li>
<li><a href="#linker">Linker</a></li>
<li><a href="#programming-the-sigma16-architecture">Programming the Sigma16 architecture</a></li>
<li><a href="#using-the-graphical-user-interface">Using the graphical user interface</a></li>
<li><a href="#about-the-software">About the software</a><ul>
<li><a href="#changes-underway">Changes underway</a></li>
</ul></li>
<li><a href="#installation">Installation</a><ul>
<li><a href="#license">License</a></li>
<li><a href="#browser-compatibility">Browser compatibility</a></li>
<li><a href="#how-to-run-the-application">How to run the application</a></li>
<li><a href="#how-to-run-the-program">How to run the program</a><ul>
<li><a href="#the-easiest-and-recommended-way-just-click-a-link">The easiest (and recommended) way: just click a link</a></li>
<li><a href="#if-you-dont-always-have-internet-access-copy-to-your-computer">If you don’t always have Internet access: copy to your computer</a></li>
<li><a href="#offers-enhanced-file-access-local-installation">Offers enhanced file access: Local installation</a></li>
<li><a href="#download-a-precompiled-executable-for-your-platform">Download a precompiled executable for your platform</a></li>
<li><a href="#making-a-release-on-github-pages">Making a release on github pages</a></li>
<li><a href="#version-number">Version number</a></li>
<li><a href="#running-in-a-browser.">Running in a browser.</a></li>
<li><a href="#running-a-standalone-pre-compiled-executable">Running a standalone pre-compiled executable</a></li>
<li><a href="#compiling-a-standalone-executable-requires-node.js-and-npm">Compiling a standalone executable; requires Node.js and npm</a></li>
</ul></li>
</ul></li>
<li><a href="#reference">Reference</a><ul>
<li><a href="#summary-of-notation">Summary of notation</a></li>
</ul></li>
</ul>
</nav>
<h1 id="introduction">Introduction</h1>
<p>Sigma16 is a computer architecture designed for research and teaching in computer systems. This application provides a complete environment for experimenting with the architecture, including an editor, assembler, linker, emulator, and an integrated development environment. There is a digital circuit that implements the architecture, which is specified using the Hydra functional hardware description language. Hydra can simulate the circuit, and machine language programs can run on both the emulator and the circuit.</p>
<p>This reference manual is organised by topic, with chapters on the architecture, the assembly language, and the emulator. However, it’s a good idea to begin with an overview of how the whole system works, and to be able to write and run simple programs, before delving into the details. For a quick start, begin with the tutorials, which show you how to enter and run a program, and how to use the programming environment.</p>
<h2 id="tutorial">Tutorial</h2>
<p>These short and simple tutorials show you how to use the system. You can keep the tutorials visible in the right panel while following along with the exercises in the main panel.</p>
<h3 id="the-user-interface">The user interface</h3>
<p><em>Topics:</em> components of the user interface, adjusting size of the user guide, the tabs for switching among the working areas</p>
<p>Let’s start by looking at the different parts of the user interface. The main window contains three main sections. The largest area, on the left side, is the <em>main working area</em>. When the program launches, this will show the Welcome pane. The <em>user guide</em> is on the right side. At the top is a row of buttons (Welcome, Examples, …). These select which page is displayed in the main working area.</p>
<p>You can adjust how much space is used for the working area and the user guide by clicking the arrow buttons on the right side of the button row. These move the boundary between the two areas left or right. If you reisze the window, the relative sizes of the working area and the user guide will remain the same.</p>
<h3 id="r-running-a-simple-program">R running a simple program</h3>
<p><em>Topics:</em> steps for running a program, registers, constants and addition</p>
<h2 id="tutorial-run-an-example-program">Tutorial: Run an example program</h2>
<p>A good way to get started is to go through the entire process of entering a simple program, assembling it, and running it. This section shows you how. For now, we focus just on how to use the software tools; an explanation of the Sigma16 architecture comes later.</p>
<p>When you launch the application, a window will appear in your browser. It has several panes, with buttons at the top to switch between panes. The Welcome pane will be visible.</p>
<ul>
<li><p>Click <strong>Editor</strong> to show the Editor Pane. <em>(You can edit code here or use an external text editor and copy/paste text into the editor.)</em></p></li>
<li><p>Click <strong>Example</strong> to load a simple example program.</p></li>
<li><p>Click the <strong>Assembler</strong> tab. The assembler page is where you translate a program from assembly language to machine language.</p></li>
<li><p>Click the <strong>Assemble</strong> button. The assembly listing, showing the translation to machine language, will appear. This example program doesn’t produce any error messages, so we can move on.</p></li>
<li><p>For this simple example, we don’t need the Linker, so you can skip it. <em>(The linker is needed for programs with multiple modules, or with external references, or that need relocation.)</em></p></li>
<li><p>Click the <strong>Processor</strong> tab, which shows the main components of the processor. This is where you can run programs using the emulator. The state of the processor is displayed as it runs your program, and the assembly listing is shown below, to help you follow the execution of the program.</p></li>
<li><p>Click <strong>Boot</strong>. This reads the machine language program into the memory, and you can see it in the Memory display. There are two independent views into the memory; this is convenient for looking at the machine language code in one view and the data in the other view. (Despite the two views, there is just one memory!) At this point the pc register contains 0, meaning that the next instruction to be executed is the one in memory location 0. The ir and other registers also contain 0, but that is just the initial value.</p></li>
<li><p>Click <strong>Step</strong>. The emulator executes a single instruction and displays the effects on the registers and memory: blue for using a value, and red for modifying it.</p></li>
<li><p>Click Step repeatedly to watch the program execute, instruction by instruction.</p></li>
<li><p>To rerun the program, click Boot again.</p></li>
<li><p>To run the program slowly, click <strong>Run Display</strong>, which is similar to clicking Step repeatedly. To run the program faster but without updating the display after each instruction, click Run. At any time you can click Pause to stop the processor, and you can resume execution with any of Step, Slow, or Run.</p></li>
<li><p>To set a breakpoint, click Breakpoint and enter the stopping condition in the dialogue box. For example, to stop when the pc register becomes $01b7, enter BPeq BPpc (BPhex “01b7”). Then click Run, and the emulator will run at full speed until the pc reaches the specified value; then it will stop so you can examine the state of the machine.</p></li>
</ul>
<h2 id="using-the-user-interface">Using the user interface</h2>
<h3 id="editor">Editor</h3>
<h3 id="assembly-language">Assembly language</h3>
<p>Each line of source code is an assembly language statement. Each statement must appear on one line. Most statements specify code, either an instruction or some constant data. Some statements are full line comments. Other statements are directives, which control the behavior of the assembler but don’t generate any code.</p>
<p>A statement may contain several fields. A field consists of non-space characters (with one exception: a space may appear in a string literal). Fields are separated from each other by one or more white space characters.</p>
<ul>
<li><p>Label. The label field is optional; if it appears, it must begin in the first character of the line. The label field, if present, must be a name.</p></li>
<li><p>Operation. The operation field specifies an instruction or assembler directive. It must be preceded by one or more white space characters. Every statement (apart from a full line comment) must have an operation field, which must be a name.</p></li>
<li><p>Operands. The operands field specifies operands for an instruction or arguments for assembly directive. All instructions have an operand field, and some assembler directives do.</p></li>
<li><p>Comment. All text that follows white space after the operands field is a comment, and is ignored by the assembler. If one or more of the other fields (label, operation, operands) is missing, the comment must be preceded by a semicolon (to prevent it from being interpreted as operands). The rule is: all text after a semicolon is a comment, and all text after white space following operands is a comment. A statement where the first non-space character is a semicolon is a full line comment.</p></li>
</ul>
<p>A name must begin with a letter (a-z or A-Z), and may contain letters, digits, or underscore characters.</p>
<h3 id="processor">Processor</h3>
<h1 id="programs-modules-and-files">Programs, modules, and files</h1>
<p>The system is designed to allow programs that consist of several modules, but also to allow programs consisting of one standalone module. In addition, an aim is to do this simply and intuitively, so that you can ignore the issues of modules and linking if you just want to write a andalone program.</p>
<p>There is a standard convention for file names. If, for example, you have a program named MyProgram, then the files associated with it should be as follows:</p>
<pre><code>-----------------  -----------
module name        MyProgram
source file        MyProgram.asm.txt
object file        MyProgram.obj.txt
assembly listing   MyProgram.lst.txt
-----------------  -----------</code></pre>
<h2 id="simple-standalone-programs">Simple standalone programs</h2>
<p>If a program does not import any names, it is <em>standalone</em>. The text of the program is shown in the editor pane. Go to the Assembler pane and click Assemble. If there are no errors, go directly to the Processor pane (you can skip the Linker) and click Boot. This will read the machine language into the memory, and now you can run the program.</p>
<h2 id="programs-with-multiple-modules">Programs with multiple modules</h2>
<p>A module consists of program text, and it may have an optional file, and an optional module name.</p>
<ul>
<li><p>The module text is a sequence of assembly language statements. The text may exist only in the editor buffer, or it may be associated with a file.</p></li>
<li><p>If there is a file, this may be specified either as a path (the unique identification of the file (C:\Users....asm.txt), or as just a filename (myprogram.asm.txt) which is relative to the current directory.</p></li>
</ul>
<p>To edit a file, the modDir and modName are both optional. An edited file may have a module name specified with a module statement. To read or save a file, both the module directory and name must be known.</p>
<p>Editor operations on files and modules</p>
<p>Each operation that changes the editor buffer (New, Open, Close) checks first to see whehter the buffer has been changed since it was last saved. If so, a dialogue asks whether the file should be saved.</p>
<ul>
<li><p>New – Check whether text in the editor buffer has been saved; if not, ask whether to save it. Create a new module with empty text and no file name, add it to the module set, and select it as the current module. Clear the text in the editor buffer.</p></li>
<li><p>Open – Check whether text in the editor buffer has been saved; if not, ask whether to save it. Enter the open file dialogue where an existing file can be found by navigation or by typing in its name. If the dialogue is cancelled, the module set and editor buffer are left unchanged. If a file is selected in the dialogue, and it is already in the module set, then it is selected in the current module. Otherwise, a new module is created with the file’s contents, and is selected as the current module. and The file is loaded into the editor buffer and added to the module set.</p></li>
<li><p>Refresh – The file corresponding to the current module is read, and its contents are loaded into the editor buffer.</p></li>
<li><p>SaveAs – Enters the save file dialogue where the directory and file name can be chosen. The editor buffer is written into this file.</p></li>
<li><p>Save – Writes the editor buffer into the current file and directory. If either the module name or directory is not known, this reverts to a SaveAs.</p></li>
<li><p>Select – Opens a list of all modules; you can click one of them which is then set as the current module.</p></li>
<li><p>Close – Check whether text in the editor buffer has been saved; if not, ask whether to save it. The module is removed from the module set, and the editor buffer is cleared. The first module (module number 0) is selected as the current module, but if there is no module at all, an empty module is created and selected as current (in effect, if there is only one module and you close it, an automatic New is performed).</p></li>
<li><p>Example – Reads in a very simple example program and sets it as the current module. This is a standalone program; you can simply click Editor: Example, then Assembler: Assemble, then Processor: Boot, and run the program. This example is used in the first “getting started” tutorial. The example program is also available in the Examples directory, accessible through Editor: Open.</p></li>
</ul>
<p>Select is for switching among the existing modules, while New and Open are for introducing a new module.</p>
<h1 id="architecture-of-the-computer">Architecture of the computer</h1>
<p>An <em>instruction set architecture</em> is a precise specification of all aspects of a machine that are visible to a programmer. It includes a description of the registers, memory, data representations, and all the instructions, but does not include components of the implementation that are not visible to a machine language programmer.</p>
<h2 id="data-representation">Data representation</h2>
<p>Sigma16 is a 16-bit architecture, and every data value is a 16-bit word. Integers are represented in 16-bit two’s complement notation. The bits of a word are numbered from left to right, starting with 0. Thus the leftmost (most significant) bit of a word is bit 0, and the rightmost (least significant) is bit 15.</p>
<h2 id="register-file">Register file</h2>
<p>The <strong>register file</strong> is a set of 16 general registers that hold a 16 bit word. A register is referenced by a 4-bit binary number. In assembly language, we use the notations R0, R1, R2, …, R9, R10, R11, R12, R13, R14, R15 to refer to the registers.</p>
<p>One of the registers, R0, has a special property: it always contains the constant 0. It is legal to perform an instruction that attempts to load some other value into R0, but the register will still contain 0 after executing such an instruction. Such an instruction will simply have no lasting effect.</p>
<p>Apart from R0, all the instructions behave exactly the same way, at least as far as the hardware is concerned.</p>
<p>There are some programming conventions that use certain registers for special purposes. The hardware does not enforce, or even know about, these conventions, and you do not have to follow the conventions in programming. However, it is necessary to obey the conventions in order to use the standard software libraries in your program. See the section on Programming for a discussion of these standard usage conventions.</p>
<h2 id="control-registers">Control registers</h2>
<p>There are several <strong>program control registers</strong> that enable the processor to keep track of the state of the running program. These registers are rarely used directly by the machine language program, but they are essential for keeping track of the execution of the program, and some instructions use them directly.</p>
<ul>
<li><p>ir – instruction register (16-bit word)</p></li>
<li><p>pc – program counter (16-bit word)</p></li>
<li><p>adr – address register (16-bit word)</p></li>
<li><p>dat – data register (16-bit word)</p></li>
</ul>
<h2 id="condition-codes">Condition codes</h2>
<p>Several instructions produce status information: the result of a comparison, whether there was an overflow, etc. This information is automatically loaded into R15, which is the condition code register. The description of each instruction states whether R15 is modified, and what goes into it.</p>
<p>The bits in R15 are indexed from bit 0 (the least significant, or rightmost bit) to bit 15 (the most significant, or leftmost). The condition code bits that have specific meanings are called <em>flags</em>. The flags are defined to make the condition code easier to read in hex: comparison flags are in the rightmost hex digit, and the carry and overflow flags are in the hex digit to the left.</p>
<p>—- —- CvVL lEgG</p>
<table>
<caption>Condition code flags</caption>
<thead>
<tr class="header">
<th style="text-align: center;">Bit</th>
<th style="text-align: center;">Flag</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;"><strong>G</strong> &gt;</td>
<td style="text-align: left;">(or &gt;0) unsigned (binary)</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;"><strong>g</strong> &gt;</td>
<td style="text-align: left;">(or &gt;0) signed (two’s complement)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: center;"><strong>E</strong> =</td>
<td style="text-align: left;">(or =0) word, signed, unsigned</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;"><strong>l</strong> &lt;</td>
<td style="text-align: left;">(or &lt;0) signed (two’s complement)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: center;"><strong>L</strong> &lt;</td>
<td style="text-align: left;">(or &lt;0) unsigned (binary)</td>
</tr>
<tr class="even">
<td style="text-align: center;">5</td>
<td style="text-align: center;"><strong>V</strong> u</td>
<td style="text-align: left;">nsigned overflow (binary)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">6</td>
<td style="text-align: center;"><strong>v</strong> s</td>
<td style="text-align: left;">igned overflow (two’s complement)</td>
</tr>
<tr class="even">
<td style="text-align: center;">7</td>
<td style="text-align: center;"><strong>C</strong> c</td>
<td style="text-align: left;">arry propagation (binary)</td>
</tr>
</tbody>
</table>
<p>conditional jump</p>
<p>jumpc0 jump if cc bit is 0 jumpc1 jump if cc bit is 1</p>
<h2 id="processor-status-flags">Processor status flags</h2>
<p>The processor can be executing in several modes, which are determined by the <strong>system control registers</strong>.</p>
<ul>
<li><p>ie – interrupts enabled (1-bit flag)</p></li>
<li><p>sys – system state (1-bit flag)</p></li>
</ul>
<h2 id="memory">Memory</h2>
<p>The memory is a hardware array of words that are accessed by address. A memory address is 16 bits wide, and there is one memory location corresponding to each address, so there are 2^16 = 64k memory locations. Each memory location is a 16-bit word.</p>
<h2 id="exceptions">Exceptions</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Location</th>
<th style="text-align: left;">Exception</th>
<th style="text-align: left;">Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: left;">Trap</td>
<td style="text-align: left;">Trap</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: left;">Overflow</td>
<td style="text-align: left;">Trap</td>
</tr>
<tr class="odd">
<td style="text-align: center;">2</td>
<td style="text-align: left;">Div0</td>
<td style="text-align: left;">Trap</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: left;">SegFault</td>
<td style="text-align: left;">Trap</td>
</tr>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: left;">Privilege</td>
<td style="text-align: left;">Trap</td>
</tr>
<tr class="even">
<td style="text-align: center;">5</td>
<td style="text-align: left;">Timer</td>
<td style="text-align: left;">Interrupt</td>
</tr>
<tr class="odd">
<td style="text-align: center;">6</td>
<td style="text-align: left;">Input</td>
<td style="text-align: left;">Interrupt</td>
</tr>
<tr class="even">
<td style="text-align: center;">7</td>
<td style="text-align: left;">Output</td>
<td style="text-align: left;">Interrupt</td>
</tr>
</tbody>
</table>
<p>Sigma16 is a load/store style architecture; that is, it does not combine memory accesses with arithmetic. All calculations are carried out in the register file, and explicit load and store instructions must be used to copy data between the memory and the register file.</p>
<h2 id="instruction-formats">Instruction formats</h2>
<p>There are three instruction formats:</p>
<ul>
<li><p>RRR – (1 word) Instructions that perform operations on data in registers, but not referring to memory.</p></li>
<li><p>RX – (2 words) Instructions that specify a memory location, as well as a register operand.</p></li>
<li><p>EXP – (2 words) Expanded instructions, for instructions that cannot be encoded as RRR or RX.</p></li>
</ul>
<p>The first word of an instruction contains four 4-bit fields, named op (bits 0-3), d (bits 4-7), sa (bits 8-11), and sb (bits 12-15).</p>
<p>Each instruction has a 4-bit field called the opcode (op for short). This gives 16 values of the opcode: 14 of them denote the 14 RRR instructions, while two of these values indicate that the instruction is either RX or EXP format, and there is then a secondary opcode in the sb field</p>
<p>Expanding opcodes</p>
<pre><code>        e     EXP format
        f     RX format</code></pre>
<h3 id="rrr-format">RRR format</h3>
<p>An RRR instruction contains an operation code (op), and specifies three operands registers using the d, sa, and sb fields. It is represented as one word, which is divided into four fields:</p>
<ul>
<li>op (4 bits, starting from bit 0) Operation code</li>
<li>d (4 bits, starting from bit 4) Destination register</li>
<li>sa (4 bits, starting from bit 8) Source a register</li>
<li>sb (4 bits, starting from bit 12) Source b register</li>
</ul>
<p>The op field of an RRR instruction must be in the range from 0 through 13 (hex 0 through d). This allows for a total of 14 distinct RRR instructions. If the op field is outside this range, it indicates an “expanding opcode”: 14 (hex e) indicates the EXP format, and 15 (hex f) indicates the RX format.</p>
<p>A typical example of an RRR instruction is add R4,R9,R2, which adds the contenst of registers R9 and R2, and loads the result into R4. It’s equivalent to R4 := R9 + R2.</p>
<h3 id="rx-format">RX format</h3>
<p>The RX instruction format is used for instructions that use a memory address, which is specified by an index register and a displacement. The name of the format describes briefly the two operands: a register (R) and an indexed memory address (X).</p>
<p>An RX instruction contains two operands: one is a memory address, and the other is a register. Typical RX instructions are loads, stores, and jumps. The instruction consists of two consecutive words. The first has the same format as an RRR instruction, with four fields: op, d, sa, sb. The second word is a single 16-bit binary number, and is called the displacement.</p>
<p>The memory address is specified in two parts: an index register and the displacement. The index register is specified in the sa field. In assembly language, the notation used is number[reg], where the number is the value of the displacement, and the reg is the index register. Thus $20b3[R2] means the address has displacement $20b3 and the index register is R2.</p>
<p>When the machine executes an RX instruction, it begins by calculating the effective address. This is abbreviated “ea”, and its value is the sum of the displacement and the contents of the index register.</p>
<p>RX instructions are represented in two words, and they use an “expanding opcode”. That is, the op field of the first word of the instruction contains the constant f (the bits 1111) for every RX instruction, and the sb field is used to hold a secondary opcode indicating which RX instruction it is.</p>
<p>The register operand is specified in the d field. For several RX instructions, this is indeed the destination of the instruction: for example, load places data into Rd. However, a few RX instructions use the d field differently (see, for example, the conditional jump instructions).</p>
<p>The memory address is specified using the sa field and the displacement, which is the entire second word of the instruction.</p>
<ul>
<li>op field (bits 0-3 of ir) is f for all RX instructions</li>
<li>d field (bits 4-7 of ir) has several uses</li>
<li>a field (bits 8-11 of ir) is index register for effective address</li>
<li>b field (bits 12-15 of ir) is secondary opcode</li>
<li>disp (displacement) is the second word of the instruction</li>
<li>ea (effective address) = displacement + r[a]</li>
</ul>
<h3 id="exp-format">EXP format</h3>
<p>The EXP instruction format is used for expanded instructions cannot be represented using the RRR or RX formats. It provides many unused opcodes, so it is useful for experimental instructions.</p>
<p>An EXP instruction consists of two words. The first word has a constant hex e in the op field, which indicates the EXP format. The a and b fields together form an 8-bit secondary opcode, allowing for 256 distinct EXP instructions. The d field in the first word, and all of the second word, hold operands which depend on the particular instruction.</p>
<h1 id="instruction-set">Instruction set</h1>
<h2 id="arithmetic">Arithmetic</h2>
<h3 id="add">add</h3>
<p>add. The two operands are fetched from registers, added, and the sum is loaded into the destination register.</p>
<p>The following table shows the complete instruction set. The instructions are in order of increasing operation code.</p>
<h3 id="mul-multiply-signed-integers">mul (multiply signed integers)</h3>
<h2 id="memory-instructions">Memory instructions</h2>
<p>The effective address is defined to be the binary sum of the displacement and the index register.</p>
<h3 id="load">load</h3>
<p>Load copies the word in memory at the effective address into the destination register.</p>
<p>general form: load Rd,disp[Ra]</p>
<p>effect: reg[Rd] := mem[disp+reg[Ra]]</p>
<p>format: RX</p>
<pre><code>   load  R12,count[R0]   ; R12 := count
   load  R6,arrayX[R2]   ; R6 := arrayX[R2]
   load  R3,$2b8e[R5]    ; R3 := mem[2b8e+R5]</code></pre>
<h3 id="store">store</h3>
<p>Store copies the word in the destination register into memory at the effective address. Unlike most instructions, store treats the “destination register” as the source of data, and the actual destination is the memory location.</p>
<p>general form: store Rd,disp[Ra] effect: mem[disp+reg[Ra]] := reg[Rd] format: RX</p>
<pre><code>   store  R3,$2b8e[R5]
   store  R12,count[R0]
   store  R6,arrayX[R2]</code></pre>
<h2 id="control">Control</h2>
<p>The effective address is defined to be the binary sum of the displacement and the index register.</p>
<h2 id="summary-of-the-instruction-set">Summary of the instruction set</h2>
<hr />
<table style="width:67%;">
<colgroup>
<col style="width: 12%" />
<col style="width: 9%" />
<col style="width: 6%" />
<col style="width: 9%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr class="header">
<th>Mnemonic</th>
<th>Format</th>
<th style="text-align: left;">Op</th>
<th>Notes</th>
<th style="text-align: left;">Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>add</td>
<td>RRR</td>
<td style="text-align: left;">0</td>
<td>E</td>
<td style="text-align: left;">r[d] := r[a] + r[b] signed +</td>
</tr>
<tr class="even">
<td>sub</td>
<td>RRR</td>
<td style="text-align: left;">1</td>
<td>E</td>
<td style="text-align: left;">r[d] := r[a] - r[b] signed -</td>
</tr>
<tr class="odd">
<td>mul</td>
<td>RRR</td>
<td style="text-align: left;">2</td>
<td></td>
<td style="text-align: left;">rem#r[d] := r[a] * r[b] signed *</td>
</tr>
<tr class="even">
<td>div</td>
<td>RRR</td>
<td style="text-align: left;">3</td>
<td>E</td>
<td style="text-align: left;">r[d] := r[a] div r[b], R15 := r[a] rem r[b]</td>
</tr>
<tr class="odd">
<td>cmplt</td>
<td>RRR</td>
<td style="text-align: left;">4</td>
<td></td>
<td style="text-align: left;">r[d] := r[a] &lt; r[b]</td>
</tr>
<tr class="even">
<td>cmpeq</td>
<td>RRR</td>
<td style="text-align: left;">5</td>
<td></td>
<td style="text-align: left;">r[d] := r[a] = r[b]</td>
</tr>
<tr class="odd">
<td>cmpgt</td>
<td>RRR</td>
<td style="text-align: left;">6</td>
<td></td>
<td style="text-align: left;">r[d] := r[a] &gt; r[b]</td>
</tr>
<tr class="even">
<td>cmp</td>
<td>RRR</td>
<td style="text-align: left;">7</td>
<td></td>
<td style="text-align: left;">R15 := comparison result (both signed, unsigned)</td>
</tr>
<tr class="odd">
<td>inv</td>
<td>RRR</td>
<td style="text-align: left;">8</td>
<td></td>
<td style="text-align: left;">r[d] := inv r[a]</td>
</tr>
<tr class="even">
<td>and</td>
<td>RRR</td>
<td style="text-align: left;">9</td>
<td></td>
<td style="text-align: left;">r[d] := r[a] and r[b]</td>
</tr>
<tr class="odd">
<td>or</td>
<td>RRR</td>
<td style="text-align: left;">a</td>
<td></td>
<td style="text-align: left;">r[d] := r[a] or r[b]</td>
</tr>
<tr class="even">
<td>xor</td>
<td>RRR</td>
<td style="text-align: left;">b</td>
<td></td>
<td style="text-align: left;">r[d] := r[a] xor r[b]</td>
</tr>
<tr class="odd">
<td></td>
<td>RRR c</td>
<td style="text-align: left;"></td>
<td></td>
<td style="text-align: left;">reserved; currently nop</td>
</tr>
<tr class="even">
<td>trap</td>
<td>RRR</td>
<td style="text-align: left;">d</td>
<td>E</td>
<td style="text-align: left;">xa := pc, pc := 0</td>
</tr>
<tr class="odd">
<td>lea</td>
<td>RX</td>
<td style="text-align: left;">f,0</td>
<td></td>
<td style="text-align: left;">r[d] := ea</td>
</tr>
<tr class="even">
<td>load</td>
<td>RX</td>
<td style="text-align: left;">f,1</td>
<td>E</td>
<td style="text-align: left;">r[d] := m[ea]</td>
</tr>
<tr class="odd">
<td>store</td>
<td>RX</td>
<td style="text-align: left;">f,2</td>
<td>E</td>
<td style="text-align: left;">m[ea] := r[d]</td>
</tr>
<tr class="even">
<td>jump</td>
<td>RX</td>
<td style="text-align: left;">f,3</td>
<td>E</td>
<td style="text-align: left;">pc := ea</td>
</tr>
<tr class="odd">
<td>jumpc0</td>
<td>RX</td>
<td style="text-align: left;">f,4</td>
<td></td>
<td style="text-align: left;">if r[15] AND d == 0 then pc := ea</td>
</tr>
<tr class="even">
<td>jumpc1</td>
<td>RX</td>
<td style="text-align: left;">f,5</td>
<td></td>
<td style="text-align: left;">if r[R15] AND d /= 0 then pc := ea</td>
</tr>
<tr class="odd">
<td>jumpf</td>
<td>RX</td>
<td style="text-align: left;">f,6</td>
<td>E</td>
<td style="text-align: left;">if not r[d] then pc := ea</td>
</tr>
<tr class="even">
<td>jumpt</td>
<td>RX</td>
<td style="text-align: left;">f,7</td>
<td>E</td>
<td style="text-align: left;">if r[d] then pc := ea</td>
</tr>
<tr class="odd">
<td>jal</td>
<td>RX</td>
<td style="text-align: left;">f,8</td>
<td>E</td>
<td style="text-align: left;">r[d] := pc, pc := ea</td>
</tr>
<tr class="even">
<td>inv</td>
<td>RRR</td>
<td style="text-align: left;">7</td>
<td></td>
<td style="text-align: left;">r[d] := inv r[a]</td>
</tr>
<tr class="odd">
<td>and</td>
<td>RRR</td>
<td style="text-align: left;">8</td>
<td></td>
<td style="text-align: left;">r[d] := r[a] and r[b]</td>
</tr>
<tr class="even">
<td>or</td>
<td>RRR</td>
<td style="text-align: left;">9</td>
<td></td>
<td style="text-align: left;">r[d] := r[a] or r[b]</td>
</tr>
<tr class="odd">
<td>xor</td>
<td>RRR</td>
<td style="text-align: left;">a</td>
<td></td>
<td style="text-align: left;">r[d] := r[a] xor r[b]</td>
</tr>
<tr class="even">
<td>trap</td>
<td>RRR</td>
<td style="text-align: left;">d</td>
<td>E</td>
<td style="text-align: left;">xa := pc, pc := 0</td>
</tr>
<tr class="odd">
<td>lea</td>
<td>RX</td>
<td style="text-align: left;">f,0</td>
<td></td>
<td style="text-align: left;">r[d] := ea</td>
</tr>
<tr class="even">
<td>load</td>
<td>RX</td>
<td style="text-align: left;">f,1</td>
<td>E</td>
<td style="text-align: left;">r[d] := m[ea]</td>
</tr>
<tr class="odd">
<td>store</td>
<td>RX</td>
<td style="text-align: left;">f,2</td>
<td>E</td>
<td style="text-align: left;">m[ea] := r[d]</td>
</tr>
<tr class="even">
<td>jump</td>
<td>RX</td>
<td style="text-align: left;">f,3</td>
<td>E</td>
<td style="text-align: left;">pc := ea</td>
</tr>
<tr class="odd">
<td>jumpf</td>
<td>RX</td>
<td style="text-align: left;">f,4</td>
<td>E</td>
<td style="text-align: left;">if not r[d] then pc := ea</td>
</tr>
<tr class="even">
<td>jumpt</td>
<td>RX</td>
<td style="text-align: left;">f,5</td>
<td>E</td>
<td style="text-align: left;">if r[d] then pc := ea</td>
</tr>
<tr class="odd">
<td>jal</td>
<td>RX</td>
<td style="text-align: left;">f,6</td>
<td>E</td>
<td style="text-align: left;">r[d] := pc, pc := ea</td>
</tr>
<tr class="even">
<td>test</td>
<td>EXP</td>
<td style="text-align: left;"></td>
<td></td>
<td style="text-align: left;">r[d] := r[a] [bit b]</td>
</tr>
<tr class="odd">
<td>inton</td>
<td>EXP</td>
<td style="text-align: left;"></td>
<td>P</td>
<td style="text-align: left;">ie := 1</td>
</tr>
<tr class="even">
<td>intoff</td>
<td>EXP</td>
<td style="text-align: left;"></td>
<td>P</td>
<td style="text-align: left;">ie := 0</td>
</tr>
<tr class="odd">
<td>sysoff</td>
<td>EXP</td>
<td style="text-align: left;"></td>
<td>P</td>
<td style="text-align: left;">sys := 0</td>
</tr>
<tr class="even">
<td>getrem</td>
<td>EXP</td>
<td style="text-align: left;">e,00</td>
<td></td>
<td style="text-align: left;">r[d] := rem</td>
</tr>
<tr class="odd">
<td>putrem</td>
<td>EXP</td>
<td style="text-align: left;">e,01</td>
<td></td>
<td style="text-align: left;">rem := r[d]</td>
</tr>
<tr class="even">
<td>getcsa</td>
<td>EXP</td>
<td style="text-align: left;">e,02</td>
<td>P</td>
<td style="text-align: left;">r[d] := csa</td>
</tr>
<tr class="odd">
<td>putcsa</td>
<td>EXP</td>
<td style="text-align: left;">e,03</td>
<td>P</td>
<td style="text-align: left;">csa := r[d]</td>
</tr>
<tr class="even">
<td>getcsl</td>
<td>EXP</td>
<td style="text-align: left;">e,04</td>
<td>P</td>
<td style="text-align: left;">r[d] := csl</td>
</tr>
<tr class="odd">
<td>putcsl</td>
<td>EXP</td>
<td style="text-align: left;">e,05</td>
<td>P</td>
<td style="text-align: left;">csl := r[d]</td>
</tr>
<tr class="even">
<td>getdsa</td>
<td>EXP</td>
<td style="text-align: left;">e,06</td>
<td>P</td>
<td style="text-align: left;">r[d] := dsa</td>
</tr>
<tr class="odd">
<td>putdsa</td>
<td>EXP</td>
<td style="text-align: left;">e,07</td>
<td>P</td>
<td style="text-align: left;">dsa := r[d]</td>
</tr>
<tr class="even">
<td>getdsl</td>
<td>EXP</td>
<td style="text-align: left;">e,08</td>
<td>P</td>
<td style="text-align: left;">r[d] := dsl</td>
</tr>
<tr class="odd">
<td>putdsl</td>
<td>EXP</td>
<td style="text-align: left;">e,09</td>
<td>P</td>
<td style="text-align: left;">dsl := r[d]</td>
</tr>
<tr class="even">
<td>addl</td>
<td>EXP</td>
<td style="text-align: left;">e,0a</td>
<td></td>
<td style="text-align: left;">rem#r[d] := r[a] + r[b] + lsb rem</td>
</tr>
<tr class="odd">
<td>subl shiftl</td>
<td>EXP RRR</td>
<td style="text-align: left;">e,0b b</td>
<td></td>
<td style="text-align: left;">rem#r[d] := r[a] - r[b] + slb rem rem#r[d] := r[a] shl b</td>
</tr>
<tr class="even">
<td>shiftr</td>
<td>RRR</td>
<td style="text-align: left;">c</td>
<td></td>
<td style="text-align: left;">rem#r[d] := r[a] shr b</td>
</tr>
<tr class="odd">
<td>inton</td>
<td>EXP</td>
<td style="text-align: left;"></td>
<td>P</td>
<td style="text-align: left;">ie := 1</td>
</tr>
<tr class="even">
<td>intoff</td>
<td>EXP</td>
<td style="text-align: left;"></td>
<td>P</td>
<td style="text-align: left;">ie := 0</td>
</tr>
<tr class="odd">
<td>sysoff</td>
<td>EXP</td>
<td style="text-align: left;"></td>
<td>P</td>
<td style="text-align: left;">sys := 0</td>
</tr>
<tr class="even">
<td>getrem</td>
<td>EXP</td>
<td style="text-align: left;">e,00</td>
<td></td>
<td style="text-align: left;">r[d] := rem</td>
</tr>
<tr class="odd">
<td>putrem</td>
<td>EXP</td>
<td style="text-align: left;">e,01</td>
<td></td>
<td style="text-align: left;">rem := r[d]</td>
</tr>
<tr class="even">
<td>getcsa</td>
<td>EXP</td>
<td style="text-align: left;">e,02</td>
<td>P</td>
<td style="text-align: left;">r[d] := csa</td>
</tr>
<tr class="odd">
<td>putcsa</td>
<td>EXP</td>
<td style="text-align: left;">e,03</td>
<td>P</td>
<td style="text-align: left;">csa := r[d]</td>
</tr>
<tr class="even">
<td>getcsl</td>
<td>EXP</td>
<td style="text-align: left;">e,04</td>
<td>P</td>
<td style="text-align: left;">r[d] := csl</td>
</tr>
<tr class="odd">
<td>putcsl</td>
<td>EXP</td>
<td style="text-align: left;">e,05</td>
<td>P</td>
<td style="text-align: left;">csl := r[d]</td>
</tr>
<tr class="even">
<td>getdsa</td>
<td>EXP</td>
<td style="text-align: left;">e,06</td>
<td>P</td>
<td style="text-align: left;">r[d] := dsa</td>
</tr>
<tr class="odd">
<td>putdsa</td>
<td>EXP</td>
<td style="text-align: left;">e,07</td>
<td>P</td>
<td style="text-align: left;">dsa := r[d]</td>
</tr>
<tr class="even">
<td>getdsl</td>
<td>EXP</td>
<td style="text-align: left;">e,08</td>
<td>P</td>
<td style="text-align: left;">r[d] := dsl</td>
</tr>
<tr class="odd">
<td>putdsl</td>
<td>EXP</td>
<td style="text-align: left;">e,09</td>
<td>P</td>
<td style="text-align: left;">dsl := r[d]</td>
</tr>
<tr class="even">
<td>addl</td>
<td>EXP</td>
<td style="text-align: left;">e,0a</td>
<td></td>
<td style="text-align: left;">rem#r[d] := r[a] + r[b] + lsb rem</td>
</tr>
<tr class="odd">
<td>subl</td>
<td>EXP</td>
<td style="text-align: left;">e,0b</td>
<td></td>
<td style="text-align: left;">rem#r[d] := r[a] - r[b] + slb rem</td>
</tr>
<tr class="even">
<td>test</td>
<td>RRR</td>
<td style="text-align: left;">c</td>
<td></td>
<td style="text-align: left;">r[d] := r[a] [bit b]</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="assembly-language-1">Assembly Language</h1>
<p>An assembly language provides a reasonably readable notation for writing machine language programs. An instruction in machine language is just one or more words (often written in hexadecimal notation), while the corresponding instruction in assembly language uses mnemonic names so the programmer doesn’t have to memorise all the operation codes, addresses of variables, and so on. However, the assembly language still gives the programmer complete control over a program, down to the last bit.</p>
<p>Computer hardware executes machine language, which is hard for humans to read because it consists entirely of numbers. Assembly language is a way of expressing a machine language program in a readable way. It uses names for instructions and variables, as well as other notations to make the code easier to understand.</p>
<h2 id="notation">Notation</h2>
<p>Constants can be written in decimal, hexadecimal, or binary.</p>
<ul>
<li><p>Decimal constants consist of a sequence of digits, with an optional leading - sign. Examples: 42 55039 -1</p></li>
<li><p>Hexadecimal constants are written with a dollar sign $ followed by four hex digits (0 1 2 3 4 5 6 7 8 9 a b c d e f). Examples: $0249 $c78a</p></li>
<li><p>Binary constants are written with a hash sign # followed by any number of 0 or 1 characters. You can write fewer than 16 bits; they will be padded on the left with zeros. Examples: #1101 #000100000001101</p></li>
</ul>
<h2 id="assembly-instruction-fields">Assembly instruction fields</h2>
<p>An assembly language statement consists of three fields. A field is a string of non-space characters, and fields must be separated by spaces. The fields are:</p>
<ul>
<li><p>Label. This field is optional: if there is a label, it must begin in the first character of a line. If the first character is a space, then that line has no label. A label is similar to a variable name in a programming language. It must begin with a letter, and may contain letters, digits, and underscore characters.</p></li>
<li><p>Operation. This is the first field that appears after white space in the statement. The operation is the name of an instruction.</p></li>
<li><p>Operands. This field specifies the registers and memory addresses used by an instruction.</p></li>
<li><p>Comment. Everything on a line after a semicolon character is a comment, and is ignored by the assembler.</p></li>
</ul>
<h2 id="expressions">Expressions</h2>
<p>An expression denotes a 16-bit word. Usually they are used to specify a word of machine language, either an address or a data constant.</p>
<p>Syntax of expressions</p>
<h2 id="assembly-language-statements">Assembly language statements</h2>
<h3 id="instructions">Instructions</h3>
<h3 id="directives">Directives</h3>
<p>A directive is a statement that doesn’t generate an instruction, but which gives further information about how to translate the program to object code.</p>
<h4 id="module-statement">Module statement</h4>
<pre><code>modname   module</code></pre>
<p>The module statement, if present, declares the name of the module. It must be the first statement in the program, apart from full line comments and blank lines. A file may contain only one module statement, and if the statement “foo module” is present the file name should be foo.asm.txt.</p>
<p>Examples</p>
<pre><code>quicksort module
main      module
myprog    module</code></pre>
<p>name import export name</p>
<h2 id="object-language-statements">Object language statements</h2>
<p>hex4 means a 4-digit hexadecimal constant, such as 3b9f.</p>
<p>name means an identifier, beginning with a letter and comprising letters, digits, _</p>
<p>org hex4 set location counter data hex4 … hex4 load words, incrementing loc counter relocate hex4 add relocation to word at address external name insert value of external name</p>
<h2 id="assembly-listing">Assembly listing</h2>
<p>The first section of the assembly listing shows each line of the source program. The line number appears first, followed by the memory address that the instruction on this line will be placed in. The address is given as a 4 digit hexadecimal number, and it is binary (not two’s complement). Next comes the machine language code generated by the line of source code. If the line contains a two-word instruction, there will be two 4-digit hexadecimal values; for a one-word instruction there will be one hex number, and if the line doesn’t produce any code these fields will be blank. After the code, the original source statement appears.</p>
<p>The second section of the assembly listing is the <em>Symbol Table</em>. This shows each identifier (or “symbol”) that appears in the program, the address allocated for the symbol, the source code line where it was defined, and the source code lines where it was used.</p>
<h1 id="linker">Linker</h1>
<p>The linker is not implemented in this version of the application.</p>
<h1 id="programming-the-sigma16-architecture">Programming the Sigma16 architecture</h1>
<p>Coming soon.</p>
<h1 id="using-the-graphical-user-interface">Using the graphical user interface</h1>
<p>Coming soon</p>
<h1 id="about-the-software">About the software</h1>
<p>Sigma16 is built using the Haskell programming language and the Hydra hardware description language. The documentation is written in markdown and prepared for a web browser using pandoc.</p>
<ul>
<li><a href="file:README.html">README</a></li>
<li><a href="file:LICENSE.html">LICENSE</a></li>
<li><a href="file:LICENSE_GPL3.html">Full text of GPL3 license</a></li>
</ul>
<h2 id="changes-underway">Changes underway</h2>
<p>Support relocatable code</p>
<ul>
<li>Change jump, jumpt, jumpf, jal to use pc-relative addressing</li>
<li>Introduce a jalext that uses indexed absolute address, for external</li>
</ul>
<p>User flags register</p>
<ul>
<li>Carry output</li>
<li>Overflow</li>
<li>Carry input</li>
</ul>
<p>System flags register * System status * Interrupts enabled</p>
<p>Arithmetic Add/subtract with carry</p>
<p>Input/Output dma channels Ready Ack</p>
<h1 id="installation">Installation</h1>
<h2 id="license">License</h2>
<p>This is free and open source software and is distributed under the GPL License, either version 3 or (at your option) any later version. See the LICENSE and LICENSE_GPL3 files. This program is experimental software, and is under development.</p>
<h2 id="browser-compatibility">Browser compatibility</h2>
<p>The application currently works with Chrome and Firefox, and possible Edge.</p>
<h2 id="how-to-run-the-application">How to run the application</h2>
<p>The program uses a web browser to display the graphical user interface.</p>
<h2 id="how-to-run-the-program">How to run the program</h2>
<p>The software is available on the Internet at the <a href="https://jtod.github.io/Sigma16/">Sigma16 home page</a>, which contains a link to the latest version, some previous versions, related documents, and more information about the project.</p>
<p>There are a number of ways to run the software, but it’s recommended that you try the easiest way.</p>
<h3 id="the-easiest-and-recommended-way-just-click-a-link">The easiest (and recommended) way: just click a link</h3>
<p>Run the app with two clicks:</p>
<ol type="1">
<li>Visit the <a href="https://jtod.github.io/Sigma16/index.html">Sigma16 homepage</a></li>
<li>Click on <em>Launch the latest release</em></li>
</ol>
<p>This will run the app in your browser, and you don’t need to download or install anything. For most users this is the recommended method.</p>
<h3 id="if-you-dont-always-have-internet-access-copy-to-your-computer">If you don’t always have Internet access: copy to your computer</h3>
<p>You can also download the software onto your computer and run it locally. This exactly like the first method, except the web pages are coming from your computer’s files rather than the Internet.</p>
<p>Visit the <a href="https://jtod.github.io/Sigma16/index.html">Sigma16 home page</a> and download the zip file for the latest release. Unzip and click on index.html in the folder and follow the directions.</p>
<p>You might also be able to launch it by <a href="../../Sigma16.html">clicking this link</a> although that might not work; it depends on whether all the necessary files are accessible.</p>
<h3 id="offers-enhanced-file-access-local-installation">Offers enhanced file access: Local installation</h3>
<p>The previous methods run the app in a browser. There are some security restrictions on what a browser can do, and these make it slightly awkward for the program to read and write files. You can perform a local installation which will run Sigma16 as a standalone app on your computer, rather than in a browser, and this makes it a little more convenient to use.</p>
<p>If you don’t want to bother with downloading some software tools and running an installation script, you can skip to the next method, which is to download a precompiled executable for your platform. But it’s straightforward to build Sigma16 on your computer:</p>
<ul>
<li><p>You need a shell such as bash or Windows PowerShell. Every computer will have one.</p></li>
<li><p>Install the npm package manager for JavaScript, available at <a href="https://www.npmjs.com/get-npm">https://www.npmjs.com/get-npm</a>. Download the installer and follow the instructions.</p></li>
<li><p>Install the <em>electron</em> package. In your shell, enter <em>npm install electron –save-dev</em>. (Why is it called “electron”? Originally, there was a text editor named <em>Atom</em> written in JavaScript, and it needed a shell. So it’s the electron shell for atom…</p></li>
<li><p>Download the source for Sigma16. Unzip it, and cd into the app directory. Enter <em>make all</em>.</p></li>
<li><p>To launch Sigma16, enter <em>npm run start</em>. Now you’ll have enhanced file access, as well as a few other minor enhancements, and you don’t need Internet access.</p></li>
</ul>
<h3 id="download-a-precompiled-executable-for-your-platform">Download a precompiled executable for your platform</h3>
<p>The Sigma16 home page provides pre-compiled executable apps for some platforms. You can download one of these and it should “just work”.</p>
<p>It is always prudent to be careful about what executable software you download and install on your computer. If you don’t feel comfortable with doing so, try the previous method (Local installation). It’s actually quite straightforward!</p>
<h3 id="making-a-release-on-github-pages">Making a release on github pages</h3>
<p>make a local directory for editing the project page on github pages. cd into this directory.</p>
<pre><code>git clone https://github.com/jtod/jtod.github.io
git add jtod.github.io
cd jtod.github.io
git branch adds16dir
git checkout adds16dir
git status
mkdir Sigma16
using emacs, create index.html and Sigma16/index.html</code></pre>
<p>To build a release, the necessary files in the current version need to be copied from the development directory into the web page directory in jtod.github.io/Sigma16. However, it doesn’t work very well simply to copy the contents of the Sigma16 development directory into the release directory because all the .gitignore files should be skipped. Consequently a script is used to automate the construction of a release, and the script will copy exactly the required files.</p>
<pre><code>git remote add webpage https://github.com/jtod/jtod.github.io
git remote
git status
git push webpage adds16dir         adds16dir is the local branch</code></pre>
<p>On github page, made a pull request and selected adds1dir. There were no merge conflicts and the pull request was executed and cleared. The home page seems to come from the README file but refreshing it gives my index.html.</p>
<p>To build standalone version using Node.hs and electron. In the src/app directory, use the following commands. They create a file package-lock.json and a directory node_modules, both in src/app.</p>
<pre><code>npm install
npm start</code></pre>
<p>The pkg program can generate a native executable which doesn’t require the user to have npm installed.</p>
<pre><code>npm install -g pkg 
pkg --help
pkg main.js</code></pre>
<p>Maybe the bin entry in package.json would allow the command to be just pkg . ? In src directory tried this:</p>
<pre><code>$ pkg  -t win-x64 app</code></pre>
<p>Lots of warnings:</p>
<pre><code>&gt; Warning Cannot include directory %1 into executable.
  The directory must be distributed with executable as %2.
  app\node_modules\electron\dist
  path-to-executable/electron/dist
&gt; Warning Cannot include file %1 into executable.
  The file must be distributed with executable as %2.
  app\node_modules\sliced\index.js
  path-to-executable/node_modules/sliced/index.js
&gt; Warning Cannot include file %1 into executable.
  The file must be distributed with executable as %2.
  app\node_modules\deep-defaults\lib\index.js
  path-to-executable/node_modules/deep-defaults/index.js</code></pre>
<p>Turns out that to build an app with electron one of the following specific tools is needed:</p>
<pre><code>electron-forge
electron-builder
electron-packager</code></pre>
<p>Trying electron-builder</p>
<pre><code>npm install electron-builder --save-dev   in src/app
npm run mkdist</code></pre>
<h3 id="version-number">Version number</h3>
<p>The version number is needed in several places. To keep it consistent, there is only one primary place where it should be specified manually: in the version property in app/package.json.</p>
<p>The makefile extracts the version number from that file, and (1) defines a make variable; (2) writes the Sigma16/VERSION file with just the version number, and (3) writes Sigma16/app/version.js which is just defines the version number as a global constant.</p>
<h3 id="running-in-a-browser.">Running in a browser.</h3>
<h3 id="running-a-standalone-pre-compiled-executable">Running a standalone pre-compiled executable</h3>
<h3 id="compiling-a-standalone-executable-requires-node.js-and-npm">Compiling a standalone executable; requires Node.js and npm</h3>
<pre><code>cd src
npm install
npm start

# Clone this repository
git clone https://github.com/electron/electron-quick-start
# Go into the repository
cd electron-quick-start
# Install dependencies
npm install
# Run the app
npm start</code></pre>
<h1 id="reference">Reference</h1>
<h2 id="summary-of-notation">Summary of notation</h2>
<p>ea m[ea] r[d] r[a] r[b] q#r[d] lsb q</p>
</body>
</html>
