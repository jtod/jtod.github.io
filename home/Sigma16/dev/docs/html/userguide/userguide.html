<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>User Guidefoobar!</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="userguidestyle.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">User Guide</h1>
</header>
Version 3.0.34
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#tutorials">Tutorials</a><ul>
<li><a href="#hello-world">Hello, world!</a></li>
<li><a href="#registers-and-arithmetic">Registers and arithmetic</a></li>
<li><a href="#keeping-variables-in-memory">Keeping variables in memory</a></li>
<li><a href="#assembly-language">Assembly language</a></li>
<li><a href="#compilation">Compilation</a></li>
<li><a href="#conditionals">Conditionals</a></li>
<li><a href="#loops">Loops</a></li>
<li><a href="#machine-language">Machine language</a><ul>
<li><a href="#representing-rrr-instructions">Representing RRR instructions</a></li>
<li><a href="#representing-rx-instructions">Representing RX instructions</a></li>
</ul></li>
<li><a href="#instruction-execution">Instruction execution</a></li>
<li><a href="#effective-addresses-and-arrays">Effective addresses and arrays</a><ul>
<li><a href="#address-arithmetic">Address arithmetic</a></li>
<li><a href="#why-r0">Why [R0]?</a></li>
<li><a href="#address-arithmetic-1">Address arithmetic</a></li>
<li><a href="#what-can-you-do-with-address-arithmetic">What can you do with address arithmetic?</a></li>
</ul></li>
<li><a href="#effective-addresses-and-arrays-1">Effective addresses and arrays</a><ul>
<li><a href="#representing-an-array">Representing an array</a></li>
</ul></li>
<li><a href="#array-traversal-and-for-loops">Array traversal and for loops</a><ul>
<li><a href="#high-level-algorithm">High level algorithm}</a></li>
</ul></li>
<li><a href="#procedures-call-and-return">Procedures: call and return</a></li>
<li><a href="#the-call-stack">The call stack</a><ul>
<li><a href="#variables">Variables</a></li>
<li><a href="#access-to-variables">Access to variables</a></li>
<li><a href="#three-classes-of-variable">Three classes of variable</a></li>
<li><a href="#static-variables">Static variables</a></li>
<li><a href="#combining-static-variables-with-code">Combining static variables with code</a></li>
<li><a href="#disadvantages-of-combining-variables-and-code">Disadvantages of combining variables and code</a></li>
<li><a href="#local-variables">Local variables</a></li>
<li><a href="#accessing-local-variables">Accessing local variables</a></li>
<li><a href="#dynamic-variables">Dynamic variables</a></li>
<li><a href="#the-heap">The Heap</a></li>
<li><a href="#the-call-stack-1">The call stack</a></li>
<li><a href="#simplest-stack-return-addresses">Simplest stack: return addresses</a></li>
<li><a href="#saved-registers">Saved registers</a></li>
<li><a href="#dynamic-links">Dynamic links</a></li>
<li><a href="#local-variables-1">Local variables</a></li>
<li><a href="#static-links-for-scoped-variables">Static links for scoped variables</a></li>
<li><a href="#accessing-a-word-in-the-stack-frame">Accessing a word in the stack frame</a></li>
<li><a href="#example-from-factorial-program-see-below">Example from factorial program (see below)</a></li>
<li><a href="#recursive-factorial">Recursive factorial</a></li>
<li><a href="#about-the-factorial-program">About the factorial program</a></li>
<li><a href="#statement-of-problem-and-register-usage">Statement of problem, and register usage</a></li>
<li><a href="#format-of-main-program-stack-frame">Format of main program stack frame</a></li>
<li><a href="#main-program-initialisation">Main program initialisation</a></li>
<li><a href="#main-program-calls-factorial">Main program calls factorial</a></li>
<li><a href="#main-program-finishes">Main program finishes</a></li>
<li><a href="#description-of-factorial-function">Description of factorial function</a></li>
<li><a href="#format-of-stack-frame-for-factorial">Format of stack frame for factorial</a></li>
<li><a href="#factorial-build-stack-frame">Factorial: build stack frame</a></li>
<li><a href="#factorial-check-for-base-or-recursion-case">Factorial: check for base or recursion case</a></li>
<li><a href="#factorial-base-case">Factorial: base case</a></li>
<li><a href="#factorial-recursion-case">Factorial: recursion case</a></li>
</ul></li>
<li><a href="#records">Records</a></li>
<li><a href="#pointers">Pointers</a></li>
<li><a href="#further-topics">Further topics</a></li>
</ul></li>
<li><a href="#architecture">Architecture</a><ul>
<li><a href="#data-representation-and-notation">Data representation and notation</a></li>
<li><a href="#overview-of-the-subsystems">Overview of the subsystems</a></li>
<li><a href="#register-file">Register file</a><ul>
<li><a href="#r0-holds-the-constant-0">R0 holds the constant 0</a></li>
<li><a href="#r15-is-the-condition-code-register">R15 is the condition code register</a></li>
</ul></li>
<li><a href="#memory">Memory</a></li>
<li><a href="#control-registers">Control registers</a><ul>
<li><a href="#status-register-flags">Status register flags</a></li>
<li><a href="#interrupts-and-exceptions">Interrupts and exceptions</a></li>
<li><a href="#mask-and-request-flags">Mask and request flags</a></li>
</ul></li>
<li><a href="#instruction-representation">Instruction representation</a><ul>
<li><a href="#instruction-fields">Instruction fields</a></li>
<li><a href="#rrr-format">RRR format</a></li>
<li><a href="#rx-format">RX format</a></li>
<li><a href="#exp0-format">EXP0 format</a></li>
<li><a href="#exp4-format">EXP4 format</a></li>
<li><a href="#exp8-format">EXP8 format</a></li>
<li><a href="#summary-of-instruction-formats">Summary of instruction formats</a></li>
<li><a href="#assembly-language-statement-formats">Assembly language statement formats</a></li>
<li><a href="#rrr-format-1">RRR format</a></li>
<li><a href="#rx-format-1">RX format</a></li>
<li><a href="#exp-format">EXP format</a></li>
</ul></li>
</ul></li>
<li><a href="#instruction-set">Instruction set</a><ul>
<li><a href="#arithmetic-instructions">Arithmetic instructions</a><ul>
<li><a href="#add">add</a></li>
<li><a href="#sub">sub</a></li>
<li><a href="#mul">mul</a></li>
<li><a href="#div">div</a></li>
<li><a href="#addc">addc</a></li>
</ul></li>
<li><a href="#accessing-memory">Accessing memory</a><ul>
<li><a href="#lea">lea</a></li>
<li><a href="#load">load</a></li>
<li><a href="#store">store</a></li>
<li><a href="#save">save</a></li>
<li><a href="#restore">restore</a></li>
<li><a href="#push">push</a></li>
<li><a href="#pop">pop</a></li>
<li><a href="#top">top</a></li>
</ul></li>
<li><a href="#comparisons">Comparisons</a><ul>
<li><a href="#cmplt">cmplt</a></li>
<li><a href="#cmpeq">cmpeq</a></li>
<li><a href="#cmpgt">cmpgt</a></li>
<li><a href="#cmp">cmp</a></li>
</ul></li>
<li><a href="#transfer-of-control">Transfer of control</a><ul>
<li><a href="#jump">jump</a></li>
<li><a href="#jumpf">jumpf</a></li>
<li><a href="#jumpt">jumpt</a></li>
<li><a href="#jumpc0">jumpc0</a></li>
<li><a href="#jumpc1">jumpc1</a></li>
<li><a href="#jal">jal</a></li>
<li><a href="#aliases-for-conditional-jumps">Aliases for conditional jumps</a></li>
</ul></li>
<li><a href="#bit-fields">Bit fields</a><ul>
<li><a href="#inv">inv</a></li>
<li><a href="#and">and</a></li>
<li><a href="#or">or</a></li>
<li><a href="#xor">xor</a></li>
<li><a href="#shiftl">shiftl</a></li>
<li><a href="#shiftr">shiftr</a></li>
<li><a href="#getbit">getbit</a></li>
<li><a href="#getbiti">getbiti</a></li>
<li><a href="#putbit">putbit</a></li>
<li><a href="#putbiti">putbiti</a></li>
<li><a href="#extract">extract</a></li>
<li><a href="#execute">execute</a></li>
</ul></li>
<li><a href="#system-control">System control</a><ul>
<li><a href="#trap">trap</a></li>
<li><a href="#getctl">getctl</a></li>
<li><a href="#putctl">putctl</a></li>
<li><a href="#rfi">rfi</a></li>
</ul></li>
<li><a href="#trap-operations">Trap operations</a><ul>
<li><a href="#halt">Halt</a></li>
<li><a href="#nonblocking-read">Nonblocking read</a></li>
<li><a href="#write">Write</a></li>
<li><a href="#blocking-readline">Blocking readline</a></li>
<li><a href="#nonblocking-readline">Nonblocking readline</a></li>
<li><a href="#random-number">Random number</a></li>
</ul></li>
<li><a href="#list-of-instructions">List of instructions</a></li>
</ul></li>
<li><a href="#assembly-language-1">Assembly Language</a><ul>
<li><a href="#notation">Notation</a></li>
<li><a href="#statement-formats">Statement formats</a></li>
<li><a href="#instructions">Instructions</a></li>
<li><a href="#directives">Directives</a><ul>
<li><a href="#expressions">Expressions</a></li>
<li><a href="#data-statement">data statement</a></li>
<li><a href="#module-statement">module statement</a></li>
<li><a href="#org-statement">org statement</a></li>
<li><a href="#import-statment">import statment</a></li>
<li><a href="#export-statement">export statement</a></li>
<li><a href="#equ">equ</a></li>
</ul></li>
<li><a href="#assembly-listing">Assembly listing</a></li>
</ul></li>
<li><a href="#linker">Linker</a><ul>
<li><a href="#programs-modules-and-files">Programs, modules, and files</a></li>
<li><a href="#simple-standalone-programs">Simple standalone programs</a></li>
<li><a href="#programs-with-multiple-modules">Programs with multiple modules</a></li>
<li><a href="#object-code">Object code</a><ul>
<li><a href="#relocate-statement">relocate statement</a></li>
</ul></li>
<li><a href="#executable-code">Executable code</a></li>
</ul></li>
<li><a href="#programming">Programming</a><ul>
<li><a href="#using-the-instructions">Using the instructions</a><ul>
<li><a href="#load-and-store">load and store</a></li>
<li><a href="#lea-1">lea</a></li>
</ul></li>
<li><a href="#how-to-perform-commmon-tasks">How to perform commmon tasks</a><ul>
<li><a href="#stopping-the-program">Stopping the program</a></li>
<li><a href="#conditional-jumps">Conditional jumps</a></li>
<li><a href="#compilation-patterns">Compilation patterns</a><ul>
<li><a href="#compiling-an-assignment-statement">Compiling an assignment statement</a></li>
</ul></li>
<li><a href="#variable-names-and-addresses">Variable names and addresses</a></li>
<li><a href="#instructions-in-assembly-language">Instructions in assembly language</a></li>
<li><a href="#how-the-assembler-allocates-memory">How the assembler allocates memory</a></li>
<li><a href="#program-structure">Program structure</a></li>
<li><a href="#example-program-add">Example program Add</a></li>
<li><a href="#snapshot-of-memory-example-program-add">Snapshot of memory: example program Add</a></li>
</ul></li>
<li><a href="#programming-tips">Programming tips</a><ul>
<li><a href="#programming-tip-copying-one-register-to-another">Programming tip: Copying one register to another</a></li>
<li><a href="#using-load-and-store">Using load and store</a></li>
<li><a href="#compilation-patterns-1">Compilation patterns</a></li>
<li><a href="#how-can-you-tell-if-youre-using-the-pattern">How can you tell if you’re using the pattern?</a></li>
<li><a href="#are-you-using-the-pattern">Are you using the pattern?</a></li>
<li><a href="#comments">Comments</a></li>
</ul></li>
<li><a href="#records-1">Records</a></li>
<li><a href="#pointers-1">Pointers</a><ul>
<li><a href="#expressions-using-pointers">Expressions using pointers</a></li>
<li><a href="#the-operator-requires-only-one-instruction-lea">The &amp; operator requires only one instruction: lea!</a></li>
<li><a href="#the-operator-requires-only-one-instruction-load">The * operator requires only one instruction: load!</a></li>
<li><a href="#flexibility-of-load-and-lea">Flexibility of load and lea</a></li>
<li><a href="#following-a-pointer-to-the-address-of-x-gives-x">Following a pointer to the address of x gives x}</a></li>
<li><a href="#review-accessing-a-variable-the-ordinary-way">Review: accessing a variable the ordinary way</a></li>
<li><a href="#accessing-a-variable-through-a-pointer">Accessing a variable through a pointer</a></li>
<li><a href="#access-a-record-using-a-pointer">Access a record using a pointer</a></li>
</ul></li>
<li><a href="#requests-to-the-operating-system">Requests to the Operating System</a><ul>
<li><a href="#termination">Termination</a></li>
<li><a href="#character-strings-pointer-to-array-of-characters">Character strings: pointer to array of characters</a></li>
<li><a href="#write-operation-on-sigma16">Write operation on Sigma16</a></li>
</ul></li>
<li><a href="#procedures">Procedures</a><ul>
<li><a href="#call-and-return">Call and return</a></li>
<li><a href="#the-jump-and-link-instruction-jal">The jump-and-link instruction: jal</a></li>
<li><a href="#calling-with-jal-and-returning-with-jump">Calling with jal and returning with jump</a></li>
<li><a href="#parameter-passage">Parameter passage</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#what-if-a-procedure-calls-another-procedure">What if a procedure calls another procedure?</a></li>
<li><a href="#r13-overwritten-proc1-returns-to-the-wrong-place">R13 overwritten: proc1 returns to the wrong place!</a></li>
<li><a href="#saving-state">Saving state</a></li>
<li><a href="#stack-of-return-addresses">Stack of return addresses</a></li>
</ul></li>
<li><a href="#stacks">Stacks</a><ul>
<li><a href="#the-call-stack-2">The call stack</a></li>
</ul></li>
<li><a href="#retrospective">Retrospective</a><ul>
<li><a href="#review-of-procedures-call-with-jal-return-with-jump">Review of procedures: Call with jal, return with jump</a></li>
<li><a href="#review-activation-records-a.k.a.-stack-frames">Review: Activation records, a.k.a. stack frames</a></li>
</ul></li>
<li><a href="#linked-lists">Linked lists</a><ul>
<li><a href="#is-list-p-empty">Is list p empty?</a></li>
<li><a href="#get-value-in-node-that-p-points-at-x-p.value">Get value in node that p points at: x := *p.value</a></li>
<li><a href="#get-pointer-to-next-node-in-a-list-q-p.next">Get pointer to next node in a list: q := *p.next</a></li>
<li><a href="#traversing-a-list">Traversing a list</a></li>
<li><a href="#search-a-list-p-for-a-value-x">Search a list p for a value x</a></li>
<li><a href="#cons-constructing-a-list-be-consing-a-value-to-the-front">cons — constructing a list be consing a value to the front</a></li>
<li><a href="#list-header">List header</a></li>
<li><a href="#deleting-a-node">Deleting a node</a></li>
<li><a href="#memory-management">Memory management</a></li>
<li><a href="#sharing-and-side-effects">Sharing and side effects</a></li>
</ul></li>
<li><a href="#comparing-lists-and-arrays">Comparing lists and arrays</a></li>
<li><a href="#example-ordered-lists-program">Example: Ordered lists program</a></li>
<li><a href="#testing-and-debugging">Testing and debugging</a><ul>
<li><a href="#breakpoints">Breakpoints</a></li>
</ul></li>
<li><a href="#trees">Trees</a></li>
<li><a href="#abstract-data-type">Abstract data type</a><ul>
<li><a href="#array-implementation-of-stack">Array implementation of stack</a></li>
</ul></li>
<li><a href="#error-checking">Error checking</a></li>
<li><a href="#programming-techniques">Programming techniques</a><ul>
<li><a href="#compound-boolean-expressions">Compound Boolean expressions</a></li>
<li><a href="#short-circuit-expressions">``Short circuit’’ expressions</a></li>
<li><a href="#condition-code">Condition code</a><ul>
<li><a href="#repeat-until-loop">Repeat-until loop</a></li>
</ul></li>
</ul></li>
<li><a href="#inputoutput">Input/Output</a><ul>
<li><a href="#converting-a-number-to-a-string">Converting a number to a string</a></li>
<li><a href="#arrays-and-pointers">Arrays and pointers</a></li>
<li><a href="#sum-of-an-array-x-using-index-high-level">Sum of an array x using index: high level</a></li>
<li><a href="#arrays-and-pointers-1">Arrays and pointers</a></li>
<li><a href="#accessing-an-array-element-using-a-pointer">Accessing an array element using a pointer</a></li>
<li><a href="#sum-of-an-array-x-using-pointers-high-level">Sum of an array x using pointers: high level</a></li>
<li><a href="#sum-of-an-array-x-using-pointers-assembly-language">Sum of an array x using pointers: assembly language</a></li>
<li><a href="#comparing-the-two-approaches">Comparing the two approaches</a></li>
<li><a href="#records-2">Records</a></li>
<li><a href="#traverse-array-of-records-with-indexing">Traverse array of records with indexing</a></li>
<li><a href="#traverse-array-of-records-with-pointers-high-level">Traverse array of records with pointers: high level</a></li>
<li><a href="#traverse-array-of-records-with-pointers-low-level">Traverse array of records with pointers: low level</a></li>
<li><a href="#traverse-array-of-records-with-pointers-assembly-language">Traverse array of records with pointers: assembly language</a></li>
<li><a href="#stack-overflow">Stack overflow</a></li>
<li><a href="#blocks">Blocks</a></li>
<li><a href="#python-syntax-style-for-blocks-layout">Python syntax style for blocks: layout</a></li>
<li><a href="#algolpascal-style-for-blocks-beginend">Algol/Pascal style for blocks: begin—end</a></li>
<li><a href="#c-style-for-blocks-braces">C style for blocks: braces</a></li>
<li><a href="#block-structured-style-for-blocks-matching-keywords">Block structured style for blocks: matching keywords</a></li>
<li><a href="#enter-at-beginning-exit-at-end">Enter at beginning, exit at end</a></li>
<li><a href="#single-entranceexit-for-compilation-patterns">Single entrance/exit for compilation patterns</a></li>
<li><a href="#systematic-approach-to-programming">Systematic approach to programming?</a></li>
</ul></li>
<li><a href="#nested-conditionals">Nested conditionals</a></li>
<li><a href="#privileged-instructions">Privileged instructions</a></li>
<li><a href="#trees-1">Trees</a></li>
<li><a href="#binary-search-trees">Binary search trees</a><ul>
<li><a href="#complexity-of-search">Complexity of search</a></li>
<li><a href="#how-much-faster">How much faster?</a></li>
<li><a href="#how-bad-can-complexity-be">How bad can complexity be?</a></li>
</ul></li>
<li><a href="#interrupts">Interrupts</a><ul>
<li><a href="#concurrent-processes">Concurrent processes</a></li>
<li><a href="#how-interrupts-are-implemented">How interrupts are implemented</a></li>
<li><a href="#registers">Registers</a></li>
<li><a href="#infinite-loop">Infinite loop</a></li>
<li><a href="#case-dispatch">Case dispatch</a></li>
<li><a href="#control-algorithm">Control algorithm</a></li>
</ul></li>
<li><a href="#languages-and-systems">Languages and systems</a><ul>
<li><a href="#advice-on-software-engineering">Advice on software engineering</a></li>
<li><a href="#what-should-a-software-engineer-study">What should a software engineer study?</a></li>
<li><a href="#low-level-list-manipulation">Low level list manipulation</a></li>
<li><a href="#b-a.copy">b = a.copy()</a><ul>
<li><a href="#for-loops">for loops</a></li>
</ul></li>
<li><a href="#for-loops-in-algol-and-descendants">for loops in Algol and descendants</a></li>
<li><a href="#write-programs-at-a-high-level">Write programs at a high level</a></li>
<li><a href="#use-patterns-to-translate-to-low-level">Use patterns to translate to low level</a></li>
<li><a href="#translate-low-level-to-assembly-language">Translate low level to assembly language</a></li>
<li><a href="#practical-programming-tip">Practical programming tip</a></li>
<li><a href="#example-writevalchar">Example: WriteValChar</a></li>
<li><a href="#a-simple-procedure-writevalchar">A simple procedure: WriteValChar</a></li>
<li><a href="#calling-writevalchar">Calling WriteValChar</a></li>
<li><a href="#definition-of-writevalchar-1">Definition of WriteValChar (1)</a></li>
<li><a href="#definition-of-writevalchar-2">Definition of WriteValChar (2)</a></li>
<li><a href="#static-variables-in-a-data-segment">Static variables in a data segment</a></li>
<li><a href="#implementing-static-data-segment">Implementing static data segment</a></li>
<li><a href="#practical-tip---editing">Practical tip - editing</a></li>
</ul></li>
<li><a href="#linking">Linking}</a><ul>
<li><a href="#subroutines">Subroutines</a></li>
<li><a href="#calling-conventions">Calling conventions</a></li>
<li><a href="#linking-1">Linking</a></li>
<li><a href="#interrupts-an-unrequested-jump">Interrupts — an unrequested jump</a></li>
<li><a href="#implementing-interrupts">Implementing interrupts</a></li>
<li><a href="#basic-interrupt-control">Basic interrupt control</a></li>
<li><a href="#saving-the-pc">Saving the PC</a></li>
<li><a href="#where-to-save-the-pc">Where to save the PC?</a></li>
<li><a href="#saving-state-1">Saving state</a></li>
<li><a href="#disabling-interrupts">Disabling interrupts</a></li>
<li><a href="#missing-interrupts">Missing interrupts</a></li>
</ul></li>
<li><a href="#data-types">Data types</a><ul>
<li><a href="#many-kinds-of-procedure">Many kinds of procedure</a></li>
<li><a href="#about-those-jumps-call-and-return">About those jumps (call and return)</a></li>
<li><a href="#characters">Characters</a></li>
<li><a href="#calling-conventions-1">Calling conventions</a></li>
<li><a href="#programming-tips-1">Programming tips</a></li>
<li><a href="#how-to-program-efficiently">How to program efficiently</a></li>
<li><a href="#how-to-waste-time">How to waste time</a></li>
</ul></li>
<li><a href="#using-the-instruction-set">Using the instruction set</a><ul>
<li><a href="#part-of-the-instruction-set">Part of the instruction set</a></li>
<li><a href="#closed-source-open-source-free">Closed source, open source, free</a></li>
</ul></li>
<li><a href="#operating-systems">Operating Systems</a><ul>
<li><a href="#essential-services">Essential services</a></li>
<li><a href="#requests-to-the-os">Requests to the OS</a></li>
<li><a href="#the-trap-instruction">The trap instruction</a></li>
<li><a href="#trap-is-like-jump-but-different">trap is like jump, but different</a></li>
<li><a href="#typical-os-requests">Typical OS requests</a></li>
<li><a href="#memory-allocation">Memory allocation</a></li>
<li><a href="#adding-a-character-to-a-string">Adding a character to a string</a></li>
<li><a href="#memory-allocation-1">Memory allocation</a></li>
<li><a href="#part-of-the-instruction-set-1">Part of the instruction set</a></li>
</ul></li>
<li><a href="#pointers-2">Pointers</a><ul>
<li><a href="#three-key-instructions-lea-load-store">Three key instructions: lea, load, store</a></li>
<li><a href="#a-computer-is-a-digital-circuit">A computer is a digital circuit!}</a></li>
<li><a href="#philosophical-question-finding-the-ultimate-cause">Philosophical question: finding the ultimate cause}</a></li>
<li><a href="#some-examples-of-emergent-ultimate-causes">Some examples of emergent ``ultimate causes’’}</a></li>
<li><a href="#summary">Summary</a><ul>
<li><a href="#booleans">Booleans</a></li>
</ul></li>
<li><a href="#booleans-in-machine-language">Booleans in machine language</a></li>
<li><a href="#example-program-findmax">Example: program findmax}</a></li>
<li><a href="#trap-1">Trap</a></li>
</ul></li>
<li><a href="#addresses">Addresses</a><ul>
<li><a href="#accessing-data">Accessing data</a></li>
</ul></li>
<li><a href="#hexadecimal-numbers">Hexadecimal Numbers</a><ul>
<li><a href="#hexadecimal-digits">Hexadecimal Digits</a></li>
<li><a href="#hexadecimal-numbers-hex-numbers">Hexadecimal numbers (``hex numbers’’)</a></li>
<li><a href="#hexadecimal-is-easier-to-read-than-bits">Hexadecimal is easier to read than bits</a></li>
</ul></li>
<li><a href="#jumping">Jumping</a><ul>
<li><a href="#instruction-set-1">Instruction set</a></li>
<li><a href="#what-can-we-learn-from-this">What can we learn from this?</a></li>
<li><a href="#structure-of-the-control-algorithm">Structure of the control algorithm</a></li>
<li><a href="#a-closer-look-at-lea">A closer look at lea</a></li>
<li><a href="#lea-and-load-similar-but-not-identical">Lea and Load: similar but not identical!</a></li>
<li><a href="#a-jump-is-just-a-load">A jump is just a load!</a></li>
<li><a href="#programming-guidelines">Programming Guidelines</a></li>
<li><a href="#identify-the-program">Identify the program</a></li>
<li><a href="#high-level-algorithm-as-pseudocode">High level algorithm as pseudocode</a></li>
<li><a href="#middle-level-the-goto-form">Middle level: the ``goto form’’</a></li>
<li><a href="#translate-high-level-code-to-low-level-goto-form">Translate high level code to low level ``goto form’’</a></li>
<li><a href="#specify-how-the-registers-are-used">Specify how the registers are used</a></li>
<li><a href="#lowest-level-commented-assembly-language">Lowest level: Commented assembly language</a></li>
<li><a href="#block-of-statements-to-initialise-registers">Block of statements to initialise registers</a></li>
<li><a href="#assembly-language-code">Assembly language code</a></li>
<li><a href="#assembly-language-continued">Assembly language, continued</a></li>
<li><a href="#data-definitions">Data definitions</a></li>
<li><a href="#static-variables-in-a-data-segment-1">Static variables in a data segment</a></li>
<li><a href="#implementing-static-data-segment-1">Implementing static data segment</a></li>
</ul></li>
<li><a href="#assembly-language-2">Assembly language</a><ul>
<li><a href="#assembly-language-notation">Assembly language notation</a></li>
<li><a href="#fields-separated-by-spaces">Fields separated by spaces</a></li>
<li><a href="#correct-form-of-operand-field">Correct form of operand field</a></li>
<li><a href="#each-of-these-statements-is-wrong">Each of these statements is wrong!</a></li>
<li><a href="#writing-constants">Writing constants</a></li>
<li><a href="#good-style">Good style</a></li>
<li><a href="#comments-1">Comments</a></li>
<li><a href="#indent-your-code-consistently">Indent your code consistently</a></li>
<li><a href="#use-spaces-not-tabs">Use spaces, not tabs</a></li>
</ul></li>
<li><a href="#programming-techniques-1">Programming techniques</a><ul>
<li><a href="#programming-tip-copying-one-register-to-another-1">Programming tip: Copying one register to another</a></li>
<li><a href="#using-load-and-store-1">Using load and store</a></li>
<li><a href="#a-useful-convention">A useful convention</a></li>
<li><a href="#development-by-transformation">Development by transformation}</a></li>
<li><a href="#high-level">High level</a></li>
<li><a href="#low-level">Low level</a></li>
<li><a href="#basic-expressions-and-statements">Basic expressions and statements</a></li>
<li><a href="#exposing-the-architecture">Exposing the architecture</a><ul>
<li><a href="#data-types-and-data-structures">Data types and data structures</a></li>
</ul></li>
<li><a href="#data-types-1">Data types</a></li>
<li><a href="#records-3">Records</a></li>
<li><a href="#traverse-array-of-records-with-indexing-1">Traverse array of records with indexing</a></li>
<li><a href="#traverse-array-of-records-with-pointers">Traverse array of records with pointers</a></li>
<li><a href="#high-level-control-structures">High level control structures</a></li>
<li><a href="#low-level-control-structures">Low level control structures</a></li>
<li><a href="#compilation-patterns-2">Compilation patterns</a></li>
<li><a href="#if-bexp-then-s">if bexp then S</a></li>
<li><a href="#if-bexp-then-s1-else-s2">if bexp then S1 else S2</a></li>
<li><a href="#while-b-do-s">while b do S</a></li>
<li><a href="#implementing-compilation-patterns">Implementing compilation patterns</a></li>
<li><a href="#some-interesting-points">Some interesting points</a></li>
<li><a href="#opportunities">Opportunities</a></li>
<li><a href="#opportunity-for-multiple-execution-models">Opportunity for multiple execution models</a></li>
<li><a href="#tricky-issues">Tricky issues</a></li>
</ul></li>
<li><a href="#stacks-1">Stacks</a></li>
</ul></li>
<li><a href="#circuit">Circuit</a><ul>
<li><a href="#m1-circuit">M1 circuit</a></li>
</ul></li>
<li><a href="#installation">Installation</a><ul>
<li><a href="#how-to-run-sigma16">How to run Sigma16</a><ul>
<li><a href="#the-easiest-way-just-click-a-link">The easiest way: just click a link</a></li>
<li><a href="#download-and-open-file-in-browser">Download and open file in browser</a></li>
<li><a href="#run-locally-with-npm-and-electron">Run locally with npm and electron</a></li>
<li><a href="#compiling-a-standalone-executable">Compiling a standalone executable</a></li>
<li><a href="#version-number">Version number</a></li>
<li><a href="#running-in-a-browser.">Running in a browser.</a></li>
<li><a href="#running-a-standalone-pre-compiled-executable">Running a standalone pre-compiled executable</a></li>
</ul></li>
</ul></li>
<li><a href="#about-sigma16">About Sigma16</a><ul>
<li><a href="#author">Author</a></li>
<li><a href="#license">License</a></li>
<li><a href="#implementation">Implementation</a></li>
</ul></li>
<li><a href="#reference">Reference</a><ul>
<li><a href="#index-of-notation">Index of notation</a></li>
</ul></li>
</ul>
</nav>
<h1 id="introduction">Introduction</h1>
<p>Sigma16 is a computer architecture designed for research and teaching in computer systems. This application provides a complete environment for experimenting with the architecture, including an editor, assembler, linker, emulator, and an integrated development environment. There is a digital circuit that implements the architecture, which is specified using the Hydra functional hardware description language. Hydra can simulate the circuit, and machine language programs can run on both the emulator and the circuit.</p>
<p>This reference manual is organised by topic, with chapters on the architecture, the assembly language, and the emulator. However, it’s a good idea to begin with an overview of how the whole system works, and to be able to write and run simple programs, before delving into the details. For a quick start, begin with the tutorials, which show you how to enter and run a program and how to use the programming environment.</p>
<h1 id="tutorials">Tutorials</h1>
<p>The following short tutorials introduce the system; full details appear in later sections. You can keep the tutorials visible in the right panel while following along with the exercises in the main panel.</p>
<h2 id="hello-world">Hello, world!</h2>
<p>The Sigma16 IDE (the main “app”) is implemented in JavaScript and runs in a web browser. There are additional components to the system that must be downloaded and run on a computer; these include a digital circuit that implements the architecture and a high speed emulator. You can run the IDE simply by <a href="https://jtod.github.io/S16/dev/app/Sigma16.html">clicking a link to Launch Sigma16 to run in your browser</a>. See the <a href="https://jtod.github.io/S16/">Sigma16 Home Page</a> for further information, documentation, and executable versions. For now, we will just work with the IDE running in a browser.</p>
<p>The main window contains three main sections. The largest area, on the left side, is the <em>main working area</em>. When the program launches, this will show the Welcome page. The <em>user guide</em> is on the right side. At the top is a row of buttons (Welcome, Examples, etc.). These select which page is displayed in the main working area.</p>
<p>It’s convenient to see the main working area and the user guide side by side. Begin by resizing the entire window (bigger is better). Then you can change the amount of space given to the user guide by clicking the arrow symbols on the right side of the top button bar. These arrows will expand or shrink the user guide: the small arrows adjust by one pixel, the larger arrows by ten pixels. If you resize the entire browser window, Sigma16 will maintain the same relative sizes of the architecture and user guide sections.</p>
<p>You can also open the User Guide in a separate browser tab or window. The Welcome page contains a link to do this.</p>
<p>A good way to get started is to go through the entire process of running a simple program. For now, we focus just on how to use the software tools; an explanation of the Sigma16 architecture comes later.</p>
<p>The main working area has several pages, with buttons at the top to switch between them:</p>
<ul>
<li><p><strong>Welcome</strong> contains some introductory information, release notes, and links.</p></li>
<li><p><strong>Examples</strong> contains a collection of assembly language programs, organized by topic.</p></li>
<li><p><strong>Modules</strong> shows a summary of all the files and modules you currently have open.</p></li>
<li><p><strong>Editor</strong> shows the selected module, where it can be edited.</p></li>
<li><p><strong>Assembler</strong> translates a program from assembly language to machine language, and shows the assembly isting as well as the object code.</p></li>
<li><p><strong>Linker</strong> combines a collection of object code modles into a single executable program.</p></li>
<li><p><strong>Processor</strong> shows the components of the architecture and executes machine language programs.</p></li>
</ul>
<p>Let’s begin by running a simple example program.</p>
<ul>
<li><p>Click <strong>Editor</strong>, then <strong>Simple Example</strong>. This will enter a small assembly language program into the editor window. Later, we’ll load some of the more complex example programs into the editor, and you can also modify a program or type in a new one from scratch.</p></li>
<li><p>Click <strong>Assembler</strong> and then the <strong>Assemble</strong> button. This translates the program in the Editor page from assembly language to machine language. The <strong>Assembly Listing</strong> button displays the result of the translation, including any error messages. The <strong>Object Code</strong> button displays the output from the translation.</p></li>
<li><p>For this simple example, we don’t need the Linker, so you can skip it. The linker is needed for larger and more complex programs with multiple modules, or with external references, or that need relocation.</p></li>
<li><p>Click <strong>Processor</strong>, which shows the main components of the computer architecture, including registers and memory. These components are explained later. For now, just note that this page is where you can run programs using the emulator.</p></li>
<li><p>Still on the Processor page, click <strong>Boot</strong>. This reads the machine language program into the memory, and you can see it in the Memory display. The source code (the assembly language) appears in the bottom section.</p></li>
<li><p>Click <strong>Step</strong>. The processor executes a single instruction and displays the effects on the registers and memory: blue for using a value, and red for modifying it. The assembly listing shows the instruction that just executed by highlighting it in red. It also shows the instruction that will execute next by highlighting it in blue. This is just to make it easier to follow what is happening; the actual machine ignores the assembly language listing and doesn’t even “know” that it exists.</p></li>
<li><p>Click Step repeatedly to watch the program execute, instruction by instruction. When the program terminates, the small window labelled <strong>Emulator</strong> will display Halted.</p></li>
<li><p>To rerun the program, click Boot again.</p></li>
</ul>
<p>To exit the app, just close the browser window or tab. This should put up a dialogue box warning that any unsaved data may be lost and asking you to confirm.</p>
<h2 id="registers-and-arithmetic">Registers and arithmetic</h2>
<p>Registers are like variables in a programming language. They are even more similar to the registers in a calculator.</p>
<p>Registers can hold variables</p>
<ul>
<li>We often think of a variable as </li>
<li>A register can hold a variable!</li>
<li>An add instruction (or sub, mul, div) is like an assignment statement</li>
<li> means  \begin{enumerate}</li>
<li>Evaluate the right hand side </li>
<li>The operands (R8, R2) are not changed</li>
<li>Overwrite the left hand side (destination) (R2) with the result</li>
<li>The old value of the destination is destroyed</li>
<li>It is </li>
<li>It is  \end{enumerate}</li>
<li>Assignment is often written </li>
<li>The  operator means , and does not mean </li>
</ul>
<p>Why write a notation like add R5,R2,R3 instead of R5 := R2 + R3?</p>
<ul>
<li><p>It’s more consistent because  instruction will be written in this form: a keyword for the operation, followed by the operands</p></li>
<li><p>The notation is related closely to the way instructions are represented in memory, which we’ll see later</p></li>
</ul>
<p>A simple program. The problem:</p>
<ul>
<li>Given three integers in R1, R2, R3</li>
<li>Goal: calculate the sum R1+R2+R3 and put it in R4</li>
</ul>
<pre><code>    add  R4,R1,R2    ;  R4 := R1+R2   (this is a comment)
    add  R4,R4,R3    ;  R4 := (R1+R2) + R3</code></pre>
<p>There are four arithmetic instructions, to perform addition, subtraction, multiplication, and division. (There are also a few more not discussed here.)</p>
<p>The add instruction takes the contents of two operand registers and places their sum into a destination register. It is written with the operation <em>add</em>, and the three registers separated by commas: <em>add destination,firstOperand,secondOperand</em>. For example, add R2,R5,R8 calculates the sum of R5 and R8 and places the result into R2. The effect can be described with an assignment statement: R2 := R5+R8.</p>
<p>To place a constant into a register, use the lea instruction. The destination is a register, and the operand is a constant followed by [R0]. For example, to load 42 into register 3, write</p>
<pre><code>    lea   R2,42[R0]   ; R2 := 42</code></pre>
<p>For now, just ignore the [R0], but this is a required part of the instruction. Later we’ll see why [R0] is there, along with more capabilities of the lea instruction.</p>
<pre><code>    lea   R5,3[R0]    ; R5 := 3
    lea   R8,4[R0]    ; R8 := 4
    add   R2,R5,R8    ; R2 := R5 + R8 = 3+4 = 7</code></pre>
<p>hexadecimal</p>
<p>Replace 3+4 by 23+5. Now the result is 28. The processor page shows numbers in hexadecimal, so 28 is displayed as 001c (i.e. 28 = 1*16 + 12, and the hex digit for 12 is c).</p>
<pre><code>    lea   R5,23[R0]   ; R5 := 23
    lea   R8,5[R0]    ; R8 := 5
    add   R2,R5,R8    ; R2 := R5 + R8 = 23+5 = 28 = $001c</code></pre>
<p>Further instructions</p>
<pre><code>    add   R1,R2,R3
    sub   R1,R2,R3
    mul   R1,R2,R3
    div   R1,R2,R3</code></pre>
<p>More arithmetic instructions. There are instructions for the basic arithmetic operations</p>
<pre><code> add  R4,R11,R0   ; R4 := R11 + R0
 sub  R8,R2,R5    ; R8 := R2 - R5
 mul  R10,R1,R2   ; R10 := R1 * R2
 div  R7,R2,R12   ; R7 := R2 / R12</code></pre>
<p>Every arithmetic operation takes its operands from registers, and loads the result into a register.</p>
<p>In the lea instruction, the constant value can be specified using either decimal or hexadecimal notation. Indicate hexadecimal in assembly language by putting $ before the number. Thus $00a5 and 0165 both represent the integer 165.</p>
<p>Most instructions follow a similar pattern, where the first operand is the destination where the result is placed, and the subsequent operands are the arguments to the computation. This is the same convention used in assignment statements in many programming languages: the registers in sub R1,R2,R3 appear in the same order as the varaibles in R1 := R2-R3.</p>
<p>An arithmetic instruction performs just one operation. Several instructions are needed to evaluate a larger expression, such as 7 + 10*9:</p>
<pre><code>   lea   R1,7[R0]
   lea   R2,10[R0]
   lea   R3,9[R0]
   mul   R2,R2,R3
   add   R1,R1,R2</code></pre>
<p>Generally you can use any register you like; in the previous example we could have used R12, R6, and R8 instead of R1, R2, R3. Registers R1 through R14 are all the same. However, two of the registers are different:</p>
<ul>
<li><p>R0 contains the constant 0 and it will never change. Any time an instruction uses R0, the value it gets will be 0. It is legal for an instruction to attempt to modify R0 (for example, add R0,R3,R4 is legal) but after executing this instruction R0 still contains 0. The reason for this is that we frequently need to have access to a register containing 0.</p></li>
<li><p>R15 contains a number of bits that provide some information about an instruction. For example, if an addition produces a result that is too large to fit in a register, a special flag indicating this is set in R15. Many of the instructions, including all the arithmetic instructions, change the value of R15 as well as placing the result in the destination register. For this reason, R15 cannot be used to hold a variable: its value would be destroyed almost immediately.</p></li>
</ul>
<p>To summarise, Registers R1 through R14 are all identical and can be used for variables. R0 contains 0 and will never change. R1 changes very frequently and can be used to determine various error conditions and other information about an instruction.</p>
<p>Every register contains one word of data. On the Sigma16 architecture, a word is 16 bits of data. This is enough to represent any of the following:</p>
<ul>
<li><p>An integer between ? and ?</p></li>
<li><p>A natural number between 0 and 65,535</p></li>
<li><p>A character</p></li>
</ul>
<p>Example</p>
<ul>
<li>Suppose we have variables a, b, c, d</li>
<li>R1=a, R2=b, R3=c, R4=d</li>
<li>We wish to compute R5 = (a+b) * (c-d)</li>
</ul>
<pre><code>    add   R6,R1,R2     ; R6 := a + b
    sub   R7,R3,R4     ; R7 := c - d
    mul   R5,R6,R7     ; R5 := (a+b) * (c-d)</code></pre>
<p>Good comments make the code easier to read!</p>
<p>General form of arithmetic instruction</p>
<pre><code>op d,a,b</code></pre>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">op</td>
<td style="text-align: center;">operation: add, sub, mul,div</td>
</tr>
<tr class="even">
<td style="text-align: center;">d</td>
<td style="text-align: center;">destination register: where the result goes</td>
</tr>
<tr class="odd">
<td style="text-align: center;">a</td>
<td style="text-align: center;">first operand register</td>
</tr>
<tr class="even">
<td style="text-align: center;">b</td>
<td style="text-align: center;">second operand register</td>
</tr>
</tbody>
</table>
<p>Meaning R_d := R_a op  R_b</p>
<p>Example: add R5,R2,R12 ; R5 := R2+R12</p>
<p><strong>Register R0 and R15 are special</strong></p>
<p>You should not use R0 or R15 to hold ordinary variables.</p>
<p><strong>R0 always contains 0</strong></p>
<ul>
<li><p>Any time you need the number 0, it’s available in R0</p></li>
<li><p>You cannot change the value of R0</p></li>
<li><p>add R0,R2,R3 ; does nothing — R0 will not change</p></li>
<li><p>add R5,R2,R3 ; fine - you can change all other registers</p></li>
<li><p>It is legal to use R0 as the destination, but it will still be 0 after you do it!</p></li>
</ul>
<p><strong>R15 holds status information</strong></p>
<ul>
<li><p>Some instructions place additional information in R15 (is the result negative? was there an overflow?)</p></li>
<li><p>Therefore the information in R15 is transient</p></li>
<li><p>R15 is for temporary information; it’s not a safe place to keep long-term data</p></li>
</ul>
<h2 id="keeping-variables-in-memory">Keeping variables in memory</h2>
<p>Limitation of register file: it’s small.</p>
<p>The register file is used to perform calculations. In computing something like x := (2<em>a + 3</em>b) / (x-1), all the arithmetic will be done using the register file. But the register file has a big limitation: There are only 16 registers And most programs need more than 16 variables!</p>
<p>Solution: the memory is large and can hold far more data than the register file.</p>
<p>The memory is similar to the register file: it is a large collection of words A variable name (x, sum, count) refers to a word in memory Some differences between memory and register file: The memory is : 65,536 locations (the register file has only 16) The memory cannot do arithmetic</p>
<p>So our strategy in programming:</p>
<ul>
<li>Keep data permanently in memory</li>
<li>When you need to do arithmetic, copy a variable from memory to a register</li>
<li>When finished, copy the result from a register back to memory</li>
</ul>
<p>The register file:</p>
<ul>
<li>16 registers</li>
<li></li>
<li>Each register holds a 16-bit word</li>
<li>Names are R0, R1, R2, <span class="math inline">…</span>, R15</li>
<li>You can do arithmetic on data in the registers</li>
<li></li>
</ul>
<p>The {memory</p>
<ul>
<li>65,536 memory locations</li>
<li>Each memory location holds a 16-bit word</li>
<li>Each memory location has an  0, 1, 2, <span class="math inline">…</span>, 65,535</li>
<li>The machine cannot do arithmetic on a memory location</li>
<li></li>
</ul>
<p>Copying a word between memory and register. There are two instructions for accessing the memory</p>
<p>load copies a variable from memory to a register  copies the variable  from memory to register R2  R2 is changed; x is unchanged</p>
<p>store copies a variable from a register to memory  copies the word in register R3 to the variable  in memory  y is changed; R3 is unchanged</p>
<p>Notice that we write [R0] after a variable name. Later we’ll see the reason, but for now don’t worry about the [R0] – just don’t forget to put it in.</p>
<p>An assignment statement in machine langauge</p>
<p>x := a+b+c</p>
<pre><code>       load   R1,a[R0]      ; R1 := a
       load   R2,b[R0]      ; R2 := b
       add    R3,R1,R2      ; R3 := a+b
       load   R4,c[R0]      ; R4 := c
       add    R5,R3,R4      ; R5 := (a+b) + c
       store  R5,x[R0]      ; x := a+b+c</code></pre>
<p>Use  to  Do arithmetic with  Use  to </p>
<p>Why do we have registers and memory? The programmer has to keep track of which variables are currently in registers, and you have to use load and store instructions to copy data between the registers and memory. Wouldn’t it be easier just to get rid of the distinction between registers and memory, and do all the arithmetic on memory?</p>
<p>Yes, it’s possible to design a computer that way, and there have actually been real computers like that. However, this approach makes the computer very much slower. With modern circuits, a computer without load and store instructions (where you do arithmetic on memory locations) would run approximately 100 times slower.</p>
<p>Defining variables</p>
<p>To define variables x, y, z and give them initial values</p>
<pre><code>x    data   34    ; x is a variable with initial value 34
y    data    9    ; y is initially 9
z    data    0    ; z is initially 0
abc  data  $02c6  ; specify initial value as hex</code></pre>
<p>The data statements should come  all the instructions in the program (we’ll see why later)</p>
<p>A complete example program</p>
<pre><code>; Program Add
; A minimal program that adds two integer variables

; Execution starts at location 0, where the first instruction will be
; placed when the program is executed.

      load   R1,x[R0]   ; R1 := x
      load   R2,y[R0]   ; R2 := y
      add    R3,R1,R2   ; R3 := x + y
      store  R3,z[R0]   ; z := x + y
      trap   R0,R0,R0   ; terminate

; Static variables are placed in memory after the program

x     data  23
y     data  14
z     data  99</code></pre>
<h2 id="assembly-language">Assembly language</h2>
<p>The syntax of assembly language is simple and rigid.</p>
<p>Fields separated by spaces. An assembly language statement has four fields, separated by space.</p>
<ul>
<li>label (optional) – if present, must begin in leftmost character</li>
<li>mnemonic (the name of the operation): load, add, etc.</li>
<li>operands: R1,R2,R3 or R1,x[R0]</li>
<li>comments: ; x = 2 * (a+b)</li>
</ul>
<p>There cannot be any spaces inside a field*</p>
<ul>
<li>R1,R12,R5 is ok</li>
<li>R1, R12,R5 is wrong</li>
</ul>
<pre><code>loop   load   R1,count[R0]    ; R1 = count
       add    R1,R1,R2        ; R1 = R1 + 1</code></pre>
<p>The assember first breaks each statement into the four fields; then it looks at the operation and operands.</p>
<p>Correct form of operand field</p>
<ul>
<li><p>RRR: Exactly three registers separated by commas R8,R13,R0.</p></li>
<li><p>RX:Two operands: first is a register, second is an address. The address is a name or constant followed by [register]. Example: R12,array[R6]</p></li>
</ul>
<p>Each of these statements is wrong!</p>
<pre><code>    add   R2, R8, R9     Spaces in the operand field
    store x[R0],R5       First operand must be register, second is address
  loop load R1,x[R0]     Space before the label
    jumpt R6,loop        Need register after address:  loop[R0]
    jal   R14, fcn[R0]   Space in operand field</code></pre>
<p>If you forget some detail, look at one of the example programs</p>
<p>Writing constants</p>
<p>In assembly language, you can write constants in either decimal or hexadecimal.</p>
<ul>
<li>decimal: 50</li>
<li>hexadecimal: $0032</li>
</ul>
<p>Examples:</p>
<pre><code>   lea   R1,40[R0]      ; R1 = 40
   lea   R2,$ffff[R0]   ; R2 = -1

x  data  25
y  data  $2c9e</code></pre>
<p>It isn’t enough just to get the assembler to accept your program without error messages. Your program should be clear and easy to read. This requires good style. Good style saves time writing the program and getting it to work A sloppy program looks unprofessional.</p>
<p>Comments</p>
<ul>
<li>In Sigma16, a semicolon  indicates that the rest of the line is a comment</li>
<li>You can have a full line comment: just put ; at the beginning</li>
<li>You should use good comments in all programs, regardless of language</li>
<li>But they are even more important in machine language, because the code needs more explanation</li>
<li>At the beginning of the program, use comments to give the name of the program and to say what it does</li>
<li>Use a comment on every instruction to explain what it’s doing</li>
</ul>
<p>Indent your code consistently. Each field should be lined up vertically, like this:</p>
<pre><code>    load   R1,three[R0]  ; R1 = 3
    load   R2,x[R0]      ; R2 = x
    mul    R3,R1,R2      ; R3 = 3*x
    store  R3,y[R0]      ; y = 3*x
    trap   R0,R0,R0      ; stop the program</code></pre>
<p>Not like this:</p>
<pre><code>    load   R1,three[R0]     ; R1 = 3
  load  R2,x[R0] ; R2 = x
       mul R3,R1,R2           ; R3 = 3*x
 store         R3,y[R0]      ; y = 3*x
   trap  R0,R0,R0      ; stop the program</code></pre>
<p>The exact number of spaces each field is indented isn’t important; what’s important is to make the program neat and readable.</p>
<p>To indent your code, always use spaces – Don’t use tabs! In general, never use tabs except in the (rare) cases they are actually required.</p>
<p>The tab character was introduced to try to mimic the tab key on old mechanical typewriters But . If you use tabs, your can look good in one application and a mess in another It’s easy to indent with spaces, and it works everywhere!</p>
<h2 id="compilation">Compilation</h2>
<p>There are two ways to handle variables:</p>
<p>The statement-by-statement style: Each statement is compiled independently. The pattern is: load, arithmetic, store. Straightforward but inefficient.</p>
<p>The register-variable style: Keep variables in registers across a group of statements. Don’t need as many loads and stores. More efficient. You have to keep track of whether variables are in memory or a register. Use comments to show register usage. Real compilers use this style. Use this style if you like the shorter code it produces.</p>
<p>We’ll translate the following program fragment to assembly language, using each style:</p>
<pre><code>x = 50;
y = 2*z;
x = x+1+z;</code></pre>
<p>Statement-by-statement style</p>
<pre><code>; x = 50;
     lea    R1,$0032   ; R1 = 50
     store  R1,x[R0]   ; x = 50

; y = 2*z;
     lea    R1,$0002   ; R1 = 2
     load   R2,z[R0]   ; R2 = z
     mul    R3,R1,R2   ; R3 = 2*z
     store  R3,y[R0]   ; y = 2*z

; x = x+1+z;
     load   R1,x[R0]   ; R1 = x
     lea    R2,1[R0]   ; R2 = 1
     load   R3,z[R0]   ; R3 = z
     add    R4,R1,R2   ; R4 = x+1
     add    R4,R4,R3   ; R4 = x+1+z
     store  R4,x[R0]   ; x = x+1+z</code></pre>
<p>Register-variable style</p>
<pre><code>; Usage of registers
;   R1 = x
;   R2 = y
;   R3 = z

; x = 50;
     lea    R1,$0032   ; x = 50
     load   R3,z[R0]   ; R3 = z
     lea    R4,$0002   ; R4 = 2
; y = 2*z;
     mul    R2,R4,R3   ; y = 2*z
; x = x+1+z;
     lea    R4,$0001   ; R4 = 1
     add    R1,R1,R4   ; x = x+1
     add    R1,R1,R3   ; x = x+z
     store  R1,x[R0]   ; move x to memory
     store  R2,y[R0]   ; move y to memory</code></pre>
<p>Comparison of the styles</p>
<p>Statement by statement. * Each statement is compiled into a separate block of code. * Each statement requires loads, computation, then stores. * A variable may appear in several different registers. * There may be a lot of redundant loading and storing. * The object code corresponds straightforwardly to the source code, but it may be unnecessarily long.</p>
<p>Register variable * The instructions corresponding to the statemnts are mixed together. * Some statements are executed entirely in the registers. * A variable is kept in the same register across many statments. * The use of loads and stores is minimised. * The object code is concise, but it’s harder to see how it corresponds to the source code. * It’s possible to have a mixture of the styles: you don’t have to follow one or the other all the time.</p>
<h2 id="conditionals">Conditionals</h2>
<p>if bexp then S</p>
<pre><code>if x&lt;y
  then {statement 1;}
statement 2;</code></pre>
<p>Translates into</p>
<pre><code>   R7 := (x &lt; y)
   jumpf R7,skip[R0]
   instructions for statement 1
skip
   instructions for statement 2 </code></pre>
<p>Example: code with if-then. Source program fragment:</p>
<pre><code>x := 2;
if y&gt;x
   then { a := 5; }
b := 6;</code></pre>
<p>Translating if-then</p>
<pre><code>; x := 2;
      lea     R1,2[R0]    ; R1 := 2
      store   R1,x[R0]    ; x := 2

; if y&gt;x
      load    R1,y[R0]    ; R1 := y
      load    R2,x[R0]    ; R2 := x
      cmpgt   R3,R1,R2    ; R3 := (y&gt;x)
      jumpf   R3,skip[R0] ; if y &lt;= x then goto skip

;  then { a := 5; }
      lea    R1,5[R0]     ; R1 := 5
      store  R1,a[R0]     ; a := 5

; b := 6;
skip  lea    R1,6[R0]     ; R1 := 6
      store  R1,b[R0]     ; b := 6</code></pre>
<p>if-then-else</p>
<p>if bexp then S1 else S2</p>
<pre><code>if x&lt;y
  then { S1 }
  else { S2 }
S3</code></pre>
<p>Compiled into: ~~~~ R5 := (x&lt;y) jumpf R5,else[R0] ; then part of the statement instructions for S1 jump done[R0] ; else part of the statement else instructions for S2 done instructions for statement S3 ~~~~</p>
<h2 id="loops">Loops</h2>
<p>while loop</p>
<p>while b do S</p>
<pre><code>while i&lt;n do
  { S1 }
S2</code></pre>
<p>Compiled into: ~~~~ loop R6 := (i&lt;n) jumpf R6,done[R0] … instructions for the loop body S1 … jump loop[R0] done instructions for S2 ~~~~</p>
<p>Infinite loops</p>
<pre><code>while (true)
  {statements} </code></pre>
<p>Compiled into:</p>
<pre><code>loop
   ... instructions for the loop body ...
   jump   loop[R0] </code></pre>
<p>Nested statements</p>
<p>For each kind of high level statement, there is a pattern for translating it to Low level code (goto) and then on to<br />
assembly language.</p>
<p>In larger programs, there will be nested statements.</p>
<pre><code>if b1
  then { S1;
         if b2 then {S2} else {S3};
         S4;
       }
  else { S5;
         while b3 do {S6};
       }
S7</code></pre>
<p>How to compile nested statements</p>
<p>A block is a sequence of instructions. To execute it, always start with the first statement. When it finishes, it always reaches the last statement.</p>
<p>Every statement should be compiled into a block of code. This block may contain internal structure — it may contain several smaller blocks — but to execute it you should always begin at the beginning and it should always finish at the end. The compilation patterns work for nested statements.</p>
<p>You need to use new labels (can’t have a label like ``skip’’ in several places).</p>
<h2 id="machine-language">Machine language</h2>
<ul>
<li>The actual bits representing an instruction (written in hex) —  – is </li>
<li>The actual hardware runs the machine language — it’s just looking at the numbers</li>
<li>The text notation with names —  — is </li>
<li>Assembly language is for humans, machine language is for machines</li>
<li>Both , down to the last bit</li>
</ul>
<p>What’s in the memory</p>
<ul>
<li><p>All your program’s data</p></li>
<li>Variables</li>
<li><p>Data structures, arrays, lists</p></li>
<li><p></p></li>
</ul>

<p>Instruction formats: different types of instruction</p>
<p>Sigma16 has several instruction formats</p>
<ul>
<li> instructions use the </li>
<li> instructions use the </li>
<li> instructions use </li>
</ul>
<p>Each kind of instruction is called an instruction format. All the instructions with the same format are similar Each instruction format has a standard representation in the memory.</p>
<p>The machine language program is in the memory So we need to represent each instruction as a word An instruction format is a systematic way to represent an instruction using a string of bits, on one or more words. Every instruction is either RRR, RX, or EXP</p>
<ul>
<li>An RRR instruction is represented in one word (recall that a word is 16 bits).</li>
<li>An RX instruction is represented in two words.</li>
</ul>
<p>Fields of an instruction word</p>
<p>An instruction word has 16 bits. There are four fields, each 4 bits. We write the value in a field using hexadecimal. hex digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f. These correspond to 0, 1, …, 15</p>
<p>The names of the fields are:</p>
<ul>
<li>op – holds the operation code</li>
<li>d – usually holds the destination register</li>
<li>a – usually holds the first source operand register</li>
<li>b – usually holds the second source operand register</li>
</ul>
<h3 id="representing-rrr-instructions">Representing RRR instructions</h3>
<p>Every RRR instruction consists of</p>
<ul>
<li>An operation (e.g. add)</li>
<li>Three register operands: a destination and two operands</li>
<li>The instruction performs the operation on the operands and puts the result in the destination</li>
</ul>
<p>Example: add R3,R12,R5. We need to specify  RRR instruction this is. Is it add? sub? mul? another? This is done with an operation code — a number that says what the operation is. There are about a dozen RRR instructions, so a 4-bit operation code suffices. We also need to specify three registers: destination and two source operands. There are 16 registers, so a particular one can be specified by 4 bits. Total requirements: 4 fields, each 4 bits — total 16 bits. An RRR instruction exactly fills one word.</p>
<p>All RRR instructions have the same form, just the operation differs</p>
<ul>
<li>add R2,R2,R5 ; R2 = R2 + R5</li>
<li>sub R3,R1,R3 ; R3 = R1 - R3</li>
<li>mul R8,R6,R7 ; R8 = R6 * R7</li>
</ul>
<p>In add R2,R5,R9 we call R5 the first operand, R9 the second operand, and R2 the destination. It’s ok to use the same register as an operand and destination! Later we’ll see some more RRR instructions, obut they all have the same form as these do.</p>
<p>Here are the RRR operation codes:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">mnemonic</th>
<th style="text-align: center;">opcode</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">add</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">sub</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">mul</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="even">
<td style="text-align: center;">div</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">trap</td>
<td style="text-align: center;">d</td>
</tr>
</tbody>
</table>
<p>Don’t memorise this table! You just need to understand how it’s used.</p>
<p>Example of RRR:</p>
<pre><code>add  R13,R6,R9</code></pre>
<ul>
<li>The opcode (operation code) is 0</li>
<li>Destination register is 13 (hex d)</li>
<li>Source operand registers are 6 and 9 (hex 6 and 9)</li>
<li>So the instruction is 0d69</li>
</ul>
<h3 id="representing-rx-instructions">Representing RX instructions</h3>
<p>Every RX instruction contains two operands:</p>
<ul>
<li>A </li>
<li>A </li>
</ul>
<p>We have seen several so far:</p>
<ul>
<li>lea R5,19[R0] ; R5 = 19</li>
<li>load R1,x[R0] ; R1 = x</li>
<li>store R3,z[R0] ; z = R3</li>
<li><p>jump finished[R0] ; goto finished</p></li>
<li>The first operand (e.g. R1 here) is called the destination register, just like for RRR instructions</li>
<li>The second operand x[R0] specifies a memory address</li>
<li><p>Each variable is kept in memory at a specific location which is identified by its address</p></li>
</ul>
<p>The memory operand has two parts:</p>
<ul>
<li>The variable x is a name for the address where x is kept — called the displacement.</li>
<li>The R0 part is just a register, called the index register.</li>
</ul>
<p>Format of RX instruction</p>
<p>{ ~~~~ load R1,x[R0] ~~~~ }</p>
<ul>
<li>There are two words in the machine language code</li>
<li><p>The first word has 4 fields: op, d, a, b</p></li>
<li>op contains f for every RX instruction</li>
<li>d contains the register operand (in the example, 1)</li>
<li>a contains the index register (in the example, 0)</li>
<li><p>b contains a code indicating  RX instruction this is (1 means load)</p></li>
<li><p>The second word contains the displacement (address) (in the example, the address of x)</p></li>
</ul>
<p>Suppose x has memory address 0008. Then the machine code for load R1,x[R0] is:</p>

<p>Operation codes for RX instructions</p>
<ul>
<li>Recall, for RRR the op field contains a number saying  RRR instruction it is</li>
<li>For RX, the op field </li>
<li>So how does the machine know  RX instruction it is?</li>
<li>Answer: there is a secondary code in the b field</li>
</ul>

<h2 id="instruction-execution">Instruction execution</h2>
<p>Boot: reading in the program</p>
<ul>
<li>The program is placed in memory starting at location 0</li>
<li>The program should finish by executing the instruction ``trap R0,R0,R0’’</li>
<li>Normally, trap R0,R0,R0 should be the last instruction of the program (i.e. the program begins execution with the first instruction, and ends execution with the last, although it may jump around during execution)</li>
<li>After the trap R0,R0,R0 come the data statements, which tell the assembler the names of the variables and their initial values</li>
<li>These conventions were typical for early computers; later we will discuss how the operating system interacts with user programs</li>
</ul>
<p>Control registers</p>
<ul>
<li>Some of the registers in the computer are accessible to the programmer: R0, R1, R2, <span class="math inline">…</span>, R15</li>
<li>There are several more registers that {the machine uses to keep track of what it’s doing}</li>
<li>These are called </li>
<li>They are (mostly) invisible to the program</li>
</ul>
<p>Keeping track of where you are</p>
<p>When you hand execute a program, you need to know</p>
<ul>
<li>Where you are (point a finger at the current instruction)</li>
<li>What you’re doing (read the current instruction)</li>
</ul>
<p>The computer needs to know this too!</p>
<ul>
<li>The  (``program counter’’) contains  to be executed</li>
<li>The  (``instruction register’’) contains </li>
<li>If an RX instruction is being executed, the  (``address register’’) contains  of the second operand.</li>
</ul>
<p>Following PC and IR control registers</p>
<ul>
<li>Try running a simple program</li>
<li>Step through the execution</li>
<li>Before each instruction executes, look at the PC and IR registers</li>
<li>Notice that PC always contains the  and IR always contains the </li>
<li>{The control registers help to understand in detail what the machine is doing.}</li>
</ul>
<h2 id="effective-addresses-and-arrays">Effective addresses and arrays</h2>
<h3 id="address-arithmetic">Address arithmetic</h3>
<h3 id="why-r0">Why [R0]?</h3>
<ul>
<li><p>So far, we have always been writing [R0] after constants or names</p></li>
<li>lea R2,39</li>
<li>load R3,xyz</li>
<li><p>store R4,total</p></li>
<li>Why?</li>
<li><p>This is part of a general and powerful technique called </p></li>
</ul>
<h3 id="address-arithmetic-1">Address arithmetic</h3>
<ul>
<li>Every piece of data in the computer (in registers, or memory) is a </li>
<li><p>A word can represent several different kinds of data</p></li>
<li>So far, we’ve just been using </li>
<li><p>Represented with : <span class="math inline"> − 2<sup>15</sup>, …,  − 1, 0, 1, 2, …, 2<sup>15</sup> − 1</span></p></li>
<li>Now, we’ll start doing computations with  too</li>
<li><p>Addresses are : <span class="math inline">0, 1, 2, …, 65535</span></p></li>
</ul>
<h3 id="what-can-you-do-with-address-arithmetic">What can you do with address arithmetic?</h3>
<ul>
<li><p>Powerful data structures</p></li>
<li> Arrays</li>
<li>Pointers and records</li>
<li><p>Linked lists, queues, dequeues, stacks, trees, graphs, hash tables, <span class="math inline">…</span> Subject of </p></li>
<li><p>Powerful control structures</p></li>
<li>Input/Output</li>
<li>Procedures and functions</li>
<li>Recursion</li>
<li>Case dispatch</li>
<li><p>Coroutines, classes, methods</p></li>
</ul>
<h2 id="effective-addresses-and-arrays-1">Effective addresses and arrays</h2>
<p>Data structures</p>
<ul>
<li>An ordinary variable holds one value (e.g. an integer)</li>
<li>A  can hold many individual elements</li>
<li>A data structure is a </li>
<li>The simplest data structure: </li>
<li>There are many more data structures!</li>
<li>The key idea: {we will do arithmetic on addresses}</li>
</ul>
<p>Arrays</p>
<ul>
<li><p>In mathematics, an array (vector) is a sequence of indexed values <span class="math inline"><em>x</em><sub>0</sub>, <em>x</em><sub>1</sub>, …, <em>x</em><sub><em>n</em> − 1</sub></span></p></li>
<li><span class="math inline"><em>x</em></span> is the entire array</li>
<li><span class="math inline"><em>x</em><sub>3</sub></span> is one specific element of the array with index 3</li>
<li><p>It’s useful to refer to an arbitrary element by using an integer variable as index: <span class="math inline"><em>x</em><sub><em>i</em></sub></span></p></li>
<li>Arrays are ubiquitous: used in all kinds of applications</li>
<li><p>In programming languages, we refer to <span class="math inline"><em>x</em><sub><em>i</em></sub></span> as </p></li>
</ul>
<h3 id="representing-an-array">Representing an array</h3>
<ul>
<li>An array is represented in a computer by placing the elements in consecutive memory locations</li>
<li>The array x starts in memory at some location: here, it’s 01a5</li>
<li>The address of the array x is the address of its first element x[0]</li>
<li>The elements follow in consecutive locations</li>
</ul>




<p>Allocating an array</p>
<ul>
<li>An array is in memory along with other data — after the trap that terminates the program</li>
<li>You can allocate the elements and give them initial value with data statements</li>
<li>Use the name of the array as a label on the first element (the one with index 0)</li>
<li>Don’t put labels on the other elements</li>
</ul>
<pre><code>   ...
      trap   R0,R0,R0  ; terminate

; Variables and arrays

abc   data    25       ; some variable
n     data     6       ; size of array x

x     data    13       ; x[0]
      data   189       ; x[1]
      data   870       ; x[2]
      data    42       ; x[3]
      data     0       ; x[4]
      data  1749       ; x[5]

def   data     0       ; some other variable</code></pre>
<p>What about big arrays?</p>
<ul>
<li>In the programs we’ll work with, the arrays will be small (a dozen elements or so)</li>
<li>In real scientific computing, it’s common to have large arrays with thousands — or even millions — of elements</li>
<li>It would be horrible to have to write thousands of data statements!</li>
<li><p>In large scale software, arrays are allocated  with help from the </p></li>
<li>The user program calculates how large an array it wants, and stores that in a variable (e.g. n = 40000)</li>
<li>It uses a trap to request (from the operating system) a block of memory big enough to hold the array</li>
<li><p>The operating system returns the address of this block to the user program</p></li>
<li><p>We won’t be doing this: we will just allocate small arrays using data statements</p></li>
</ul>
<p>Indexed addressing</p>
<ul>
<li>Suppose we have array x with elements x[0], x[1], …, x[n-1]</li>
<li>Elements are stored in consecutive memory locations</li>
<li>Use the label x to refer to the array; x is also the location of x[0]</li>
<li>{The address of x[i] is x+i}</li>
<li>To do any calculations on x[i], we must load it into a register, or store a new value into it</li>
<li></li>
<li>If you try  the effect will be R4 := x[0]</li>
<li>We need a way to access x[i] where i is a variable</li>
</ul>
<p>Effective address</p>
<ul>
<li><p>An RX instruction specifies addresses in two parts, for example  or  or </p></li>
<li>The  is a 16 bit constant (you can write the number, or use a name — the assembler will put in the address for you)</li>
<li><p>The  is written in brackets</p></li>
<li>The machine adds the displacement to the value in the index register — this is called the </li>
<li><p>The instruction is performed using the effective address</p></li>
</ul>
<p>Using the effective address</p>
<p>The addressing mechanism is flexible!</p>
<ul>
<li>You can access an ordinary variable:\ \ R0 always contains 0, so the effective address is just the address of sum</li>
<li>You can access an array element: if R8 contains an index i, then\ \ will load x[i] into R2</li>
<li>There’s more: effective addresses are used to implement pointers, functions, procedures, methods, classes, instances, jump tables, case dispatch, coroutines, records, interrupt vectors, lists, heaps, trees, forests, graphs, hash tables, activation records, stacks, queues, dequeues, <span class="math inline">…</span></li>
</ul>
<p>Addressing modes</p>
<ul>
<li>An  is a scheme for specifying the address of data</li>
<li>Sigma16 has one addressing mode: displacement[index], e.g. x[R4]</li>
<li>Many older computers provided many addressing modes: one for variables, another for arrays, yet another for linked lists, still another for stacks, and so on</li>
<li>It’s more efficient to provide just one or two flexible addressing modes, rather than a big collection of them</li>
</ul>
<p>Using effective address for an array</p>
<p>Suppose we want to execute </p>
<pre><code>    lea   R1,50[R0]   ; R1 := 50
    load  R5,i[R0]    ; R5 := i
    load  R6,x[R5]    ; R6 := x[i]
    add   R6,R6,R1    ; R6 := x[i] + 50
    store R6,x[R5]    ; x[i] := x[i] + 50</code></pre>
<h2 id="array-traversal-and-for-loops">Array traversal and for loops</h2>
<p>A typical operation on an array is to traverse it; this means to perform a calculation on each element. Here’s a loop that doubles each element of x:</p>
<pre><code>i := 0;
while i &lt; n do
  { x[i] := x[i] * 2;
    i := i + 1;
  }</code></pre>
<p>For loops</p>
<ul>
<li>A for loop is designed specifically for array traversal</li>
<li>It handles the loop index automatically</li>
<li>It sets the index to each array element index and executes the body</li>
<li>The intuition is do the body for every element of the array</li>
</ul>
<pre><code>for i := exp1 to exp2 do
   { statements }</code></pre>
<p>Array traversal with while and for</p>
<p>Here is the program that doubles each element of x, written with both constructs</p>
<pre><code>i := 0;
while i &lt; n do             for i := 0 to n-1 do
  { x[i] := x[i] * 2;          { x[i] := x[i] * 2; }
    i := i + 1;
  }</code></pre>
<p>Translating the for loop to low level</p>
<p>High level for loop (with any number of statements in the body) ~~~~ for i := exp1 to exp2 do { statement1; statement2; } ~~~~</p>
<p>Translate to low level with this pattern:</p>
<pre><code>       i := exp1;
loop:  if i &gt; exp2 then goto loopdone;
       statement1;
       statement2;
       i := i + 1;
       goto loop;
loopdone:</code></pre>
<p>It’s straightforward to complete the translation to assembly language.</p>
<p>Alternative syntax for for loops</p>
<p>In languages derived from C (C++, Java, C#, and many more) you will see for loops written like this:</p>
<pre><code>for (i=x; i&lt;y; i++)
   { S1; }
S2;</code></pre>
<p>Example program ArrayMax</p>
<ul>
<li>A complete programming example</li>
<li>The problem: find the maximum element of an array</li>
<li><p>To do this we need to</p></li>
<li>Allocate an array</li>
<li>Loop over the elements</li>
<li>Access each element</li>
<li><p>Perform a conditional</p></li>
<li><p>This example puts all our techniques together into one program</p></li>
</ul>
<p>State what the program does</p>
<p>; Program ArrayMax</p>
<p>;——————————————————————— ; The program finds the maximum element of an array. It is given ; * a natural number n, assume n&gt;0 ; * an n-element array x[0], x[1], …, x[n-1] ; and it calculates ; * max = the maximum element of x</p>
<p>; Since n&gt;0, the array x contains at least one element, and a maximum ; element is guaranteed to exist. ~~~~ }</p>
<h3 id="high-level-algorithm">High level algorithm}</h3>
<p>;——————————————————————— ; High level algorithm</p>
<p>; max := x[0]; ; for i := 1 to n-1 do ; { if x[i] &gt; max ; then max := x[i]; ; } ~~~~</p>
<p>Translate high level code to low level ``goto form’’</p>
<p>It’s easier to check that this low level is equivalent to both the high level algorithm and the assembly language, rather than translating all the way to assembly language in one giant step.</p>
<pre><code>; Low level algorithm

;     max := x[0]
;     i := 1
; forloop:
;     if i &gt;= n then goto done
;     if x[i] &lt;= max then goto skip
;     max := x[i]
; skip:
;     i := i + 1
;     goto forloop
; done:
;     terminate</code></pre>
<p>Specify how the registers are used</p>
<p>The program is written in the ``register variable style’’.</p>
<pre><code>
;---------------------------------------------------------------------
; Assembly language

; Register usage
;   R1 = constant 1
;   R2 = n
;   R3 = i
;   R4 = max</code></pre>
<p>}</p>
<p>Block of statements to initialise registers</p>
<pre><code>; Initialise
       lea    R1,1[R0]         ; R1 = constant 1
       load   R2,n[R0]         ; R2 = n
; max := x[0]
       load   R4,x[R0]         ; R4 = max = x[0]
; i := 1
       lea    R3,1[R0]         ; R3 = i = 1</code></pre>
<p>Beginning of loop</p>
<pre><code>; Top of loop, determine whether to remain in loop
forloop
; if i &gt;= n then goto done
       cmp    R3,R2            ; compare i, n
       jumpge done[R0]         ; if i&gt;=n then goto done

Body of loop: if-then

; if x[i] &lt;= max then goto else
       load   R5,x[R3]         ; R5 = x[i]
       cmp    R5,R4            ; compare x[i], max
       jumple skip[R0]         ; if x[i] &lt;= max then goto skip

; max := x[i]
       add   R4,R5,R0          ; max := x[i]

End of loop

skip
; i := i + 1
       add    R3,R3,R1         ; i = i + 1
; goto forloop
       jump   forloop[R0]      ; go to top of forloop


Finish

; Exit from forloop
done   store R4,max[R0]        ; max = R4
; terminate
       trap  R0,R0,R0          ; terminate</code></pre>
<p>Data definitions</p>
<pre><code>; Data area

n        data   6
max      data   0
x        data  18
         data   3
         data  21
         data  -2
         data  40
         data  25</code></pre>
<h2 id="procedures-call-and-return">Procedures: call and return</h2>
<h2 id="the-call-stack">The call stack</h2>
<h3 id="variables">Variables</h3>
<h3 id="access-to-variables">Access to variables</h3>
<ul>
<li>Depending on the programming language, there are several different ways that variables can be allocated</li>
<li>For each of these, there is a corresponding way to access the variable in memory</li>
<li><p>Three key issues:</p></li>
<li>The  of a variable: when it is created, when it is destroyed</li>
<li>The  of a variable: which parts of the source program are able to access the variable</li>
<li><p>The  of a variable: what its address in memory is</p></li>
<li><p>The compiler generates the correct object code to access each variable</p></li>
</ul>
<h3 id="three-classes-of-variable">Three classes of variable</h3>
<ul>
<li> (Sometimes called ) — visible through the entire program</li>
<li> (Sometimes called ) — visible only in a local procedure</li>
<li> (Sometimes called ) — used in object oriented and functional languages</li>
</ul>
<h3 id="static-variables">Static variables</h3>
<ul>
<li><p>The lifetime of a static variable is the entire execution of a program</p></li>
<li>When the program is launched, its static variables are created</li>
<li><p>They continue to exist, and to retain their values, until the program is terminated</p></li>
<li>In C, you can declare a variable to be static. In Pascal, all global variables (i.e. all variables that aren’t defined locally) are static</li>
<li><p></p></li>
</ul>
<h3 id="combining-static-variables-with-code">Combining static variables with code</h3>
<p>The simple way we have been defining variables makes them static</p>
<pre><code>     load  R1,x[R0]    ; R1 := x
   ...
     trap  R0,R0,R0    ; terminate

; Static variables

x    data    0
n    data  100</code></pre>
<p>These variables exist for the entire program execution. There is one variable x, and one variable n.</p>
<h3 id="disadvantages-of-combining-variables-and-code">Disadvantages of combining variables and code</h3>
<ul>
<li><p>The executable code cannot be shared.</p></li>
<li>Suppose two users want to run the program.</li>
<li>Each needs to have a copy of the entire object, which contains both the instructions and the data</li>
<li>That means the instructions are duplicated in memory</li>
<li><p>This is inefficient use of memory</p></li>
<li>To avoid the duplication of instructions, we need to separate the data from the code</li>
<li><p>Modern operating systems organise information into </p></li>
<li>A  is read-only, and can be shared</li>
<li><p>A  is read/write, and cannot be shared</p></li>
</ul>
<h3 id="local-variables">Local variables</h3>
<ul>
<li>Local variables are defined in a function, procedure, method, or in a begin…end block, or a {…} block</li>
<li>A local variable has one name, but there may be many instances of it if the function is recursive</li>
<li>Therefore local variables cannot be stored in the static data segment</li>
<li>They are kept in stack frames</li>
<li>The compiler (or assembler) works out the address of each local variable </li>
<li>The variables are accessed using the stack frame register</li>
</ul>
<h3 id="accessing-local-variables">Accessing local variables</h3>
<pre><code>      load  R1,x[R14]   ; access local variable x; R14 points to frame</code></pre>
<p>}</p>
<ul>
<li>The compiler (or the programmer) works out the exact format of the stack frame</li>
<li>Each local variable has a dedicated spot in the stack frame, and its address (relative to the frame) is used in the load instruction</li>
</ul>
<h3 id="dynamic-variables">Dynamic variables</h3>
<ul>
<li>A  is created explicitly (e.g. using  in Java)</li>
<li>It is not limited to use in just one function</li>
<li>The lifetime of a dynamic variable does not need to follow the order that stack frames are pushed or popped</li>
<li>So dynamic variables can’t be kept in the static data segment, and they can’t be kept on the stack</li>
</ul>
<h3 id="the-heap">The Heap</h3>
<ul>
<li>Languages that support dynamic variables (Lisp, Scheme, Haskell, Java) have a region of memory called the .</li>
<li>The heap typically contains a very large number of very small objects</li>
<li>The heap contains a , a data structure that points to all the free words of memory.</li>
<li>The heap is maintained by the language ``runtime system’’, not by the operating system.</li>
<li>When you do a , a (small) amount of memory is allocated from the heap and a pointer (address) to the object is returned</li>
<li>When the object is no longer required, the memory used to hold it is linked back into the free space list.</li>
</ul>
<h3 id="the-call-stack-1">The call stack</h3>
<ul>
<li>Each procedure call pushes information on the stack</li>
<li>The information needed by the procedure is in the stack frame (also called activation record)</li>
<li>Each procedure return pops information off the stack</li>
<li><p>A register is permanently used as the </p></li>
<li>For each computer architecture, there is a standard register chosen to be the stack pointer</li>
<li>In Sigma16, R14 is the stack pointer</li>
<li>When you call, you push a new stack frame and increase R14</li>
<li>As a procedure runs, it access its data via R14</li>
<li><p>When you return, you set R14 to the stack frame below</p></li>
</ul>
<h3 id="simplest-stack-return-addresses">Simplest stack: return addresses</h3>

<p>Just save the return address on the stack</p>
<h3 id="saved-registers">Saved registers</h3>

<p>Save the registers the procedure needs to use on the stack, and restore them before returning. This way the procedure won’t crash the caller</p>
<h3 id="dynamic-links">Dynamic links</h3>

<p> (dlink3.east) to [out=0, in=0] (dlink2.north east);  (dlink2.east) to [out=0, in=0] (dlink1.north east);</p>
<ul>
<li>Problem: since each activation record can have a different size, how do we pop the top one off the stack?</li>
<li>Simplest solution: each activation record contains a pointer (called dynamic link) to the one below</li>
</ul>
<h3 id="local-variables-1">Local variables</h3>

<p> (dlink3.east) to [out=0, in=0] (dlink2.north east);  (dlink2.east) to [out=0, in=0] (dlink1.north east);</p>
<p>The procedure keeps its local variables on the stack</p>
<h3 id="static-links-for-scoped-variables">Static links for scoped variables</h3>

<p> (dlink3.east) to [out=0, in=0] (dlink2.north east);  (dlink2.east) to [out=0, in=0] (dlink1.north east);</p>
<h3 id="accessing-a-word-in-the-stack-frame">Accessing a word in the stack frame</h3>
<ul>
<li>Work out a ``map’’ showing the format of a stack frame</li>
<li>Describe this in comments (it’s similar to the register usage comments we’ve been using)</li>
<li>Suppose local variable, say ``avacado’’, is kept at position 7 in the stack frame</li>
<li><p>To access the variable:</p></li>
<li>load R1,7[R14] ; R1 := avacado</li>
<li>store R1,7[R14] ; R1 := avacado</li>
<li>Also, we can define the symbol ``avacodo’’ to be 7, and write:</li>
<li>load R1,avacado[R14] ; R1 := avacado</li>
<li><p>store R1,avacado[R14] ; R1 := avacado</p></li>
<li><p>These are called  because every call to a procedure has its own private copy</p></li>
</ul>
<h3 id="example-from-factorial-program-see-below">Example from factorial program (see below)</h3>
<p>These comments document the structure of a stack frame for the program:</p>
<pre><code>; Structure of stack frame for fact function
;    6[R14]   origin of next frame
;    5[R14]   save R4
;    4[R14]   save R3
;    3[R14]   save R2
;    2[R14]   save R1 (parameter n)
;    1[R14]   return address
;    0[R14]   pointer to previous stack frame</code></pre>
<p>}</p>
<h3 id="recursive-factorial">Recursive factorial</h3>
<ul>
<li>In the Sigma16 examples, there is a program called </li>
<li>This program illustrates the full stack frame technique</li>
<li>It uses recursion — a function that calls itself</li>
<li>Note: the best way actually to compute a factorial is with a simple loop,  with recursion</li>
<li>But recursion is an important technique, and it’s better to study it with a simple example (like factorial) rather than a complicated ``real world’’ example</li>
</ul>
<h3 id="about-the-factorial-program">About the factorial program</h3>
<ul>
<li>Comments are used to identify the program, describe the algorithm, and document the data structures.</li>
<li>Blank lines and full-line comments organise the program into small sections.</li>
<li>The caller just uses jal to call the function.</li>
<li>The function is responsible for building the stack frame, saving and restoring registers.</li>
<li>The technique of using the stack for functions is general, and can be used for large scale programs.</li>
</ul>
<h3 id="statement-of-problem-and-register-usage">Statement of problem, and register usage</h3>
<p>;———————————————————————– ; factorial.asm.txt ;———————————————————————–</p>
<p>; This program for the Sigma16 architecture uses a recursive function ; to compute x! (factorial of x), where x is defined as a static ; variable.</p>
<p>; The algorithm uses a recursive definition of factorial: ; if n &lt;=1 ; then factorial n = 1 ; else factorial n = n * factorial (n-1)</p>
<p>; Register usage ; R15 is reserved by architecture for special instructions ; R14 is stack pointer ; R13 is return address ; R2, R3, R4 are temporaries used by factorial function ; R1 is function parameter and result ; R0 is reserved by architecture for constant 0</p>
<h3 id="format-of-main-program-stack-frame">Format of main program stack frame</h3>
<p>;———————————————————————– ; Main program</p>
<p>; The main program computes result := factorial x and terminates.</p>
<p>; Structure of stack frame for main program ; 1[R14] origin of next frame ; 0[R14] pointer to previous stack frame = nil</p>
<h3 id="main-program-initialisation">Main program initialisation</h3>
<p>; Initialise stack lea R14,stack[R0] ; initialise stack pointer store R0,0[R14] ; previous frame pointer := nil</p>
<h3 id="main-program-calls-factorial">Main program calls factorial</h3>
<p>; Call the function to compute factorial x load R1,x[R0] ; function parameter := x store R14,1[R14] ; point to current frame lea R14,1[R14] ; push stack frame jal R13,factorial[R0] ; R1 := factorial x</p>
<h3 id="main-program-finishes">Main program finishes</h3>
<p>; Save result and terminate store R1,result[R0] ; result := factorial x trap R0,R0,R0 ; terminate</p>
<h3 id="description-of-factorial-function">Description of factorial function</h3>
<p>;———————————————————————– factorial ; Function that computes n! ; Input parameter n is passed in R1 ; Result is returned in R1</p>
<h3 id="format-of-stack-frame-for-factorial">Format of stack frame for factorial</h3>
<p>; Structure of stack frame for fact function ; 6[R14] origin of next frame ; 5[R14] save R4 ; 4[R14] save R3 ; 3[R14] save R2 ; 2[R14] save R1 (parameter n) ; 1[R14] return address ; 0[R14] pointer to previous stack frame</p>
<h3 id="factorial-build-stack-frame">Factorial: build stack frame</h3>
<p>; Create stack frame<br />
store R13,1[R14] ; save return address store R1,2[R14] ; save R1 store R2,3[R14] ; save R2 store R3,4[R14] ; save R3 store R4,5[R14] ; save R4 ~~~~</p>
<h3 id="factorial-check-for-base-or-recursion-case">Factorial: check for base or recursion case</h3>
<pre><code>; Initialise
     lea    R2,1[R0]           ; R2 := 1

; Determine whether we have base case or recursion case
     cmpgt  R10,R1,R2           ; R10 := n&gt;1
     jumpt  R10,recursion[R0]   ; if n&gt;1 then go to recursion case</code></pre>
<h3 id="factorial-base-case">Factorial: base case</h3>
<pre><code>; Base case.  n&lt;=1 so the result is 1
     lea    R1,1[R0]           ; factorial n = 1
     jump   return[R0]         ; go to end of function</code></pre>
<h3 id="factorial-recursion-case">Factorial: recursion case</h3>
<pre><code>; Recursion case.  n&gt;1 so factorial n = n * factorial (n-1)
recursion
     sub    R1,R1,R2           ; function paramemter := n-1

; Call function to compute factorial (n-1)
     store  R14,6[R14]         ; point to current frame
     lea    R14,6[R14]         ; push stack frame
     jal    R13,factorial[R0]  ; R1 := factorial (n-1)
     load   R2,2[R14]          ; R2 := saved R1 = n
     mul    R1,R2,R1           ; R1 := n * fact (n-1)

### Factorial: restore registers and return
</code></pre>
<p>; Restore registers and return; R1 contains result return load R2,3[R14] ; restore R2 load R3,4[R14] ; restore R3 load R4,5[R14] ; restore R4 load R13,1[R14] ; restore return address load R14,0[R14] ; pop stack frame jump 0[R13] ; return ~~~~</p>
<p>Static data area</p>
<pre><code>; Static data segment

x       data   5
result  data   0
stack   data   0   ; stack extends from here on...</code></pre>
<p>Summary</p>
<ul>
<li><p>Variables defined with data statement are static</p></li>
<li>Each static variable must have a unique name</li>
<li><p>Static variables exist through entire execution of program</p></li>
<li><p>Variables defined in a procedure are local</p></li>
<li>Different procedures can use the same name for different variables</li>
<li>Local variables are kept in the stack frame</li>
<li>Call–push stack frame; return–pop stack frame</li>
<li><p>R14 points to current stack frame; local variables are accessed using R14</p></li>
</ul>
<h2 id="records">Records</h2>
<h2 id="pointers">Pointers</h2>
<h2 id="further-topics">Further topics</h2>
<p>To run the program slowly, click Step repeatedly. To run the program faster but without updating the display after each instruction, click Run. At any time you can click Pause to stop the processor, and you can resume execution with either Step or Run.</p>
<p>There are two independent views into the memory; this is convenient for looking at the machine language code in one view and the data in the other view. (Despite the two views, there is just one memory!) At this point the pc register contains 0, meaning that the next instruction to be executed is the one in memory location 0. The ir and other registers also contain 0, but that is just the initial value.</p>
<p>To set a breakpoint, click Breakpoint and enter the stopping condition in the dialogue box. For example, to stop when the pc register becomes $01b7, enter BPeq BPpc (BPhex “01b7”). Then click Run, and the emulator will run at full speed until the pc reaches the specified value; then it will stop so you can examine the state of the machine.</p>
<h1 id="architecture">Architecture</h1>
<p>Our focus is on fundamental concepts, ideas and principles. Sigma16 illustrates the fundementals of computer systems but it avoids unnecessary complexity. For example, Sigma16 has just one word size (16 bits) while most commercial machines provide a variety. That variety is useful for practical applications but it complicates many of the details while not adding any new fundamental ideas. Most commercial computers that achieve success in the marketplace eventually become encrusted with complications that help support backward compatibility; this can lead to great complexity.</p>
<h2 id="data-representation-and-notation">Data representation and notation</h2>
<p>Sigma16 is a 16-bit architecture, and every data value is a 16-bit word. Integers are represented in 16-bit two’s complement notation. The bits of a word are numbered from left to right, starting with 0. Thus the leftmost (most significant) bit of a word is bit 0, and the rightmost (least significant) is bit 15.</p>
<p>The value of a word can be written in several ways:</p>
<ul>
<li>An unsigned integer between 0 and 65,535 (2^16 - 1)</li>
<li>A signed integer between -32,768 and 32,767 (-2^15 and 2^15 - 1)</li>
<li>A 4-digit hexadecimal constant, where the digits are 0-9 a-f. Sometimes, when the context is clear, this is written as just the hex digits (e.g 3b2f). In assembly language programs, hex constants are written with a preceding $ sign (e.g. $3b2f). This is necessary to avoid ambiguity: 1234 is a decimal number and $1234 is a hexadecimal number. In contexts where there is no ambiguiity, the $ may be omitted: for example, the GUi shows register and memory contents as hexadecimal without the leading $.</li>
</ul>
<p>Some machine operations act on individual bits in a word. We will use the notation word.n to indicate bit n in the word, where the bits are numbered from 0 at the left (most significant) position up to 15 at the rightmost (least significant) position. For example the fourth bit of R15 can be written as R15.3.</p>
<p>A <em>field</em> is a consecutiave sequence of bits within a word. For example, we will later define a field named <em>op</em> which consists of bits 0-3 of a word; this means the leftmost four bits of the word.</p>
<h2 id="overview-of-the-subsystems">Overview of the subsystems</h2>
<p>The system contains several main subsystems. The most important of these are <em>registers</em>, <em>memory</em>, and <em>logic and arithmetic</em>, and <em>Input/Output</em>. These are described in detail later, but here is a brief synopsis:</p>
<ul>
<li><p>A register is a digital circuit that can retain one word of data. A new value can be loaded into a register, and the current contents may be read out. There are a number of special registers as well as a <em>register file</em> that contains 16 registers.</p></li>
<li><p>The memory can hold a large number of words. It’s similar to the register file, but significantly slower and much larger.</p></li>
<li><p>The ALU (arithmetic and logic unit) is a circuit that can do arithmetic, such as addition, subtraction, comparison, and some other operations</p></li>
<li><p>The Input/Output system can transfer data between the computer and the outside world.</p></li>
</ul>
<h2 id="register-file">Register file</h2>
<p>The <strong>register file</strong> is a set of 16 general registers that hold a 16 bit word. A register is referenced by a 4-bit binary number. In assembly language, we use the notations R0, R1, R2, …, R9, R10, R11, R12, R13, R14, R15 to refer to the registers. The state of the register file can be written as a table showing the value of each register:</p>
<p>Register Contents ~~~~~~~~~~ ~~~~~~~~~~ R0 0000 R1 fffe R2 13c4 … … R14 03c8 R15 0020</p>
<p>Sigma16 is a load/store style architecture; that is, it does not combine memory accesses with arithmetic. All calculations are carried out in the register file, and explicit load and store instructions must be used to copy data between the memory and the register file.</p>
<p>There are some programming conventions that use certain registers for special purposes. The hardware does not enforce, or even know about, these conventions, and you do not have to follow the conventions in programming. However, it is necessary to obey the conventions in order to use the standard software libraries in your program. See the section on Programming for a discussion of these standard usage conventions.</p>
<h3 id="r0-holds-the-constant-0">R0 holds the constant 0</h3>
<p>One of the registers, R0, has a special property: it always contains the constant 0. It is legal to perform an instruction that attempts to load some other value into R0, but the register will still contain 0 after executing such an instruction. Such an instruction will simply have no lasting effect.</p>
<h3 id="r15-is-the-condition-code-register">R15 is the condition code register</h3>
<p>Several instructions produce status information: the result of a comparison, whether there was an overflow, etc. This information is automatically loaded into R15, which is the condition code register. The description of each instruction states whether R15 is modified, and what goes into it.</p>
<p>The bits in R15 are indexed from bit 0 (the most significant, or lefttmost bit) to bit 15 (the least significant, or rightmost). The condition code bits that have specific meanings are called <em>flags</em>.</p>
<p>Table: Condition code flags</p>
<table>
<tr>
<th>
Bit
</th>
<th>
Flag
</th>
<th>
Symbolic name
</th>
<th>
Meaning
</th>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>G</strong>
</td>
<td>
sysccG
</td>
<td>
gt (or gt 0) unsigned (binary)
</td>
</tr>
<tr>
<td>
1
</td>
<td>
<strong>g</strong>
</td>
<td>
sysccg
</td>
<td>
gt (or gt 0) signed (two’s complement)
</td>
</tr>
<tr>
<td>
2
</td>
<td>
<strong>E</strong>
</td>
<td>
sysccE
</td>
<td>
= (or =0) word, signed, unsigned
</td>
</tr>
<tr>
<td>
3
</td>
<td>
<strong>l</strong>
</td>
<td>
sysccl
</td>
<td>
lt (or lt 0) signed (two’s complement)
</td>
</tr>
<tr>
<td>
4
</td>
<td>
<strong>L</strong>
</td>
<td>
sysccL
</td>
<td>
lt (or lt 0) unsigned (binary)
</td>
</tr>
<tr>
<td>
5
</td>
<td>
<strong>V</strong>
</td>
<td>
sysccV
</td>
<td>
unsigned overflow (binary)
</td>
</tr>
<tr>
<td>
6
</td>
<td>
<strong>v</strong>
</td>
<td>
sysccv
</td>
<td>
signed overflow (two’s complement)
</td>
</tr>
<tr>
<td>
7
</td>
<td>
<strong>C</strong>
</td>
<td>
sysccC
</td>
<td>
carry propagation (binary)
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</table>
<p>The condition code flags are defined to make the condition code easier to read in hex:</p>
<ul>
<li><p>The first (leftmost) hex digit holds the comparison flags</p></li>
<li><p>The second hex digit holds the carry and overflow flags</p></li>
<li><p>The third hex digit holds the stack error flags</p></li>
</ul>
<p>conditional jump</p>
<p>jumpc0 jump if cc bit is 0 jumpc1 jump if cc bit is 1</p>
<h2 id="memory">Memory</h2>
<p>The memory is a hardware array of words that are accessed by address. A memory address is 16 bits wide, and there is one memory location corresponding to each address, so there are 2^16 = 64k memory locations. Each memory location is a 16-bit word.</p>
<p>Instructions specify memory addresses in two parts: the <em>displacement</em>, which is a word representing a binary number, and the <em>index</em>, which is one of the registers in the register file. For example, a memory address could be specified as $003c[R5]; the displacement is 003c and the index is R5.</p>
<p>When the instruction is executed, the computer calculates the <em>effective address</em> by adding the value of the displacement and the value in the index register. If R5 contains 2, then the effective address of $003c[R5] is 003e.</p>
<p>This scheme may seem more complicated than simply specifying the address directly, but it is extraordinarily flexible. If the machine language just gave the address as a single binary number, it would be limited to accessing simple static variables. The effective address mechanism is simple to implement in hardware, as you can see in the digital circuit processor, yet it allows the implementation of local variables, records, arrays, pointers and linked data structures, jump tables, and more. These techniques are described later.</p>
<h2 id="control-registers">Control registers</h2>
<p>There are several instruction control registers that enable the processor to keep track of the state of the running program. These registers are rarely used directly by the machine language program, but they are essential for keeping track of the execution of the program, and some instructions use them directly.</p>
<ul>
<li><p>ir – instruction register (16-bit word)</p></li>
<li><p>pc – program counter (16-bit word)</p></li>
<li><p>adr – address register (16-bit word)</p></li>
<li><p>dat – data register (16-bit word)</p></li>
<li><p>status – collection of control flags</p></li>
</ul>
<h3 id="status-register-flags">Status register flags</h3>
<p>The processor can be executing in several modes, which are determined by the <strong>system control registers</strong>.</p>
<ul>
<li><p>sys (bit 0) – system state (1-bit flag)</p></li>
<li><p>ie (bit 1) – interrupts enabled (1-bit flag)</p></li>
</ul>
<p>Table: Processor status flags</p>
<table>
<tr>
<th>
Bit
</th>
<th>
Flag
</th>
<th>
Meaning
</th>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>U</strong>
</td>
<td>
User state
</td>
</tr>
<tr>
<td>
1
</td>
<td>
<strong>E</strong>
</td>
<td>
Interrupts enabled
</td>
</tr>
</table>
<h3 id="interrupts-and-exceptions">Interrupts and exceptions</h3>
<ul>
<li><p>mask</p></li>
<li><p>req</p></li>
<li><p>istat</p></li>
<li><p>ipc</p></li>
<li><p>vect</p></li>
</ul>
<h3 id="mask-and-request-flags">Mask and request flags</h3>
<table>
<tr>
<th>
Bit
</th>
<th>
Flag
</th>
<th>
Meaning
</th>
</tr>
<tr>
<td>
0
</td>
<td>
Trap
</td>
<td>
Trap
</td>
</tr>
<tr>
<td>
0
</td>
<td>
Trap
</td>
<td>
Trap
</td>
</tr>
<tr>
<td>
1
</td>
<td>
Overflow
</td>
<td>
Trap
</td>
</tr>
<tr>
<td>
2
</td>
<td>
Div0
</td>
<td>
Trap
</td>
</tr>
<tr>
<td>
3
</td>
<td>
StackFault
</td>
<td>
Trap
</td>
</tr>
<tr>
<td>
4
</td>
<td>
SegFault
</td>
<td>
Trap
</td>
</tr>
<tr>
<td>
5
</td>
<td>
Privelege
</td>
<td>
Trap
</td>
</tr>
<tr>
<td>
6
</td>
<td>
Timer
</td>
<td>
Interrupt
</td>
</tr>
<tr>
<td>
7
</td>
<td>
Input
</td>
<td>
Interrupt
</td>
</tr>
<tr>
<td>
8
</td>
<td>
Output
</td>
<td>
Interrupt
</td>
</tr>
</table>
<h2 id="instruction-representation">Instruction representation</h2>
<p>Instructions are represented in the memory of the computer using words, just like all other kinds of data. From the programmer’s perspective, an instruction is like a simple statement in a programming language. From the circuit designer’s perspective, however, instructions must be processed using logic gates, and the specific way it is represented as a word of bits is important.</p>
<p>An instruction specifies several pieces of information. For example, add R1,R2,R3 is an instruction that says four things: it’s an addition, the result goes into R1, and the operands come from R2 and R3. Therefore to represent instructions we need to organize a word as a collection of several <em>fields</em>, with each field giving one specific piece of information about the instruction.</p>
<p>The particular scheme for describing an instruction as a collection of fields is called an <em>instruction format</em>. Like most computers, Sigma16 has a small number of instruction formats and a larger number of instructions. The key to understanding the interface between machine language and digital circuit design is to master the instruction formats.</p>
<p>The core architecture (the simplest part of the system) uses just the RRR format (for instructions that perform operations in the registers) and the RX format (for instructions that refer to a memory location.) The advanced parts of the architecture provide additional instructions which are represented with the EXP format.</p>
<h3 id="instruction-fields">Instruction fields</h3>
<p>An instruction may consist of one word or two words, depending on the instruction format. These words are subdivided into 4-bit <em>fields</em>, each with a unique name:</p>
<pre><code>   ---------------------
   | op |  d |  a |  b |
   ---------------------
   |  e |  f |  g |  h |
   ---------------------</code></pre>
<p>Some instruction formats combine two of the 4-bit fields to form a larger field:</p>
<ul>
<li>The a and b fields may be combined to form an 8-bit field called ab</li>
<li>The g and h fields may be combined to form an 8-bit field called gh</li>
<li>The e, f, g, h fields may be combined to form a 16-bit field called disp</li>
</ul>
<table class="wordlayout"">
 <tr>
  <th>op</th>
  <th>d</th>
  <th>a</th>
  <th>b</th>
 </tr>
 <tr>
  <td>0-3</td>
  <td>4-7</td>
  <td>8-11</td>
  <td>12-15</td>
 </tr>
</table>
<p>Every instruction has a 4-bit field called the opcode (op for short). This gives 16 values of the opcode: 14 of them (0 through 13) denote the 14 RRR instructions, described later. If the op field is 14 (hex e) the instruction is EXP format and has a secondary opcode in the a and b fields. If the op field contains 15 (hex f) the instruction is RX format with a secondary opcode in the b field. The instruction formats are described below.</p>
<p>The first word of every instruction contains the following fields.</p>
<ul>
<li>op (bits 0-3) opcode, determines instruction format</li>
<li>d (bits 4-7) 4-bit destination</li>
<li>a (bits 8-11) 4-bit operand</li>
<li>b (bits 12-15) 4-bit operand, or expanded opcode for RX</li>
<li>ab (bits 8-15) 8-bit expanded opcode for EXP</li>
</ul>
<p>A second word is needed to represent RX, EXP4 and EXP8 formats. There are individual names for the individual 4-bit fields, as well as names (disp, gh) for larger fields.</p>
<ul>
<li>e (bits 0-3) 4-bit operand</li>
<li>f (bits 4-7) 4-bit operand</li>
<li>g (bits 8-11) 4-bit operand</li>
<li>h (bits 12-15) 4-bit operand</li>
<li>gh (bits 8-15) 8-bit operand</li>
<li>disp (bits 0-15) 16 bit operand “displacement”</li>
</ul>
<p>There are two kinds of format: the machine instruction formats, and the assembly language instruction statement formats. There are three machine instruction formats: RRR, RX, EXP0, EXP4, EXP8. However, there is a larger set of assembly language statement formats, because there are special syntaxes for some instructions, and there are assembler directives that aren’t instructions at all. The assembly language formats are described later.</p>
<p>The core architecture has only two instruction formats: RRR and RX.</p>
<h3 id="rrr-format">RRR format</h3>
<p>RRR instructions perform operations on data in registers, but not referring to memory. The representation is one word.</p>
<p>RRR instructions: op is the operation code which determines the instruction; op must be between 0 and 13 (hex 0 to hex d). The destination register is Rd, the operands are Ra and Rb.</p>
<pre><code>---------------------
| op |  d |  a |  b |
---------------------</code></pre>
<h3 id="rx-format">RX format</h3>
<p>RX instructions that specify a memory location as well as a register operand. The representation is two words.</p>
<p>RX instructions are two words, where op=15, b contains the secondary opcode which specifies which RX instruction it is, d is the destination, a is the index register, and the second word is a 16 bit constant called the displacement (often written disp for short).</p>
<pre><code>---------------------
| op |  d |  a |  b |
---------------------
|    displacement   |
---------------------</code></pre>
<h3 id="exp0-format">EXP0 format</h3>
<p>An EXP0 instruction is one word, and only one operand field (the d field) is available. (There are 0 fields in the second word; hence the name EXP0.) The op field contains e, and the a and b fields are combined to form an 8-bit opcode.</p>
<p>An EXP instruction contains 14 (hex e) in the op field, and the a and b fields are combined into a single 8-bit number that contains a secondary opcode. This means that the EXP format allows for 256 instructions. This greatly expands the number of instructions that can be accommodated, and it allows for experimental instructions for research purposes. (The name EXP stands simultaneously for both EXPansion and EXPerimentation.)</p>
<p>The EXP0 format is one word, where op=14 (hex e) and the a and b fields are combined into an 8-bit secondary operation code. There is only one operand, Rd.</p>
<pre><code>---------------------
| op |  d |    ab   |
---------------------</code></pre>
<h3 id="exp4-format">EXP4 format</h3>
<p>An EXP4 instruction instruction is two words, with a 4-bit operand in the first word and four more in the second word. (It’s called EXP4 because the second word contains 4 4-bit operands.)</p>
<p>The EXP4 format is two words. As with all EXP instructions, ab gives an expanded operation code. In EXP4, the second word contains four 4-bit fields e, f, g, h, which may contain register numbers or 4-bit constants.</p>
<pre><code>---------------------
| op |  d |    ab   |
---------------------
|  e |  f |  g |  h |
---------------------</code></pre>
<h3 id="exp8-format">EXP8 format</h3>
<p>An EXP8 instruction is two words, with three 4-bit operands and an 8-bit operand. (It’s called EXP8 because it provides an 8-bit operand.)</p>
<p>The following table summarises the instruction formats. The core of the architecture needs only the first two (RRR and RX). The more advanced features require the</p>
<p>The EXP8 format is similar to EXP4, except that the g and h fields are combined to form n 8-bit constant.</p>
<pre><code>---------------------
| op |  d |    ab   |
---------------------
|  e |  f |    gh   |
---------------------</code></pre>
<h3 id="summary-of-instruction-formats">Summary of instruction formats</h3>
<table style="width:79%;">
<caption><strong>Machine language instruction formats</strong></caption>
<colgroup>
<col style="width: 12%" />
<col style="width: 9%" />
<col style="width: 12%" />
<col style="width: 15%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Format</th>
<th style="text-align: center;">Size</th>
<th style="text-align: center;">Opcode</th>
<th style="text-align: center;">Operands</th>
<th style="text-align: center;">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">op</td>
<td style="text-align: center;">d,a,b</td>
<td style="text-align: center;">add Rd,Ra,Rb</td>
</tr>
<tr class="even">
<td style="text-align: center;">RX</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">op,b</td>
<td style="text-align: center;">d,disp,a</td>
<td style="text-align: center;">load Rd,disp[Ra]</td>
</tr>
<tr class="odd">
<td style="text-align: center;">EXP0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">op,ab</td>
<td style="text-align: center;">d</td>
<td style="text-align: center;">rfi</td>
</tr>
<tr class="even">
<td style="text-align: center;">EXP4</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">op,ab</td>
<td style="text-align: center;">d,e,f,g,h</td>
<td style="text-align: center;">extract Re,Rf,Rg,Rh</td>
</tr>
<tr class="odd">
<td style="text-align: center;">EXP8</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">op,ab</td>
<td style="text-align: center;">d,e,f,gh</td>
<td style="text-align: center;">save Rd,Re,gh[Rf]</td>
</tr>
</tbody>
</table>
<h3 id="assembly-language-statement-formats">Assembly language statement formats</h3>
<p>Assembly language statements generally correspond to the instruction formats, but there is not an exact correspondence for several reasons:</p>
<ul>
<li><p>Sometimes an instruction is written in assembly language with a field omitted which exists in the machine language code but is ignored. For example, the instruction <em>inv R1,R2</em> generates an RRR instruction, but the third operand field is omitted because the invert function takes only one operand, not two.</p></li>
<li><p>Sometimes two instructions look the same in assembly language but use different machine language instruction formats. For example, <em>add R1,R2,R3</em> and <em>push R1,R2,R3</em> look similar, but <em>add</em> uses the RRR instruction format and <em>push</em> uses the EXP4 instruction format. The reason for this is that there are not enough bits in the op field to accommodate all the instructions with three register operands, so an <em>expanding opcode</em> is used. Thus push is represented with op=14 (indicating EXP format), and the EXP4 variant is used for this instruction.</p></li>
<li><p>The 4-bit fields are sometimes used to denote a register from the register file (R3), or a control register (mask), or a constant . In assembly language the constants are written just as a number (e.g. shiftl R1,R2,5). Control registers are written by name rather than their number in the control register file (e.g. getctl R3,mask).</p></li>
</ul>
<table style="width:82%;">
<caption><strong>Assembly language statement formats</strong></caption>
<colgroup>
<col style="width: 11%" />
<col style="width: 31%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: right;">Asm E</th>
<th style="text-align: left;">xample</th>
<th style="text-align: center;">ML formats</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">RRR RX</td>
<td style="text-align: left;">add Rd,Ra,Rb lea Rd,disp[Ra]</td>
<td style="text-align: center;">RRR RX</td>
</tr>
<tr class="even">
<td style="text-align: right;">RR JX KX</td>
<td style="text-align: left;">inv Rd,Ra jump disp[Ra] jumpc0 d,disp[Ra]</td>
<td style="text-align: center;">RRR (b ignored), RREXP RX (b ignored) RX (d is constant)</td>
</tr>
<tr class="odd">
<td style="text-align: right;">NO RRK RRKK RREXP RCEXP</td>
<td style="text-align: left;">rfi shiftl Rd,Ra,k getbit Re,Rf,g,h execute Re,Rf getctl Re,Cf</td>
<td style="text-align: center;">EXP0 (d ignored) EXP4 EXP4 (d ignored) EXP4 EXP4</td>
</tr>
</tbody>
</table>
<h3 id="rrr-format-1">RRR format</h3>
<p>An RRR instruction contains an operation code (op), and specifies three operands registers using the d, sa, and sb fields. It is represented as one word, which is divided into four fields:</p>
<ul>
<li>op (4 bits, starting from bit 0) Operation code
<ul>
<li>d (4 bits, starting from bit 4) Destination register</li>
<li>sa (4 bits, starting from bit 8) Source a register</li>
<li>sb (4 bits, starting from bit 12) Source b register</li>
</ul></li>
</ul>
<table class="wordlayout"">
  <tr>
    <th>op</th>
    <th>d</th>
    <th>a</th>
    <th>b</th>
  </tr>
  <tr>
    <td>d</td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
  </tr>
  <tr>
    <td>0-3</td>
    <td>4-7</td>
    <td>8-11</td>
    <td>12-15</td>
  </tr>
</table>
<p>The op field of an RRR instruction must be in the range from 0 through 13 (hex 0 through d). This allows for a total of 14 distinct RRR instructions. If the op field is outside this range, it indicates an “expanding opcode”: 14 (hex e) indicates the EXP format, and 15 (hex f) indicates the RX format.</p>
<p>A RRR instruction is written with an instruction name (menonic) and three register operands. For example, the “trap” instruction has mnemonic 13 (and the hex value of 13 is d), so the assembly language “trap R4,R12,R2” is translated to machine language as d4c2.</p>
<p>In most cases, an RRR instruction takes two operands in registers specified by the a and b fields and produces a result which is loaded into the register specified by the d field. A typical example of an RRR instruction is add R4,R9,R2, which adds the contenst of registers R9 and R2, and loads the result into R4. It’s equivalent to R4 := R9 + R2.</p>
<h3 id="rx-format-1">RX format</h3>
<p>The RX instruction format is used for instructions that use a memory address, which is specified by an index register and a displacement. The name of the format describes briefly the two operands: a register (R) and an indexed memory address (X).</p>
<p>An RX instruction contains two operands: one is a memory address, and the other is a register. Typical RX instructions are loads, stores, and jumps. The instruction consists of two consecutive words. The first has the same format as an RRR instruction, with four fields: op, d, sa, sb. The second word is a single 16-bit binary number, and is called the displacement.</p>
<p>The memory address is specified in two parts: an index register and the displacement. The index register is specified in the sa field. In assembly language, the notation used is number[reg], where the number is the value of the displacement, and the reg is the index register. Thus $20b3[R2] means the address has displacement $20b3 and the index register is R2.</p>
<p>When the machine executes an RX instruction, it begins by calculating the effective address. This is abbreviated “ea”, and its value is the sum of the displacement and the contents of the index register.</p>
<p>RX instructions are represented in two words, and they use an “expanding opcode”. That is, the op field of the first word of the instruction contains the constant f (the bits 1111) for every RX instruction, and the sb field is used to hold a secondary opcode indicating which RX instruction it is.</p>
<p>The register operand is specified in the d field. For several RX instructions, this is indeed the destination of the instruction: for example, load places data into Rd. However, a few RX instructions use the d field differently (see, for example, the conditional jump instructions).</p>
<p>The memory address is specified using the sa field and the displacement, which is the entire second word of the instruction.</p>
<ul>
<li>op field (bits 0-3 of ir) is f for all RX instructions
<ul>
<li>d field (bits 4-7 of ir) has several uses</li>
<li>a field (bits 8-11 of ir) is index register for effective address</li>
<li>b field (bits 12-15 of ir) is secondary opcode</li>
<li>disp (displacement) is the second word of the instruction</li>
<li>ea (effective address) = displacement + r[a]</li>
</ul></li>
</ul>
<h3 id="exp-format">EXP format</h3>
<p>The EXP instruction format is used for expanded instructions that are not represented using the RRR or RX formats. It provides many unused opcodes, so it is useful for experimental instructions. The name EXP stands simultaneously for <em>expansion</em> and <em>experimental</em>.</p>
<p>There are several sub-formats, or variations, of the EXP format. These are described in more detail below. Most of the sub-formats represent an instruction with two words.</p>
<ul>
<li><p>The first word has the same fields as for RRR and RX instructions: the 4-bit fields op, d, a, b. All EXP instructions have a constant hex e in the op field, which indicates the EXP format. The a and b fields together form an 8-bit secondary opcode (this is called the ab field), allowing for 256 distinct EXP instructions. The d field in the first word, and all of the second word (if any), hold operands which depend on the particular variant of the EXP format.</p></li>
<li><p>The second word (if it appears) contains four 4-bit fields named e, f, g, h. In some variants these hold separate 4-bit values, while in some cases g and h form a single 8-bit value (called the gh field).</p></li>
</ul>
<p>First word of the instruction</p>
<table class="wordlayout"">
<tr>
<th>op</th>
<th>d</th>
<th>a</th>
<th>b</th>
</tr>
<tr>
<td>0-3</td>
<td>4-7</td>
<td>8-11</td>
<td>12-15</td>
</tr>
</table>
<p>Second word of the instruction</p>
<table class="wordlayout"">
  <tr>
    <th>e</th>
    <th>f</th>
    <th>g</th>
    <th>h</th>
  </tr>
  <tr>
    <td>0-3</td>
    <td>4-7</td>
    <td>8-11</td>
    <td>12-15</td>
  </tr>
</table>
<p>To summarise, an EXP instruction may use the fields op, d, ab, e, f, g, h. The g and h fields can be combined into a single 8-bit field gh All EXP instructions combine the a and b fields into a single 8-bit field called ab. Some EXP instructions combine the g and h fields into a single 8-bit field called gh.</p>
<p>The EXP format has the following variants.</p>
<ul>
<li><p>EXP0 format takes no operands. The instruction format uses just one word (there is no second word with the e, f, g, h fields). The op field contains 14 (hex e), the d field is ignored (the assembler sets it to 0), and the ab field contains an 8 bit expanded operation code. Example: <em>rfi</em> is an instruction with no operands and with secondary opcode 0. Its representation is e000. The EXP0 format allows rfi to be represented in one word without using up one of the limited and valuable opcodes avaiable for RRR instructions.</p></li>
<li><p>The RREXP format takes two register operands, which are in the e and f fields of the second word. The d field of the first word and the g and h fields of the second word are ignored (the assembler will set these to 0). Any RREXP instruction could be reprsented as RRR, but there are only a few RRR opcodes avaiable, so uncommon instructions that require two registers are represented as RREXP. Example: <em>execute R5,R6</em> is RREXP.</p></li>
<li><p>The RCEXP format takes two register operands; the first is a general register and the second is a control register. An example of the operand field is <em>R3,mask</em>. The operands are in the e and f fields of the second word. The d field of the first word and the g and h fields of the second word are ignored (the assembler will set these to 0.) The first operand is an element of the register file (for example, R4). The second operand is a control register, which is specified by a 4-bit number. In assembly language, we normally refer to the control registers by name rather than number, to make it easier to remember which is which. For example, <em>getctl R3,status</em> has RCEXP format.</p></li>
<li><p>The RRREXP format takes three register operands, which are in the f, g, and h fields of the second word. An example of the operand field is $R1,R2,R3<em>. The d field of the first word and the e field of the second word are ignored (the assembler will set these to 0). The RRREXP instructions would be a natural fit for the RRR format, but there are not enough RRR opcodes available, so the EXP format is used to expand the number of instructions that can be represented. For example, </em>push R5,R8,R9* has RRREXP format.</p></li>
<li><p>The RRKEXP format takes two register operands and a 4-bit constant number. An example of the operand field is <em>R1,R2,13</em>. The register operands are in the f and g fields of the second word, and constant is in the h field of the second word. The d field of the first word and the e field of the second word are ignored (the assembler sets these to 0). For example, <em>shiftr R3,R6,7</em> has RRKEXP format.</p></li>
<li><p>The RRKKEXP format takes two register operands and two 4-bit constant binary number operands. The register operands are in the e and f fields of the second word, while the two constants are in the g and h fields. The d field of the first word is ignored (the assembler sets it to 0).</p></li>
<li><p>The RRXEXP format takes two register operands as well as a memory address specified with an 8-bit offset and index register. Thus these instructions require three registers to be specified, as well as the offset. Thus every bit of both instruction words is needed to represent an RRXEXP format instruction. In assembly language, the memory address is written as <em>offset[Rh]</em> where <em>offset</em> is an -bit binary number and Rh is a register. The effective memory address is <em>offset+Rh</em>. This is similar to ordinary memory addresses; the only difference is that it uses an 8-bit offset rather than a 16-bit displacement. For example, <em>save R1,R9,2[R14]</em> has RRKEXP format.</p></li>
</ul>
<h1 id="instruction-set">Instruction set</h1>
<p>The following sections describe the instructions in groups organized by their function. Some of the groups contain instructions with different formats. From the programmer’s perspective the function is more important, so these groups are useful in finding the right instruction to use. (From the perspective of designing a digital circuit to impleemnt the architecture, the format is essential.)</p>
<h2 id="arithmetic-instructions">Arithmetic instructions</h2>
<p>The add instruction can be used for both binary addition (on natural numbers) and for two’s complement addition (on signed integers).</p>
<ul>
<li><p>16-bit natural numbers are unsigned integers 0, 1, 2, …, 65535. If two natural numbers are added, the result is a natural number (the result cannot be negative). If the result is 65536 or larger, it cannot be represented as a 16 bit binary number. If this happens, the destination register is set to the lower 16 bits of the true result, and the binary overflow flag is set in the Condition Code.</p></li>
<li><p>16-bit two’s complement numbers are signed integers -32999?, …, -1, 0, 1, …, 32???. If two signed integers are added, the result is a signed integer. If the result is less than -32000 or greater than 32000, then the result cannot be represented as a 16 bit two’s complement number. If this happens, the destination register is set to the lower 16 bits of the true result, and the two’s complement overflow flag is set in the Condition Code. Furthermore, the overflow flag is set in the req register. If interrupts are enabled and the overflow flag is 1 in the mask register, then an interrupt will occur immediatelhy after the add instruction executes.</p></li>
</ul>
<h3 id="add">add</h3>
<p>The instruction add Rz,Rx,Ry has operands Rx and Ry and destination Rz. It fetches the operands reg[x] and reg[y], calculates the sum reg[x] + reg[y], and loads the result into the destination reg[z]. The effect is reg[z] := reg[x] + reg[y]. For example, add R5,R12,R2 performs R5 := R12 + R3.</p>
<p>The add instruction is RRR format with opcode=0. Given destination z and operands x and y (where z, x, y are hex digits), add Rz,Rx,Ry is reprseented by 0zxy.</p>
<table>
<thead>
<tr class="header">
<th>de As</th>
<th>sembly Ef</th>
<th style="text-align: left;">fect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>062c</td>
<td>add R6,R2,R12</td>
<td style="text-align: left;">; R6 := R2 + R12</td>
</tr>
<tr class="even">
<td>0d13</td>
<td>add R13,R1,R3</td>
<td style="text-align: left;">; R13 := R1 + R3</td>
</tr>
</tbody>
</table>
<p>In addition to setting the destination register, the add instruction sets several bits in the condition code R15 and may set a bit in the req register.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">R15.ccG</td>
<td style="text-align: center;">result &gt;bin 0</td>
</tr>
<tr class="even">
<td style="text-align: center;">R15.ccg</td>
<td style="text-align: center;">result &gt;tc 0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">R15.ccE</td>
<td style="text-align: center;">result = 0</td>
</tr>
<tr class="even">
<td style="text-align: center;">R15.ccl</td>
<td style="text-align: center;">result &lt;tc 0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">R15.CCL</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">R15.ccV</td>
<td style="text-align: center;">bin overflow</td>
</tr>
<tr class="odd">
<td style="text-align: center;">R15.CCv</td>
<td style="text-align: center;">tc overflow</td>
</tr>
<tr class="even">
<td style="text-align: center;">R15.CCc</td>
<td style="text-align: center;">carry output</td>
</tr>
</tbody>
</table>
<h3 id="sub">sub</h3>
<p>sub R1,R2,R3</p>
<h3 id="mul">mul</h3>
<p>The multiply instruction calculates the integer (two’s complement) product of the operands Ra and Rb, and places the result in the destination register Rd.</p>
<p>If the magnitude of the product is too large to be representable as a 16 bit two’s complement integer, this is an overflow. If this happens, the integer overflow bit is set in the condition code (F15) and the integer overflow bit is also set in the interrupt request register (req), and the lower order 16 bits of the product are loaded into Rd.</p>
<h3 id="div">div</h3>
<h3 id="addc">addc</h3>
<p>The <strong>binary add with carry</strong> instruction <em>addc Rd,Re,Rf</em> calculates the sum of the binary numbers in the operand registers Re and Rf as well as the carry bit in the condition code. The sum is loaded into the destination register Rd and the carry output is set in the condition code register. Overflow is not possible with this instruction.</p>
<h2 id="accessing-memory">Accessing memory</h2>
<h3 id="lea">lea</h3>
<p>The <strong>load effective address</strong> instruction <em>lea Rd,disp[Rx]</em> calculates the effective address of the operand disp[Rx] and places the result in the destination register Rd. The effective address is the binary sum disp+Rx.</p>
<h3 id="load">load</h3>
<p>The <strong>load</strong> instruction <em>load Rd,disp[Rx]</em> calculates the effective address of the operand disp[Rx] and copies the word in memory at the effective address into the destination register Rd. The effective address is the binary sum disp+Rx.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">general form</td>
<td style="text-align: left;">load Rd,disp[Ra]</td>
</tr>
<tr class="even">
<td style="text-align: left;">effect</td>
<td style="text-align: left;">reg[Rd] := mem[disp+reg[Ra]]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">machine format</td>
<td style="text-align: left;">RX</td>
</tr>
<tr class="even">
<td style="text-align: left;">assembly format</td>
<td style="text-align: left;">RX</td>
</tr>
</tbody>
</table>
<p>Examples ~~~~ load R12,count[R0] ; R12 := count load R6,arrayX[R2] ; R6 := arrayX[R2] load R3,$2b8e[R5] ; R3 := mem[2b8e+R5] ~~~~</p>
<h3 id="store">store</h3>
<p>The <strong>store</strong> instruction <em>store Rd,disp[Rx]</em> calculates the effective address of the operand disp[Rx] and the value of the destination register Rd into memory at the effective address. The effective address is the binary sum disp+Rx.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">general form</td>
<td style="text-align: left;">store Rd,disp[Ra]</td>
</tr>
<tr class="even">
<td style="text-align: left;">effect</td>
<td style="text-align: left;">mem[disp+reg[Ra]] := reg[Rd]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">machine format</td>
<td style="text-align: left;">RX</td>
</tr>
<tr class="even">
<td style="text-align: left;">assembly format</td>
<td style="text-align: left;">RX</td>
</tr>
</tbody>
</table>
<p>Store copies the word in the destination register into memory at the effective address. This instruction is unusual in that it treats the “destination register” as the source of data, and the actual destination which is modified is the memory location.</p>
<p>Most instructions take data from the rightmost operands and modify the leftmost destination, just like an assignment statement (x := y+z). However, the store instruction operates in the opposite direction. The reason for this has to do with the circuit design of the processor. Although the “left to right” nature of the store instruction may look inconsistent from the programmer’s point of view, it actually is more consistent from the deeper perspective of circuit design.</p>
<p>Examples</p>
<pre><code>   store  R3,$2b8e[R5]
   store  R12,count[R0]
   store  R6,arrayX[R2]</code></pre>
<h3 id="save">save</h3>
<p>The <strong>save</strong> instruction stores a sequence of adjacent registers into memory starting from the effective address. It is equivalent to a fixed sequence of store instructions. The purpose of save is to copy the state of registers into memory during a procedure call or a context switch.</p>
<p>Typically, save is used as part of a procedure call and restore is used as part of the return.</p>
<p>The instruction <em>save Rd,Re,gh[Rf]</em> stores the contents of Rd, Rd+1, …, Re into memory at consecutive locations beginning with mem[gh+Rf].</p>
<p>The instruction is EXP format, and the displacement is limited to 8 bits, because it is specified in the gh field (the rightmost 8 bits) of the second word of the instruction.</p>
<p>For example, consider this instruction: ~~~~ save R3,R10,4[R14] ~~~~</p>
<p>The effect is equivalent to</p>
<pre><code>   store  R3,4[R14]
   store  R4,5[R14]
   store  R5,6[R14]
   store  R6,7[R14]
   store  R7,8[R14]
   store  R8,9[R14]
   store  R9,10[R14]
   store  R10,11[R14]</code></pre>
<h3 id="restore">restore</h3>
<p>The <strong>restore</strong> instruction copies a sequence of consecutive memory locations starting from the effecive address into a sequence of adjacent registers. It is equivalent to a fixed sequence of load instructions. The purpose of restore is to restore the state of registers from memory after a procedure call or a context switch.</p>
<p>Typically, save is used as part of a procedure call and restore is used as part of the return.</p>
<p>The instruction <em>restore Rd,Re,gh[Rf]</em> copies the contents of memory at consecutive locations beginning with mem[gh+Rf] into registers Rd, Rd+1, …, Re.</p>
<p>The instruction is EXP format, and the displacement is limited to 8 bits, because it is specified in the gh field (the rightmost 8 bits) of the second word of the instruction. The assembly language statement format is RRXEXP.</p>
<p>For example, consider this instruction: ~~~~ restore R3,R10,4[R14] ~~~~</p>
<p>The effect is equivalent to</p>
<pre><code>   load  R3,4[R14]
   load  R4,5[R14]
   load  R5,6[R14]
   load  R6,7[R14]
   load  R7,8[R14]
   load  R8,9[R14]
   load  R9,10[R14]
   load  R10,11[R14]</code></pre>
<h3 id="push">push</h3>
<p>push R1,R2,R3</p>
<p>R1 = value to push onto stack in memory R2 = stack top R3 = stack limit</p>
<p>Push the word in R1 onto a stack with top R2 and limit R3. If the stack is full, nothing is stored into memory and an error is indicated in the condition code and interrupt request registers; an interrupt will occur if interrupts are enabled and the stack mask bit is set.</p>
<p>Push has the following semantics:</p>
<p>if R2&lt;R3 then R2 := R2+1; mem[R2] := R1 else R15.sovfl := 1, req.StackBounds := 1</p>
<p>If R2=R3 this means the stack completely fills the block, and there is no space to store a new element. In this case, the push instruction does not store R1: it doesn’t modify memory outside the block, and it doesn’t overwrite data in the stack. Instead, the instruction indicates a stack overflow by setting the sovfl (stack overflow) bit in the condition code (R15), and it also sets the stack fault bit in the interrupt request register. If interrupts are enabled and the stack fault bit is set in the interrupt mask register, then an interrupt will occur after the push instruction completes. But there will be no interrupt if interrupts are disabled, or the stack fault bit is not set in the mask register.</p>
<p>Push is an EXP format instruction comprising two words:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">op</td>
<td style="text-align: center;">d</td>
<td style="text-align: center;">a</td>
<td style="text-align: center;">b</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>e</strong></td>
<td style="text-align: center;">R1</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><strong>5</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0-2</td>
<td style="text-align: center;">3-6</td>
<td style="text-align: center;">7-10</td>
<td style="text-align: center;">11-15</td>
</tr>
</tbody>
</table>
<h3 id="pop">pop</h3>
<p>The pop instruction removes the top element from a stack and loads it into the destination register. (See push for a description of representation of a stack.)</p>
<p>pop R1,R2,R3</p>
<p>R1 = value popped from stack R2 = stack top R3 = stack base</p>
<p>if R2&gt;R3 then R1 := mem[R2]; R2 := R2 - 1 else R15.StackUnderflow := 1, req.StackBounds := 1</p>
<h3 id="top">top</h3>
<p>top R1,R2,R3</p>
<p>R1 = value of top of stack R2 = stack top R2 = stack base</p>
<p>if R2&gt;R2 then R1 := mem[R1] else R15.StackEmpty := 1, req.StackBounds := 1</p>
<h2 id="comparisons">Comparisons</h2>
<p>The comparison instructions compare the values in two operand registers and produce one or more Booleans indicating the relation between the operands. The result can either loaded into a register as a word containing a Boolean (cmplt, cmpeq, cmpgt), or it can be indicated by setting a number of separate Booleans in the condition code register R15 (cmp).</p>
<h3 id="cmplt">cmplt</h3>
<p>The <strong>compare for less than</strong> instruction <em>cmplt Rd,Ra,Rb</em> performs an integer comparison of the operands. If Ra&lt;Rb then the destination Rd is set to 0001; otherwise it is set to 0000.</p>
<p>The comparison treats the operands as signed integers, not as binary numbers. For example, ffff is the two’s complement representation of -1, while 0002 is the two’s complement representation of 2, so ffff &lt; 0002.</p>
<p>The result of a comparison is a Boolean, either false or true. False is represented as 0000, and true is represented as 0001.</p>
<h3 id="cmpeq">cmpeq</h3>
<p>The <strong>compare for equality</strong> instruction <em>cmpeq Rd,Ra,Rb</em> performs an bitwise comparison of the operands. If Ra and Rb contain the same value then the destination Rd is set to 0001; otherwise it is set to 0000.</p>
<p>This instruction can be used to compare for equality of either integers (binary) numbers or integers (two’s complement).</p>
<p>The result of a comparison is a Boolean, either false or true. False is represented as 0000, and true is represented as 0001.</p>
<h3 id="cmpgt">cmpgt</h3>
<p>The <strong>compare for greater than</strong> instruction <em>cmpgt Rd,Ra,Rb</em> performs an integer comparison of the operands. If Ra&gt;Rb then the destination Rd is set to 0001; otherwise it is set to 0000.</p>
<p>The comparison treats the operands as signed integers, not as binary numbers. For example, ffff is the two’s complement representation of -1, while 0002 is the two’s complement representation of 2, so 0002 &gt; ffff.</p>
<p>The result of a comparison is a Boolean, either false or true. False is represented as 0000, and true is represented as 0001.</p>
<h3 id="cmp">cmp</h3>
<p>The <strong>compare</strong> instruction <em>cmp Ra,Rb</em> performs both an integer (two’s complement) and a natural (binary) comparison of the operands. The results are indicated in several of the flags in the condition code register, which is R15.</p>
<h2 id="transfer-of-control">Transfer of control</h2>
<h3 id="jump">jump</h3>
<p>The <strong>jump</strong> instruction <em>jump disp[Ra]</em> transfers control to the instruction in memory at the effective address <em>disp+Ra</em>.</p>
<h3 id="jumpf">jumpf</h3>
<p>The <strong>jump if false</strong> instruction <em>jumpf Rd,disp[Ra]</em> checks the Boolean value of Rd. If this is <em>false</em>, the instruction transfers control to the instruction in memory at the effective address <em>disp+Ra</em>; otherwise the instruction does nothing.</p>
<h3 id="jumpt">jumpt</h3>
<p>The <strong>jump if true</strong> instruction <em>jumpf Rd,disp[Ra]</em> checks the Boolean value of Rd. If this is <em>true</em>, the instruction transfers control to the instruction in memory at the effective address <em>disp+Ra</em>; otherwise the instruction does nothing.</p>
<h3 id="jumpc0">jumpc0</h3>
<p>The <strong>jump if condition code bit is 0</strong> instruction <em>jumpc0 k,disp[Ra]</em> checks the value of bit k in R15, which is the condition code register. If this bit is <em>0</em>, then the instruction transfers control to the instruction in memory at the effective address <em>disp+Ra</em>; otherwise the instruction does nothing.</p>
<h3 id="jumpc1">jumpc1</h3>
<p>The <strong>jump if condition code bit is 1</strong> instruction <em>jumpc1 k,disp[Ra]</em> checks the value of bit k in R15, which is the condition code register. If this bit is <em>1</em>, then the instruction transfers control to the instruction in memory at the effective address <em>disp+Ra</em>; otherwise the instruction does nothing.</p>
<h3 id="jal">jal</h3>
<p>The <strong>jump and link</strong> instruction <em>jal Rd,disp[Ra]</em> loads the address of the following instruction into the destination register Rd, and transfers control to the instruction in memory at the effective address <em>disp+Ra</em>.</p>
<p>The value loaded into Rd is the address of the instruction that immediately follows the jal. This instruction is used for calling procedures or functions: the effective address is the location of the procedure, and the return address is in Rd. The procedure can then return by jumping to the return address, e.g. with <em>jump 0[Rd]</em>.</p>
<h3 id="aliases-for-conditional-jumps">Aliases for conditional jumps</h3>
<p>jumplt jumple jumpne jumpeq jumpge jumpgt</p>
<h2 id="bit-fields">Bit fields</h2>
<p>The following instructions treat a word as a sequence of bits, and operate on the individual bits.</p>
<h3 id="inv">inv</h3>
<p>The <strong>invert</strong> instruction <em>inv Rd,Ra</em> inverts the bits in the operand Ra and places the result in the destination Rd. The operand Ra is not changed. Inverting a bit means changing 0 to 1, and changing 1 to 0.</p>
<p>Suppose R8 contains 035f. Then the following instruction will set R3 to fca0, and leave R8 unchanged.</p>
<pre><code>   inv R3,R8</code></pre>
<h3 id="and">and</h3>
<p>The <strong>logical and</strong> instruction <em>inv Rd,Ra,Rb</em> calculates the logical “and” (conjunction) of the bits in the operands Ra and Rb, and places the result in the destination Rd. The operand registers are not changed. The logical and of two bits is 1 if both bits are 1, and 0 otherwise.</p>
<h3 id="or">or</h3>
<p>The <strong>logical or</strong> instruction <em>inv Rd,Ra,Rb</em> calculates the logical “inclusive or” (disjucntion) of the bits in the operands Ra and Rb, and places the result in the destination Rd. The operand registers are not changed. The logical or of two bits is 1 if either or both of the bits are 1, and 0 otherwise.</p>
<h3 id="xor">xor</h3>
<p>The <strong>logical exclusive or</strong> instruction <em>inv Rd,Ra,Rb</em> calculates the logical “exclusive or” of the bits in the operands Ra and Rb, and places the result in the destination Rd. The operand registers are not changed. The logical exclusive or of two bits is 1 if one or the other of the bits is 1, and 0 otherwise.</p>
<p>The exclusive or of two bits is the same as the inclusive or if either bit is 0. The only time it is different is if both bits are 1: in that case exclusive or gives 0 but inclusive or gives 1.</p>
<h3 id="shiftl">shiftl</h3>
<p>The instruction shiftl Rd,Ra,k shifts the value in the operand register Ra by k bits to the left, and the result is placed in the destination register Rd. The operand Ra is not modified. During the shift, the leftmost k bits of the value are discarded and the rightmost k bits become 0.</p>
<pre><code>   shiftl  R2,R3,5</code></pre>
<p>The instruction format is EXP, and the assembly language statement format is RRKEXP</p>
<h3 id="shiftr">shiftr</h3>
<p>Shift to the right.</p>
<p>The instruction shiftr Rd,Ra,k shifts the value in the operand register Ra by k bits to the right, and the result is placed in the destination register Rd. The operand Ra is not modified. During the shift, the rightmost k bits of the value are discarded and the leftmost k bits become 0.</p>
<p>The following instruction shifts the value in R3 to the right by 5 bits and place the result in R2. The operand register R3 is not changed.</p>
<pre><code>   shiftr  R2,R3,5</code></pre>
<p>The instruction format is EXP, and the assembly language statement format is RRKEXP</p>
<h3 id="getbit">getbit</h3>
<p>The bit at position k in the operand Ra is converted to a Boolean and loaded into the destination register Rd. Bit 0 is the leftmost (most significant) bit, and bit 15 is the rightmost (least significant).</p>
<pre><code>   getbit Rd,Ra,k</code></pre>
<h3 id="getbiti">getbiti</h3>
<h3 id="putbit">putbit</h3>
<h3 id="putbiti">putbiti</h3>
<h3 id="extract">extract</h3>
<p>Extract a field from Rf starting in bit position g, or size h bits, and place the result into Re.</p>
<pre><code>   extract Re,Rf,g,h</code></pre>
<p>Format RRKKEXP. The operands are all in the second word of the instruction.</p>
<h3 id="execute">execute</h3>
<p>The <em>execute</em> instruction commands the computer to execute another instruction which is in the register file. The first word of this target instruction is in Re and the second word (in case it’s a two-word instruction) is in Rf. If Re contains an RRR instruction, then Rf is ignored.</p>
<pre><code>   execute Re,Rf</code></pre>
<p>Format RREXP. Both operands are in the second word of the instruction, in the e and f fields.</p>
<h2 id="system-control">System control</h2>
<h3 id="trap">trap</h3>
<h3 id="getctl">getctl</h3>
<h3 id="putctl">putctl</h3>
<h3 id="rfi">rfi</h3>
<p>The <strong>return from interrupt</strong> instruction performs the following operations simultaneously and atomically:</p>
<ul>
<li>status := istat</li>
<li>pc := ipc</li>
</ul>
<p>It is important that this is an atomic operation. If either of the two register updates were performed before the other, then the second one would not function correctly. In the digital circuit implementing the processor, these two register updates are genuinely simultaneous: they happen during the same clock cycle, at exactly the same time.</p>
<p>The instruction format is EXP0. As there is no operand, every rfi instruction has the same machine language representation: e000. The fields are op, d, ab; op=14 to indicate EXP format, d=0 because it is unused, and ab=0 because this is the secondary opcode of rfi.</p>
<p>This instruction is privileged. Since the instruction changes the status register, it can be used to perform a context switch.</p>
<h2 id="trap-operations">Trap operations</h2>
<h3 id="halt">Halt</h3>
<h3 id="nonblocking-read">Nonblocking read</h3>
<h3 id="write">Write</h3>
<h3 id="blocking-readline">Blocking readline</h3>
<h3 id="nonblocking-readline">Nonblocking readline</h3>
<h3 id="random-number">Random number</h3>
<h2 id="list-of-instructions">List of instructions</h2>
<table style="width:65%;">
<caption><strong>Instruction set</strong></caption>
<colgroup>
<col style="width: 11%" />
<col style="width: 8%" />
<col style="width: 9%" />
<col style="width: 6%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Mne</th>
<th style="text-align: center;">AL</th>
<th style="text-align: center;">ML</th>
<th style="text-align: center;">Op</th>
<th style="text-align: center;">Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">add</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">Rd := Ra + Rb</td>
</tr>
<tr class="even">
<td style="text-align: center;">sub</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Rd := r[a] - Rb</td>
</tr>
<tr class="odd">
<td style="text-align: center;">mul</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">Rd := Ra * Rb</td>
</tr>
<tr class="even">
<td style="text-align: center;">div</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">Rd := Ra / Rb, R15 := Ra rem Rb</td>
</tr>
<tr class="odd">
<td style="text-align: center;">cmp</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">R15 := Ra ? Rb</td>
</tr>
<tr class="even">
<td style="text-align: center;">cmplt</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">Rd := Ra &lt; Rb</td>
</tr>
<tr class="odd">
<td style="text-align: center;">cmpeq</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">Rd := Ra = Rb</td>
</tr>
<tr class="even">
<td style="text-align: center;">cmpgt</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">Rd := Ra &gt; Rb</td>
</tr>
<tr class="odd">
<td style="text-align: center;">inv</td>
<td style="text-align: center;">RR</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">Rd := inv Ra</td>
</tr>
<tr class="even">
<td style="text-align: center;">and</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">9</td>
<td style="text-align: center;">Rd := Ra and Rb</td>
</tr>
<tr class="odd">
<td style="text-align: center;">or</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">a</td>
<td style="text-align: center;">Rd := Ra or Rb</td>
</tr>
<tr class="even">
<td style="text-align: center;">xor</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">b</td>
<td style="text-align: center;">Rd := Ra xor Rb</td>
</tr>
<tr class="odd">
<td style="text-align: center;">nop</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">c</td>
<td style="text-align: center;">no operation</td>
</tr>
<tr class="even">
<td style="text-align: center;">trap</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">d</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">lea</td>
<td style="text-align: center;">RX</td>
<td style="text-align: center;">RX</td>
<td style="text-align: center;">f,0</td>
<td style="text-align: center;">Rd := Ra+disp</td>
</tr>
<tr class="even">
<td style="text-align: center;">load</td>
<td style="text-align: center;">RX</td>
<td style="text-align: center;">RX</td>
<td style="text-align: center;">f,1</td>
<td style="text-align: center;">Rd := mem[Ra+disp]</td>
</tr>
<tr class="odd">
<td style="text-align: center;">store</td>
<td style="text-align: center;">RX</td>
<td style="text-align: center;">RX</td>
<td style="text-align: center;">f,2</td>
<td style="text-align: center;">mem[Ra+disp] := Rd</td>
</tr>
<tr class="even">
<td style="text-align: center;">jump</td>
<td style="text-align: center;">JX</td>
<td style="text-align: center;">RX</td>
<td style="text-align: center;">f,3</td>
<td style="text-align: center;">pc := Ra+disp</td>
</tr>
<tr class="odd">
<td style="text-align: center;">jumpc0</td>
<td style="text-align: center;">KX</td>
<td style="text-align: center;">RX</td>
<td style="text-align: center;">f,4</td>
<td style="text-align: center;">if R15.k=1 then pc := Ra+disp</td>
</tr>
<tr class="even">
<td style="text-align: center;">jumpc1</td>
<td style="text-align: center;">KX</td>
<td style="text-align: center;">RX</td>
<td style="text-align: center;">f,5</td>
<td style="text-align: center;">if R15.k=0 then pc := Ra+disp</td>
</tr>
<tr class="odd">
<td style="text-align: center;">jumpf</td>
<td style="text-align: center;">RX</td>
<td style="text-align: center;">RX</td>
<td style="text-align: center;">f,6</td>
<td style="text-align: center;">if Rd=0 then pc := Ra+disp</td>
</tr>
<tr class="even">
<td style="text-align: center;">jumpt</td>
<td style="text-align: center;">RX</td>
<td style="text-align: center;">RX</td>
<td style="text-align: center;">f,7</td>
<td style="text-align: center;">if Rd/=0 then pc := Ra+disp</td>
</tr>
<tr class="odd">
<td style="text-align: center;">jal</td>
<td style="text-align: center;">RX</td>
<td style="text-align: center;">RX</td>
<td style="text-align: center;">f,8</td>
<td style="text-align: center;">Rd := pc, pc := Ra+disp</td>
</tr>
<tr class="even">
<td style="text-align: center;">testset</td>
<td style="text-align: center;">RX</td>
<td style="text-align: center;">RX</td>
<td style="text-align: center;">f,9</td>
<td style="text-align: center;">Rd := mem[Ra+disp], mem[Ra+disp] := 1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">rfi</td>
<td style="text-align: center;">NO</td>
<td style="text-align: center;">R</td>
<td style="text-align: center;">e,0</td>
<td style="text-align: center;">pc := ipc, status := istatus</td>
</tr>
<tr class="even">
<td style="text-align: center;">execute</td>
<td style="text-align: center;">RR</td>
<td style="text-align: center;">RREXP</td>
<td style="text-align: center;">e,8</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">getctl</td>
<td style="text-align: center;">RC</td>
<td style="text-align: center;">RCEXP</td>
<td style="text-align: center;">e,10</td>
<td style="text-align: center;">Rd := Rc</td>
</tr>
<tr class="even">
<td style="text-align: center;">putctl</td>
<td style="text-align: center;">RC</td>
<td style="text-align: center;">RCEXP</td>
<td style="text-align: center;">e,11</td>
<td style="text-align: center;">Rc := Rd</td>
</tr>
<tr class="odd">
<td style="text-align: center;">push</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">RRREXP</td>
<td style="text-align: center;">e,18</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">pop</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">RRREXP</td>
<td style="text-align: center;">e,19</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">top</td>
<td style="text-align: center;">RRR</td>
<td style="text-align: center;">RRREXP</td>
<td style="text-align: center;">e,1a</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">shiftl</td>
<td style="text-align: center;">RRK</td>
<td style="text-align: center;">RRKEXP</td>
<td style="text-align: center;">e,20</td>
<td style="text-align: center;">Rd := Ra shl k</td>
</tr>
<tr class="odd">
<td style="text-align: center;">shiftr</td>
<td style="text-align: center;">RRK</td>
<td style="text-align: center;">RRKEXP</td>
<td style="text-align: center;">e,21</td>
<td style="text-align: center;">Rd := Ra shr k</td>
</tr>
<tr class="even">
<td style="text-align: center;">getbit</td>
<td style="text-align: center;">RRKK</td>
<td style="text-align: center;">RRKEXP</td>
<td style="text-align: center;">e,22</td>
<td style="text-align: center;">Rd := R15.k</td>
</tr>
<tr class="odd">
<td style="text-align: center;">getbiti</td>
<td style="text-align: center;">RRKK</td>
<td style="text-align: center;">RRKEXP</td>
<td style="text-align: center;">e,23</td>
<td style="text-align: center;">Rd := inv R15.k</td>
</tr>
<tr class="even">
<td style="text-align: center;">putbit</td>
<td style="text-align: center;">RRKK</td>
<td style="text-align: center;">RRKEXP</td>
<td style="text-align: center;">e,24</td>
<td style="text-align: center;">R15.k := Ra.15</td>
</tr>
<tr class="odd">
<td style="text-align: center;">putbiti</td>
<td style="text-align: center;">RRKK</td>
<td style="text-align: center;">RRKEXP</td>
<td style="text-align: center;">e,25</td>
<td style="text-align: center;">R15.k := inv Ra.15</td>
</tr>
<tr class="even">
<td style="text-align: center;">extract</td>
<td style="text-align: center;">RRKK</td>
<td style="text-align: center;">RRKKEX</td>
<td style="text-align: center;">P e,3</td>
<td style="text-align: center;">8</td>
</tr>
<tr class="odd">
<td style="text-align: center;">save</td>
<td style="text-align: center;">RRX</td>
<td style="text-align: center;">RRXEXP</td>
<td style="text-align: center;">e,4</td>
<td style="text-align: center;">0 mem[Rb+ofs] := Re, mem[Rb+ofs+1] := Re+1, …, mem[Rb+ofs+(f-e+1)] := Rf,</td>
</tr>
<tr class="even">
<td style="text-align: center;">restore</td>
<td style="text-align: center;">RRX</td>
<td style="text-align: center;">RRXEXP</td>
<td style="text-align: center;">e,4</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<h1 id="assembly-language-1">Assembly Language</h1>
<p>A computer is a digital circuit that executes programs in machine language, which is hard for humans to read because it consists entirely of numbers. Assembly language provides a readable notation for writing machine language programs. It uses names for instructions and variables, as well as other notations to make the code easier to understand.</p>
<p>An instruction in machine language is just one or more words (often written in hexadecimal notation), while the corresponding instruction in assembly language uses mnemonic names so the programmer doesn’t have to memorise all the operation codes, addresses of variables, and so on. For example, the assembly language statement mul R12,R3,R8 is more readable than the corresponding machine language instruction 2c38. However, the assembly language still gives the programmer complete control over every bit a program.</p>
<p>Each line of source code is an assembly language statement. Unlike higher level languages, assembly language statements are not nested. There are three kinds of assembly language statement:</p>
<ul>
<li><p>Most statements specify either an instruction or some constant data.</p></li>
<li><p>Some statements are full line comments.</p></li>
<li><p>Other statements are <em>directives</em>, which control the behavior of the assembler but don’t generate any code.</p></li>
</ul>
<p>Humans write assembly language. The program is text: red}add R4,R2,R12. It’s easier to read, you don’t need to remember all the codes, and memory addresses are much easier to handle.</p>
<p>The computer executes machine language: The program is words containing 16-bit numbers: 042c. It’s possible for a digital circuit (the computer) to execute. No names for instructions or variables: everything is a number.</p>
<p>A human writes a machine-level program in assembly language. A software application called the <em>assembler</em> reads it in and translates it to machine language. When it sees an instruction mnemonic like add or div, it replaces it with the operation code (0, 3, or whatever). The assembler helps with variable names — the machine language needs addresses (numbers) and the assembler calculates them</p>
<ul>
<li>You can use names (add, div) rather than numeric codes (0, 3)</li>
<li>You can use variable names (x, y, sum) rather than memory addresses (02c3, 18d2)</li>
<li>You write a program in assemply language</li>
<li>The  translates it into machine language</li>
</ul>
<p>Compilers and assemblers are similar in some ways: both of them translate a program from one language to another. The main difference is that compilers translate between languages that are very different, while assemblers translate between very similar languages.</p>
<p>Example: a sequence of RRR instructions</p>
<p>Assembly language ~~~~ add R3,R5,R1 sub R4,R2,R3 mul R1,R9,R10<br />
~~~~</p>
<p>Machine language ~~~<sub> 0351 1423 219a </sub>~~~</p>
<h2 id="notation">Notation</h2>
<p>A name must begin with a letter (a-z or A-Z), and may contain letters, digits, or underscore characters.</p>
<p>Constants can be written in decimal, hexadecimal, or binary:</p>
<ul>
<li><p>Decimal constants consist of a sequence of digits, with an optional leading - sign. Examples: 42 55039 -1</p></li>
<li><p>Hexadecimal constants are written with a dollar sign $ followed by four hex digits (0 1 2 3 4 5 6 7 8 9 a b c d e f). Examples: $0249 $c78a</p></li>
<li><p>Binary constants are written with a hash sign # followed by any number of 0 or 1 characters. You can write fewer than 16 bits; they will be padded on the left with zeros. Examples: #1101 #000100000001101</p></li>
</ul>
<p>An expression denotes a 16-bit word. Usually they are used to specify a word of machine language, either an address or a data constant.</p>
<h2 id="statement-formats">Statement formats</h2>
<p>A statement may contain several fields. A field consists of non-space characters (with one exception: a space may appear in a string literal). Fields are separated from each other by one or more white space characters.</p>
<ul>
<li><p>Label. The label field is optional. If present, the label must be a name and it must begin in the first character of the line. If the first character is a space, then that line has no label.</p>
<ul>
<li><p>Operation. The operation field specifies an instruction or assembler directive. It must be preceded by one or more white space characters. Every statement (apart from a full line comment) must have an operation field, which must be a name.</p></li>
<li><p>Operands. The operands field specifies operands for an instruction or arguments for assembly directive. Most instructions and assembler directives require operands, but some do not.</p></li>
<li><p>Comment. All text that follows white space after the operands field is a comment, and is ignored by the assembler. If one or more of the other fields (label, operation, operands) is missing, the comment must be preceded by a semicolon to prevent it from being interpreted as operands. The rule is: all text after a semicolon is a comment, and all text after white space following operands is a comment. A statement where the first non-space character is a semicolon is a full line comment. If the statement has no operands, then all text after the operation field is a comment. It is good practice always to begin a comment with a semicolon.</p></li>
</ul></li>
</ul>
<h2 id="instructions">Instructions</h2>
<h2 id="directives">Directives</h2>
<p>A directive is an assembly language statement that doesn’t generate an instruction, but which gives further information about how to translate the program to object code.</p>
<p>Directive formats</p>
<pre><code>ASMDIR    operand:    xyz module
ASMDIRX   expression  org 234
ASMDIRNS  list of names   import m1,m2 export a,b,c</code></pre>
<pre><code>abc        Module
x          import   Mod1
y          import   Mod1
z          import   Mod2
           export   x,y,z
           org      34
           org      $02bf
           org      *+100
codeWrite  equ  2
codeRead   equ  1

astart     data 5
           data 9
           data 78
aend
asize      equ  aend-astart</code></pre>
<h4 id="expressions">Expressions</h4>
<p>An expression may be used in a directive (e.g. org xyz) or in an instruction (e.g. lea R2,aend-astart[R0]).</p>
<p>Expressions are useful in professional systems programming. However, they can easily confuse beginners. It is essential to understand that the arithmetic in an expression is evaluated at assembly time, not at run time. It’s a good idea not even to mention expressions in the early stages of teaching computer systems.</p>
<p>Consider how expressions are evaluated. If an expression is used to define size of a block of memory, its value would need to be known before any labels appearing after the block can be resolved. This could lead to unnecessary complexity.</p>
<ul>
<li><p>A simple and clean rule is that an org statement must be of the form constant or <em>+constant, but </em>+label is disallowed. The principle is that a first pass through the assembly source code must resolve the values of all names. But this is needlessly restrictive.</p></li>
<li><p>The important point is that during the second pass it should be possible to evaluate all expressions without backtracking. This can be achieved by another approach: simply to disallow forward references in expressions. For example this could be allowed</p></li>
</ul>
<pre><code>a  equ  123
...
   org  *+a</code></pre>
<p>An expression may be</p>
<ul>
<li><p>A literal constant</p></li>
<li><p>An identifier defined within the module</p></li>
<li><p>The sum of a local relocatable epression and a constant</p></li>
<li><p>The difference between two local locatable expressions</p></li>
<li><p>An identifier imported from another module. In this case, the expression may not contain any operators or other terms: the entire expression must just be that identifier.</p></li>
</ul>
<h3 id="data-statement">data statement</h3>
<p>The data statement specifies a sequence of constants to be placed in consecutive memory locations starting at the location counter, subject to relocation. Its argument is a list of one or more 4-digit hex constants separated by commas.</p>
<p>A long block of data can be broken up into several data statements. Suppose x1, x2, etc are 4-digit hex constants. Then</p>
<pre><code>data  x1,x2,x3,x4,x5,x6</code></pre>
<p>is equivalent to</p>
<pre><code>data x1,x2,x3
data x4,x5,x6</code></pre>
<p>Suppose</p>
<ul>
<li><p>The module’s relocation constant is r</p></li>
<li><p>The location counter has been set to c</p></li>
<li><p>The i’th constant (counting from 0) in a data statement is x.</p></li>
</ul>
<p>Then the linker will set mem[r+c+i] := x.</p>
<p>One point to watch out for is that an assembly language data statement uses $ to indicate that a number is a hex constant (e.g. $03b7) but the object language data statement requires all numbers to be 4-digit hex constants, and does not require (or allow) a preceding $ character</p>
<h3 id="module-statement">module statement</h3>
<p>Declare the name of the module. The argument must be an indentifier. The following statement says that this is the object code for module named abc.</p>
<pre><code>module abc</code></pre>
<p>A program may be organized as a collection of modules, where each module appears in a separate file. When several modules are present, each one needs a unique name. The purpose of the module statement is to specify this name.</p>
<p>A small program can be written as just one module, and it may have a module name but this is not required.</p>
<p>The module statement defines the name of a module. The statement is optional. If present, it must be the first statement in the program, apart from full line comments and blank lines. A file may contain only one module statement, and if the statement “MyModuleName module” is present the file name should be MyModuleName.asm.txt.</p>
<p>Examples</p>
<p>quicksort module main module myprog module</p>
<h3 id="org-statement">org statement</h3>
<p>The org statement sets the location counter to a specified address. Currently the argument must be a a 4-digit hexadecimal constant, such as 3b9f.</p>
<pre><code>org  0a04</code></pre>
<p>The org statement specifies where in memory instructions and data should be placed when the program is booted. It takes an operand consisting of a word value, and it sets the location counter to this value.</p>
<p>Examples</p>
<p>org $0f20 ; subsequent instructions start from 0f20 org *+50 ; skip 50 words</p>
<p>The assembler initializes the location counter to 0 before it begins translating an assembly language module. This means that, in effect, every module begins with org 0.</p>
<h3 id="import-statment">import statment</h3>
<pre><code>import mod3,sqr,addr,addr,...</code></pre>
<p>The import statement states that the value of an identifier is defined in another module. During the assembly of the module containing the import, the identifier is given a provisional value of 0, but this will be replaced by the actual value by the linker. For example,</p>
<pre><code>    x          import   Mod1</code></pre>
<p>a</p>
<p>says that x is a name that can be used in this module, but it is defined in Mod1 and its actual value will remain unknown until the linker sets it later on.</p>
<h3 id="export-statement">export statement</h3>
<p>An export statement says that the module is making the value of a symbol available for use in other modules, which may import it. The statement takes two operands: the name being exported and the value, which must be a 4-digit hex constant. It makes no difference whether the name is relocatable, as the linker performs any relocation before writing the exported value into other modules that import it. Examples:</p>
<pre><code>export  haltcode,0
export  fcn,002c</code></pre>
<p>The export statement states that the value of an identifier should be made available for other modules to import. For example, this module defines a function and exports it so other modules can import and call it:</p>
<pre><code>Mod1     module
         export fcn

fcn      add    R1,R1,R1
         jump   0[R12]</code></pre>
<h3 id="equ">equ</h3>
<pre><code>trapWrite   equ  2</code></pre>
<h2 id="assembly-listing">Assembly listing</h2>
<p>The first section of the assembly listing shows each line of the source program. The line number appears first, followed by the memory address that the instruction on this line will be placed in. The address is given as a 4 digit hexadecimal number, and it is binary (not two’s complement). Next comes the machine language code generated by the line of source code. If the line contains a two-word instruction, there will be two 4-digit hexadecimal values; for a one-word instruction there will be one hex number, and if the line doesn’t produce any code these fields will be blank. After the code, the original source statement appears.</p>
<p>The second section of the assembly listing is the <em>Symbol Table</em>. This shows each identifier (or “symbol”) that appears in the program, the address allocated for the symbol, the source code line where it was defined, and the source code lines where it was used.</p>
<h1 id="linker">Linker</h1>
<p>The assembler doesn’t translate a source module in assembly langauge directly to raw machine language. Instead, it produces an <em>object module</em> which contains some additional metadata along with the machine language code. This metadata enables the linker to combine the object module with other modules into an <em>executable module</em>.</p>
<h2 id="programs-modules-and-files">Programs, modules, and files</h2>
<p>The system is designed to allow programs that consist of several modules, but also to allow programs consisting of one standalone module. In addition, an aim is to do this simply and intuitively, so that you can ignore the issues of modules and linking if you just want to write a andalone program.</p>
<p>There is a standard convention for file names. If, for example, you have a program named MyProgram, then the files associated with it should be as follows:</p>
<hr />
<p>module name MyProgram source file MyProgram.asm.txt object file MyProgram.obj.txt assembly listing MyProgram.lst.txt —————– ———–</p>
<h2 id="simple-standalone-programs">Simple standalone programs</h2>
<p>If a program does not import any names, it is <em>standalone</em>. The text of the program is shown in the editor pane. Go to the Assembler pane and click Assemble. If there are no errors, go directly to the Processor pane (you can skip the Linker) and click Boot. This will read the machine language into the memory, and now you can run the program.</p>
<h2 id="programs-with-multiple-modules">Programs with multiple modules</h2>
<p>A module consists of program text, and it may have an optional file, and an optional module name.</p>
<ul>
<li><p>The module text is a sequence of assembly language statements. The text may exist only in the editor buffer, or it may be associated with a file.</p>
<ul>
<li>If there is a file, this may be specified either as a path (the unique identification of the file (C:\Users....asm.txt), or as just a filename (myprogram.asm.txt) which is relative to the current directory.</li>
</ul></li>
</ul>
<p>To edit a file, the modDir and modName are both optional. An edited file may have a module name specified with a module statement. To read or save a file, both the module directory and name must be known.</p>
<p>Editor operations on files and modules</p>
<p>Each operation that changes the editor buffer (New, Open, Close) checks first to see whehter the buffer has been changed since it was last saved. If so, a dialogue asks whether the file should be saved.</p>
<ul>
<li><p>New – Check whether text in the editor buffer has been saved; if not, ask whether to save it. Create a new module with empty text and no file name, add it to the module set, and select it as the current module. Clear the text in the editor buffer.</p>
<ul>
<li><p>Open – Check whether text in the editor buffer has been saved; if not, ask whether to save it. Enter the open file dialogue where an existing file can be found by navigation or by typing in its name. If the dialogue is cancelled, the module set and editor buffer are left unchanged. If a file is selected in the dialogue, and it is already in the module set, then it is selected in the current module. Otherwise, a new module is created with the file’s contents, and is selected as the current module. and The file is loaded into the editor buffer and added to the module set.</p></li>
<li><p>Refresh – The file corresponding to the current module is read, and its contents are loaded into the editor buffer.</p></li>
<li><p>SaveAs – Enters the save file dialogue where the directory and file name can be chosen. The editor buffer is written into this file.</p></li>
<li><p>Save – Writes the editor buffer into the current file and directory. If either the module name or directory is not known, this reverts to a SaveAs.</p></li>
<li><p>Select – Opens a list of all modules; you can click one of them which is then set as the current module.</p></li>
<li><p>Close – Check whether text in the editor buffer has been saved; if not, ask whether to save it. The module is removed from the module set, and the editor buffer is cleared. The first module (module number 0) is selected as the current module, but if there is no module at all, an empty module is created and selected as current (in effect, if there is only one module and you close it, an automatic New is performed).</p></li>
<li><p>Example – Reads in a very simple example program and sets it as the current module. This is a standalone program; you can simply click Editor: Example, then Assembler: Assemble, then Processor: Boot, and run the program. This example is used in the first “getting started” tutorial. The example program is also available in the Examples directory, accessible through Editor: Open.</p></li>
</ul></li>
</ul>
<p>Select is for switching among the existing modules, while New and Open are for introducing a new module.</p>
<h2 id="object-code">Object code</h2>
<p>Ojbect modules are specified in an object code language with a simple syntax and only a few types of statement. Each object statement is written on line line. It begins with a keyword indicating the type of statement, followed by white space, followed by an operand which must not contain any spaces. Operands may contain either hex constants or identifiers.</p>
<ul>
<li><p>In the object language, hex constants are written as four characters, using digits 0-9 a-f. Unlike assembly language, a hex constant is not preceded by $.</p></li>
<li><p>Identifiers have the same syntax as in assembly language: a string of letters, digits, and underscore characters, beginning with a letter.</p></li>
</ul>
<p>The object language has six statements: module, org, data, import, export, and relocate. These are related to corresponding statements in assembly language, but their syntax is different. For example, an import statement in assembly language will generate one or more import statements in the object code, but those statements have a different syntax and contain different information.</p>
<h3 id="relocate-statement">relocate statement</h3>
<p>The relocate statement specifies a list of addresses of words that must be relocated. Suppose the value x is specified in a relocate statement, and the linker is relocating the module by offset y. Then the linker will set mem[x+y] = obj[x]+y.</p>
<pre><code>relocate hex4,hex4,...</code></pre>
<h2 id="executable-code">Executable code</h2>
<p>An executable module is written in the same language as object modules. The only difference is that an executable module must contain only these types of statement: module, data, org. It is now allowed to contain any of the following statments: import, export, relocate.</p>
<p>If an assembly language program doesn’t contain any import or export directives, then its object code won’t contain any import, export, or relcate statements. In this case, the object code is already executable and does not require linking: it can be booted directly by the processor.</p>
<p>The booter (invoked by clicking the Boot button in the processor page) reads in the currently selected module and checks to see whether it is a valid executable module. If so, it loads the code into the memory. If not, it indicates that the program cannot be booted.</p>
<h1 id="programming">Programming</h1>
<h2 id="using-the-instructions">Using the instructions</h2>
<h3 id="load-and-store">load and store</h3>
<ul>
<li><p>Use load to copy a variable (either ordinary variable x or array element a[i]) from memory to register.</p></li>
<li><p>Use store to copy the value in a register into memory.</p></li>
</ul>
<h3 id="lea-1">lea</h3>
<ul>
<li><p>(Common usage) Use lea to put a constant into a register: <em>lea R2,39[R0] ; R2 = 39</em></p></li>
<li><p>(Common usage) Use lea to put the <em>address</em> of a variable into a register. (Use load to put the value of the varable into a register.)</p></li>
<li><p>Example: to write a string, you need to (1) put the code for write in R1 (this is likely to be a constant , so use lea); (2) put the address of the string in R2 (use lea); and (3) put the length of the string in R3 (this may be a constant, so use lea); then finally <em>trap R1,R2,R3</em></p></li>
<li><p>(Less common usage) Use lea to add a binary constant to a register containing a binary number: <em>lea R5,1[R5] ; R5 = R5 + 1</em>.</p></li>
</ul>
<p>Loading constants using lea</p>
<ul>
<li>The RTM has an instruction that loads a constant into a register</li>
<li>Use the  instruction</li>
<li> loads the constant 57 into R2: </li>
<li></li>
<li>General form: </li>
<li>You must write [R0] after the constant; we’ll see the reason for this later on</li>
</ul>
<pre><code>; R3 := R1 + 39*R2

    lea   R4,39[R0]    ; R4 := 39
    mul   R3,R4,R2     ; R3 := 39 * R2
    add   R3,R1,R3     ; R3 := R1 + (39*R2)</code></pre>
<h2 id="how-to-perform-commmon-tasks">How to perform commmon tasks</h2>
<h3 id="stopping-the-program">Stopping the program</h3>
<p>The last instruction should be</p>
<pre><code>     trap   R0,R0,R0   ; halt</code></pre>
<p>This tells the computer to halt; it stops execution of the program</p>
<h3 id="conditional-jumps">Conditional jumps</h3>
<ul>
<li>There are two instructions: you can jump if a Boolean is False or True</li>
<li><p>jumpf — jump if False</p></li>
<li>jumpf R4,aardvark[R0]</li>
<li>Means if R4 contains False, then goto aardvark</li>
<li><p>0 means False, so this means if R4=0 then goto aardvark</p></li>
<li><p>jumpt — jump if True</p></li>
<li>jumpt R5,banana[R0]</li>
<li>Means if R5 contains True, then goto banana</li>
<li><p>Any number other than 0 means True, so this means if R5 <span class="math inline">≠</span> 0 then goto banana</p></li>
</ul>
<h3 id="compilation-patterns">Compilation patterns</h3>
<ul>
<li>Each programming construct can be translated according to a standard pattern</li>
<li><p>It’s useful to translate in two steps:</p></li>
<li>First, translate complex statements to simple high level statements (go to label, if b then goto label)</li>
<li>The ``goto form’’ of the algorithm corresponds closely to machine instructions</li>
<li><p>Then it’s straightforward to complete the translation to assembly language</p></li>
<li>Assignment statements — loads, then arithmetic, then store</li>
<li>goto label — jump label[R0]</li>
<li>if b then goto label — jumpt R5,label[R0] where R5 contains b</li>
<li><p>if not b then goto label — jumpf R5,label[R0] where R5 contains b</p></li>
<li><p>This approach clarifies how the algorithm works</p></li>
</ul>
<h4 id="compiling-an-assignment-statement">Compiling an assignment statement</h4>
<p>Load the operands; do calculations; store results</p>
<pre><code>; x := a + b*c;
   load  R1,a[R0]   ; R1 = a
   load  R2,b[R0]   ; R2 = b
   load  R3,c[R0]   ; R3 = c
   mul   R4,R2,R3   ; R4 = b*c
   add   R4,R1,R4   ; R4 = a + (b*c)
   store R4,x[R0]   ; x := a+(b*c)</code></pre>
<h3 id="variable-names-and-addresses">Variable names and addresses</h3>
<ul>
<li>Each variable needs to be declared with a  statement</li>
<li>x data 23</li>
<li>This means: allocate a word in memory for x and initialize it to 23</li>
<li></li>
</ul>
<h3 id="instructions-in-assembly-language">Instructions in assembly language</h3>
<ul>
<li>The syntax is simple, but you have to follow the form of the instructions exactly!</li>
<li><p>RRR instructions</p></li>
<li>Typical example: </li>
<li>R8 is the  (where the result goes)</li>
<li><p>R2 and R12 are the  (the operands to be added)</p></li>
<li><p>RX instructions</p></li>
<li>RX instructions specify a  and a </li>
<li>Typical example: </li>
<li>Meaning of load: R3 = x</li>
<li></li>
<li>Meaning of store: y = R3</li>
<li> copies from </li>
<li><p> copies from </p></li>
</ul>
<h3 id="how-the-assembler-allocates-memory">How the assembler allocates memory</h3>
<ul>
<li>The assembler maintains a variable called the . This is the address where it will place the next piece of code.</li>
<li>Initially the location counter is 0.</li>
<li>The assembler reads through each line of code \begin{enumerate}</li>
<li>If there is a label, it remembers that the value of the label is the current value of the location counter. This goes into the </li>
<li>The assembler decides how many words of memory this line of assembly code will require (add needs one word, load needs two), and adds this to the location counter. \end{enumerate}</li>
<li>Then the assembler reads through the assembly language program </li>
<li>Now it generates the words of object code for each statement. If there is a reference to a label that appears farther on (e.g. load x, or jump loop) it looks up the value of the label in the symbol table.</li>
</ul>
<h3 id="program-structure">Program structure</h3>
<ul>
<li><p>A complete program needs</p>
<ul>
<li>Good comments explaining what it is</li>
<li>The actual program — a sequence of instructions</li>
<li>An instruction to stop the program: </li>
<li>Declarations of the variables:  statements</li>
</ul></li>
<li><p>Why do we put the instructions first, and define the variables at the end?</p></li>
<li>The assembler can find the definitions because it reads the program twice: the first pass finds all the labels, the second pass generates the machine language code</li>
<li><p>The computer will start executing at memory address 0, so there had better be in instruction there, not data!</p></li>
</ul>
<h3 id="example-program-add">Example program Add</h3>
<pre><code>; Program Add
; A minimal program that adds two integer variables

; Execution starts at location 0, where the first instruction will be
; placed when the program is executed.

      load   R1,x[R0]   ; R1 := x
      load   R2,y[R0]   ; R2 := y
      add    R3,R1,R2   ; R3 := x + y
      store  R3,z[R0]   ; z := x + y
      trap   R0,R0,R0   ; terminate

; Static variables are placed in memory after the program

x     data  23
y     data  14
z     data  99</code></pre>
<p>}</p>
<h3 id="snapshot-of-memory-example-program-add">Snapshot of memory: example program Add</h3>

<h2 id="programming-tips">Programming tips</h2>
<p>Standard idioms for common programming problems</p>
<p>A useful convention</p>
<ul>
<li><p>The instruction set is designed to be regular, and to follow consistent conventions</p>
<ul>
<li>This makes programming easier</li>
<li>It also helps with the hardware design!</li>
</ul></li>
<li><p>For most instructions, the operands follow the pattern of an assignment statement: information goes right to left</p></li>
<li>Assignment statement: </li>
<li>Add instruction: </li>
<li>The two operands on the right (R2, R3) are added, and placed in the destination on the left (R1)</li>
<li><p>Load instruction:  means </p></li>
<li><p></p></li>
<li> means x := R1: the information goes from left to right</li>
<li><p>Why? Doing it this way makes the digital circuit (the processor) a little bit faster</p></li>
</ul>
<h3 id="programming-tip-copying-one-register-to-another">Programming tip: Copying one register to another</h3>
<ul>
<li>Here’s a useful tip — a standard programming technique</li>
<li><p>Sometimes you want to copy a value from one register to another</p></li>
<li><p>R3 := R12</p></li>
<li><p>There’s a standard way to do it:</p></li>
<li><p></p></li>
<li>The idea is that R12 + 0 = R12!</li>
<li><p>Why do it this way? </p></li>
</ul>
<h3 id="using-load-and-store">Using load and store</h3>
<ul>
<li>A common error is to confuse load and store</li>
<li><p>The main points to remember:</p></li>
<li>We need to keep variables in memory (most of the time) because memory is big — there aren’t enough registers to hold all your variables</li>
<li>The computer hardware can do arithmetic on data in registers, but it cannot do arithmetic on data in memory</li>
<li>Therefore, to do arithmetic on variables, you must</li>
</ul>
<h3 id="compilation-patterns-1">Compilation patterns</h3>
<ul>
<li><p>We have looked at several high level programming constructs</p>
<ul>
<li>if  then </li>
<li>if  then  else </li>
<li>while  do </li>
<li>for  :=  to  do </li>
</ul></li>
<li>There is a standard way to translate each to low level form: assignment, goto , if  then goto </li>
<li><p>The low level statements correspond closely to instructions</p></li>
</ul>
<p>Follow the patterns!</p>
<p>You should use these patterns as you write your programs because</p>
<ul>
<li>This helps you understand  what high level language constructs mean—this is one of the aims of the course.</li>
<li>This is essentially how real compilers work, and this is another aim of the course.</li>
<li><p>This saves time because</p></li>
<li>It’s quicker to catch errors at the highest level (e.g. translating if-then-else to goto) rather than the lowest level (instructions)</li>
<li><p>It makes the program more readable, and therefore faster to check and to debug</p></li>
<li>This leads to good comments that make the program more readable</li>
<li>This approach scales up to large programs</li>
<li><p></p></li>
</ul>
<h3 id="how-can-you-tell-if-youre-using-the-pattern">How can you tell if you’re using the pattern?</h3>
<ul>
<li><p>Each pattern contains</p>
<ul>
<li>Changeable parts: boolean expressions, integer expressions, statements</li>
<li>Fixed parts: goto, if-then-goto</li>
<li>The labels have to be different every time, but the structure of the fixed parts never changes</li>
</ul></li>
<li><p>Example: translating a while loop</p></li>
<li>There should be one comparison, one conditional jump at the start of the loop</li>
<li><p>There should be one unconditional jump at the end of the loop</p></li>
</ul>
<h3 id="are-you-using-the-pattern">Are you using the pattern?</h3>
<p></p>
<p>{   \  }</p>

<p></p>
<p>{ \   \ \ \  }</p>

<ul>
<li>The blue text is fixed (except you need to use unique labels)</li>
<li>There should be one comparison, one conditional jump at the start of the loop</li>
<li>There should be one unconditional jump at the end of the loop</li>
</ul>
<p>Can you gain efficiency by violating the pattern?</p>
<ul>
<li>No! Example: avoid the cost of jumping to a test that jumps out of the loop by transforming the while loop to\ {\   \ \ \   \ }\</li>
<li><p>But consider:</p></li>
<li>Even if the loop executes a million times, this version saves  one jump instruction</li>
<li>And the code is longer, which likely makes it slower (because of cache—haven’t reached that topic yet)</li>
<li>And when you do this in a large program it becomes incomprehensible</li>
<li><p></p></li>
</ul>
<h3 id="comments">Comments</h3>
<ul>
<li>Initial comments to identify the program, author, date</li>
<li>Early comments to say what the program does</li>
<li>High level algorithm (in comments)</li>
<li>Translation to low level algorithm (in comments)</li>
<li><p>Translation to assembly language (with comments)</p></li>
<li>Copy the low level algorithm comments, and paste, so you have two copies</li>
<li>The first copy remains as the low level algorithm</li>
<li>In the second copy, insert the assembly language code</li>
<li><p>Every low level statement should appear as a comment in the assembly code</p></li>
</ul>
<p>Write the comments first!</p>
<ul>
<li>The program development methodology entails writing the comments </li>
<li>Avoid the temptation of writing code first, hacking it until it appears to work, and then adding comments</li>
<li>The comments, the high and low level algorithms, </li>
</ul>
<h2 id="records-1">Records</h2>
<p>A  contains several . Access a field with the dot (.) operator</p>
<pre><code>;   x, y :
;     record
;       { fieldA : int;
;         fieldB : int;
;         fieldC : int;
;       }
;
;   x.fieldA := x.fieldB + x.fieldC;
;   y.fieldA := y.fieldB + y.fieldC;</code></pre>
<p>(Some programming languages call it a  or .)</p>
<p>Defining some records</p>
<pre><code>; Data definitions

; The record x
x
x_fieldA   data   3    ; offset 0 from x  &amp;x_fieldA = &amp;x
x_fieldB   data   4    ; offset 1 from x  &amp;x_fieldB = &amp;x + 1
x_fieldC   data   5    ; offset 2 from x  &amp;x_fieldC = &amp;x + 2

; The record y
y
y_fieldA   data  20    ; offset 0 from y  &amp;y_fieldA = &amp;y
y_fieldB   data  21    ; offset 1 from y  &amp;y_fieldB = &amp;y + 1
y_fieldC   data  22    ; offset 2 from y  &amp;y_fieldC = &amp;y + 2</code></pre>
<p>Naming each field explicitly</p>
<pre><code>; ------------------------------------------------------------
; Simplistic approach, with every field of every record named
; explicitly

; In record x,  fieldA := fieldB + fieldC

; x.fieldA := x.fieldB + x.fieldC
    load   R1,x_fieldB[R0]
    load   R2,x_fieldC[R0]
    add    R1,R1,R2
    store  R1,x_fieldA[R0]</code></pre>
<p>This is awkward—but there’s a better way!</p>
<h2 id="pointers-1">Pointers</h2>
<p>So far, we have been finding a piece of data by giving it a label</p>
<pre><code>     load    R2,xyz[R0]
...
xyz  data  5</code></pre>
<p>An alternative way to find the data is to make a  to it</p>

<p></p>

<p> means the address of x: a pointer to x. You can apply the &amp; operator to a variable but not to a complex expression</p>
<ul>
<li> is ok</li>
<li> is not ok</li>
</ul>

<p> means the value that p points to. You can apply the * operator to any pointer.</p>
<h3 id="expressions-using-pointers">Expressions using pointers</h3>
<ul>
<li><p>The &amp; operator gives the address of its operand</p>
<ul>
<li> puts the  of x into p</li>
<li> puts the  of x into p. The address of x is called a , and we say ``p points at x’’.</li>
</ul></li>
<li><p>The * operator follows a pointer and gives whatever it points to</p></li>
<li> is an expression whose value is whatever p points at</li>
<li> stores p into y, so y is also now a pointer to x</li>
<li><p>  p, gets the value (which is x) and stores that in y</p></li>
</ul>
<h3 id="the-operator-requires-only-one-instruction-lea">The &amp; operator requires only one instruction: lea!</h3>
<pre><code>     lea   R5,x[R0]    ; R5 := &amp;x
...
     lea   R6,y[R0]    ; R6 := &amp;y
     store R6,p[R0]    ; p := &amp;y
...
x    data  25
y    data  0
p    data  0</code></pre>
<h3 id="the-operator-requires-only-one-instruction-load">The * operator requires only one instruction: load!</h3>
<pre><code>     load   R7,p[R0]    ; R7 := p
     load   R8,0[R7]    ; R8 := *p</code></pre>
<h3 id="flexibility-of-load-and-lea">Flexibility of load and lea</h3>
<p>We have now seen two ways to use lea:</p>
<ul>
<li>To load a constant into a register: lea R1,42[R0] ; R1 := 42</li>
<li>To create a pointer: lea R2,x[R0] ; R2 := &amp;x</li>
<li>lea can do more, too — can you figure out what?</li>
</ul>
<p>And there are several ways to use load:</p>
<ul>
<li>To load a variable into a register: load R3,x[R0] ; R3 := x</li>
<li>To access an array element: load R4,a[R5] ; R4 := a[R5]</li>
<li>To follow a pointer: load R6,0[R7] ; R6 := *R7</li>
</ul>
<h3 id="following-a-pointer-to-the-address-of-x-gives-x">Following a pointer to the address of x gives x}</h3>
<p>The value of  is just !</p>

<pre><code>   lea    R4,x[R0]    ; R4 := &amp;x
   load   R5,0[R4]    ; R5 := *(&amp;x) = x

   load   R6,x[R0]    ; R6 := x</code></pre>
<h3 id="review-accessing-a-variable-the-ordinary-way">Review: accessing a variable the ordinary way</h3>
<p> ~~~~ x := x + 5; ~~~~</p>

<p> ~~~~ ; Accessing variable x by its address, with R0 lea R1,5[R0] ; R1 := 5 (constant) load R2,x[R0] ; R2 := x add R2,R2,R1 ; R2 := x + 5 store R2,x[R0] ; x := x + 5 ~~~~</p>
<h3 id="accessing-a-variable-through-a-pointer">Accessing a variable through a pointer</h3>
<p> ~~~~ x := x + 5; ~~~~</p>

<p> ~~~~ ; Put a pointer to x into R3, which contains the address of x ; R3 := &amp;x lea R3,x[R0] ; R3 := &amp;x</p>
<p>; Add 5 to whatever word R3 points to lea R1,5[R0] ; R1 := 5 (constant) load R4,0[R3] ; R4 := <em>R3 add R4,R4,R1 ; R4 := </em>R3 + 5 store R4,0[R3] ; <em>R3 := </em>R3 + 5 ~~~~</p>
<p>Equivalent to </p>
<p>Why is the pointer helpful?</p>
<ul>
<li>We can write a block of code that accesses variables through pointers.<br />
</li>
<li>This can be , by executing it with the pointer set to point to different data.</li>
<li>Later, we’ll see additional benefits of using pointers.</li>
</ul>
<h3 id="access-a-record-using-a-pointer">Access a record using a pointer</h3>
<pre><code>; Make the same code work for any record with the same fields

; Set x as the current record by making R3 point to it
    lea    R3,x[R0]    ; R3 := &amp;x

; Perform the calculation on the record that R3 points to
    load   R1,1[R3]    ; R1 := (*R3).fieldB
    load   R2,2[R3]    ; R2 := (*R3).fieldC
    add    R1,R1,R2    ; R1 := (*R3).fieldB + (*R3).fieldC
    store  R1,0[R3]    ; *R3.fieldA := (*R3).fieldB + (*R3).fieldC</code></pre>
<h2 id="requests-to-the-operating-system">Requests to the Operating System</h2>
<ul>
<li><p>Many operations cannot be performed directly by a user program because</p>
<ul>
<li></li>
<li>Also, some operations are difficult to program</li>
<li>The code would need to change when OS is updated</li>
</ul></li>
<li>The program requests the operating system to perform them</li>
<li>An OS request is performed by executing a  instruction, such as </li>
<li> (and you don’t have to give the address to jump to)</li>
<li><p>We use pointers to tell the operating system what to do</p></li>
</ul>
<p>Typical OS requests</p>
<ul>
<li>The type of request is a number, placed in R1, and operands (if any) are in R2, R3</li>
<li>The specific codes used to make a request are defined by the operating system, not by the hardware</li>
<li>{This is a major reason why compiled programs run only on one operating system}</li>
<li><p>Typical requests:</p>
<ul>
<li>Terminate execution of the program</li>
<li>Read from a file</li>
<li>Write to a file</li>
<li>Allocate a block of memory</li>
</ul></li>
</ul>
<h3 id="termination">Termination</h3>
<ul>
<li>A program cannot stop the machine; it requests the operating system to terminate it</li>
<li>The operating system then removes the program from its tables of running programs, and reclaims any resources dedicated to the program</li>
<li>In Sigma16, you request termination by </li>
</ul>
<h3 id="character-strings-pointer-to-array-of-characters">Character strings: pointer to array of characters</h3>
<ul>
<li>A string like  is represented as an array of characters</li>
<li>Each element of the array contains one character</li>
<li>If you are writing a string to output, the last character of the string should be a ``newline character’’</li>
</ul>
<h3 id="write-operation-on-sigma16">Write operation on Sigma16</h3>
<p>To write a string of characters</p>
<ul>
<li>trap R1,R2,R3</li>
<li>R1 — 2 is the code that indicates a write request</li>
<li>R2 — address of first word of string to write</li>
<li>R3 — length of string (the last word should be newline character)</li>
<li>See example program Write.asm.txt</li>
</ul>
<p>Writing a string</p>
<p>To write a string named , we use (1) lea to load a constant, (2) lea to load the address of an array, (3) load to get a variable</p>
<pre><code>; write out (size = k)
     lea    R1,2[R0]         ; trap code: write
     lea    R2,animal[R0]    ; address of string to print
     load   R3,k[R0]         ; string size = k
     trap   R1,R2,R3         ; write out (size = k)

     trap   R0,R0,R0         ; terminate

k    data   4    ; length of animal
; animal = string &quot;cat&quot;
animal
     data   99   ; character code for &#39;c&#39;
     data   97   ; character code for &#39;a&#39;
     data  116   ; character code for &#39;t&#39;
     data   10   ; character code for newline</code></pre>
<h2 id="procedures">Procedures</h2>
<ul>
<li><p>Often there is a sequence of instructions that comes up again and again</p>
<ul>
<li>For example: sqrt (square root)</li>
<li>It takes a lot of instructions to calculate a square root</li>
<li>An application program may need a square root in many different places</li>
</ul></li>
<li><p>We don’t want to keep repeating the code</p></li>
<li>It’s tedious</li>
<li><p>It wastes space (all those instructions require memory!)</p></li>
<li><p>The aim:  and </p></li>
<li>Write the code  — the block of code is called a procedure (or subroutine, function)</li>
<li>Put the instructions off by themselves somewhere, not in the main flow of instructions</li>
<li>Give the block of code a label (e.g. work) that describes what it does</li>
<li>Every time you need to perform this computation, : go to work</li>
<li><p>When it finishes, </p></li>
</ul>
<h3 id="call-and-return">Call and return</h3>
<ul>
<li>One idea is just to use jump instructions for both call and return</li>
<li>But that isn’t actually sufficient — let’s look in more detail at what happens</li>
</ul>
<p>Returning to the instruction after the call</p>
<ul>
<li>Suppose a procedure named {dowork} is used in several places</li>
<li>Each call jumps to the same place (the address of the first instruction of the procedure</li>
<li>But the calls </li>
<li>Therefore the procedure must finish by </li>
</ul>
<p>Calling and returning</p>
<p>Here is a main program that calls a procedure ``dowork’’ several times. (It takes the value in R1 and doubles it, and the main program would use the result but we ignore that here.)</p>



<p></p>
<h3 id="the-jump-and-link-instruction-jal">The jump-and-link instruction: jal</h3>
<ul>
<li>When the main program calls the subroutine, it needs to </li>
<li>This is the purpose of the  instruction — jump and link</li>
<li><p></p></li>
<li>A  — the return address — is loaded into the destination register (e.g. R5)</li>
<li><p>Then the machine jumps to the effective address</p></li>
</ul>
<p>Jumping</p>
<p>All jump instructions (jump, jal, jumplt, etc.) refer to </p>
<ul>
<li>jump  \ { goto loop}</li>
<li>jump  \ { goto instruction whose address is in R14}</li>
<li>jump  \ { goto instruction whose address is const+R2}</li>
</ul>
<p>Implementing call and return</p>
<ul>
<li><p>To call a procedure : </p>
<ul>
<li>The address of the instruction  the jal is placed in R13</li>
<li>The program jumps to the effective address, and the procedure starts executing</li>
</ul></li>
<li><p>To return when the procedure has finished: </p></li>
<li>The effective address is 0 + the address of the instruction after the jal</li>
<li><p>The program jumps there and the main program resumes</p></li>
</ul>
<h3 id="calling-with-jal-and-returning-with-jump">Calling with jal and returning with jump</h3>


<ul>
<li> — jal puts a pointer to the next instruction into R13</li>
<li>{return} — follow the pointer in R13</li>
</ul>
<p> (call1) to [out=180, in=175] (entry.west);  (return.east) to [out=10, in=0] (ret1.east);  (call2) to [out=2000, in=150] (entry.north west);  (return.north east) to [out=45, in=0] (ret2.east);</p>
<h3 id="parameter-passage">Parameter passage</h3>
<ul>
<li>There are several different conventions for passing argument to the function, and passing the result back</li>
<li>What is important is that the caller and the procedure agree on how information is passed between them</li>
<li>If there is a small number of arguments, the caller may put them in registers before calling the procedure</li>
<li>If there are many arguments, the caller builds an array or vector (sequence of adjacent memory locations), puts the arguments into the vector, and passes the address of the vector in a register (typically R1)</li>
<li>A simple convention: </li>
</ul>
<h3 id="functions">Functions</h3>
<ul>
<li><p>A  is a procedure that</p>
<ul>
<li>Receives a parameter (a word of data) from the caller</li>
<li>Calculates a result</li>
<li>Passes the result back to the caller when it returns</li>
</ul></li>
<li><p>A  is a function that doesn’t do anything else — it doesn’t change any global variables, or do any input/output</p></li>
</ul>
<p>Example: Passing argument and result in R1</p>
<pre><code>; Main program
       load  R1,x[R0]       ; arg = x
       jal   R13,work[R0]   ; result = work (x)
       ...
       load  R1,y[R0]       ; arg = y
       jal   R13,work[R0]   ; result = work (y)
       ...

; Function work (x) = 1 + 7*x
work   lea   R2,7[R0]       ; R7 = 2
       lea   R3,1[R0]       ; R3 = 1
       mul   R1,R1,R2       ; result = arg * 7
       add   R1,R3,R1       ; result = 1 + 7*arg
       jump  0[R13]         ; return</code></pre>
<h3 id="what-if-a-procedure-calls-another-procedure">What if a procedure calls another procedure?</h3>
<ul>
<li><p>The simplest kind of procedure</p>
<ul>
<li>Call it with </li>
<li>It returns by executing </li>
</ul></li>
</ul>
<p>Limitations of basic call</p>
<ul>
<li>If the procedure modifies any registers, it may destroy data belonging to the caller
<ul>
<li>If the procedure calls another procedure, it can’t use R13 again. Each procedure would need a dedicated register for its return address, limiting the program to a small number of procedures</li>
<li>The basic call mechanism doesn’t allow a procedure to call itself (this is called )</li>
</ul></li>
</ul>
<h3 id="r13-overwritten-proc1-returns-to-the-wrong-place">R13 overwritten: proc1 returns to the wrong place!</h3>

<h3 id="saving-state">Saving state</h3>
<ul>
<li><p>Calling a procedure creates new information</p>
<ul>
<li>The return address</li>
<li>Whatever values the procedure loads into the registers</li>
</ul></li>
<li>But this new information could overwrite essential information belonging to the caller</li>
<li><p>We need to  so the procedure won’t destroy it</p></li>
</ul>
<p>The wrong way to save state</p>
<ul>
<li>Suppose we just have a variable saveRetAdr</li>
<li>Store R13 into it in the procedure, load that when we return</li>
<li>Now it’s ok for proc1 to call proc2</li>
<li>But if proc2 calls proc3 we are back to the same problem: it doesn’t work!</li>
<li>The solution: a </li>
</ul>
<p>Saving registers</p>
<ul>
<li>Most procedures need to use several registers</li>
<li>It’s nearly impossible to do  without using some registers!</li>
<li>The first thing a procedure should do is to  it will use by copying them into memory (with store instructions).</li>
<li>The last thing it should do before returning is to  by copying their values back from memory (with load instructions).</li>
</ul>
<p>Where can the registers be saved?</p>
<ul>
<li>It won’t work to copy data from some of the registers to other registers!</li>
<li>It’s essential to save the data into memory</li>
<li><p>Two approaches</p></li>
<li>Allocate fixed variables in memory to save the registers into — simple but doesn’t allow recursion</li>
<li><p>Maintain a  in memory, and  the data onto the stack — this is the best approach and is used by most programming languages</p></li>
</ul>
<p>Who saves the state: the caller or the procedure?</p>
<ul>
<li>Two approaches:
<ul>
<li><p>Caller saves (used occasionally)</p></li>
<li>Before calling a procedure, the caller saves the registers, so all its essential data is in memory</li>
<li><p>After the procedure returns, the caller does whatever loads are needed</p></li>
<li><p>Callee saves (usually the preferred solution)</p></li>
<li>The caller keeps data in registers, and assumes that the procedure won’t disturb it</li>
<li>The first thing the procedure does is to save the registers it needs to use into memory</li>
<li><p>Just before returning, the procedure restores the registers by loading the data from memory</p></li>
</ul></li>
</ul>
<h3 id="stack-of-return-addresses">Stack of return addresses</h3>
<ul>
<li>To allow a large number of procedures, we can’t dedicate a specific register to each one for its return address</li>
<li><p>Therefore we</p></li>
<li>Always use the same register for the return address in a jal instruction (we will use R13)</li>
<li>The first thing a procedure does is to store its return address into memory</li>
<li>The last thing the procedure does is to load its return address and jump to it</li>
<li><p>The return addresses are pushed onto a , rather than being stored at a fixed address</p></li>
</ul>
<h2 id="stacks">Stacks</h2>
<ul>
<li>A  is a container</li>
<li>Initially it is empty</li>
<li>You can  a value onto the stack; this is now sitting on the top of the stack</li>
<li>You can  the stack; this removes the  value and returns it</li>
<li>A stack allows access only to the top value; you cannot access anything below the top</li>
<li>We can save procedure return addresses on a stack because return always needs the most recently saved return address</li>
</ul>
<p>Initially the stack is empty</p>
<p>Call procedure, push return address a</p>
<p>a</p>
<p>Call another procedure, push return address b</p>
<p>b a</p>
<p>Return: pop produces return address b</p>
<p>a</p>
<p>Call some procedure, push return address c</p>
<p>c a</p>
<p>Call a procedure, push return address d</p>
<p>d c a</p>
<h3 id="the-call-stack-2">The call stack</h3>
<ul>
<li><p>Central technique for</p>
<ul>
<li>Preserving data during a procedure call</li>
<li>Holding most of your variables</li>
</ul></li>
<li><p>It goes by several names; these are all the same thing</p></li>
<li>call stack</li>
<li>execution stack</li>
<li><p>``The stack’’</p></li>
<li><p>It’s important!</p></li>
<li>Most programming languages use it</li>
<li>Computers are designed to support it</li>
<li><p>Often referred to (Stack Overflow web site, etc.)</p></li>
</ul>
<p>Stack frames</p>
<ul>
<li>There is a  or  that maintains complete information about all procedure calls and returns</li>
<li>Every ``activation’’ of a procedure pushes a </li>
<li>When the procedure returns, its stack frame is popped (removed) from the stack</li>
<li>R14 contains the address of the current (top) stack frame</li>
<li><p>The stack frame contains:</p></li>
<li>A pointer to the previous stack frame (this is required to make the pop work)</li>
<li>The return address (saved value of R13)</li>
<li>The saved registers (so the procedure can use the registers without destroying information)</li>
<li><p>Local variables (so the procedure can have some memory of its own to use)</p></li>
</ul>
<p>Implementing the call stack</p>
<ul>
<li>Dedicate R14 to the </li>
<li>This is a programming convention, not a hardware feature</li>
<li>When the program is started, R14 will be set to point to an empty stack</li>
<li>When a procedure is called, the saved state will be pushed onto the stack: store a word at 0[R14] and add 1</li>
<li>When a procedure returns, it pops the stack and restores the state: subtract 1, load from 0[R14]</li>
<li>The program should never modify R14 apart from the push and pop</li>
</ul>
<h2 id="retrospective">Retrospective</h2>
<p>What is a computer program?</p>
<ul>
<li><p>A beginner’s view</p>
<ul>
<li>The computer runs programs</li>
<li>A program is lines of code of (Python, C, whatever)</li>
</ul></li>
<li>The strange program shows how wrong that is!</li>
<li><p>A more sophisticated view</p></li>
<li>The lines of source code are input to the assembler (compiler) which generates the  value of the machine language</li>
<li>When the program is booted, the initial machine language is stored in memory</li>
<li><p>The computer executes the machine language instructions in memory; the original assembly language code (labels and all) no longer exists</p></li>
<li><p>Essential concepts:</p></li>
<li>Source code and object code</li>
<li><p>Compile time and run time</p></li>
</ul>
<p>What is a variable?</p>
<ul>
<li><p>Beginner’s view</p>
<ul>
<li>A variable is a box with a name that holds a value</li>
<li>An expression can use the value in the box; an assignment can modify the value in the box</li>
<li>In assembly language, you define a variable with a data statement</li>
</ul></li>
<li><p>A more sophisticated view</p></li>
<li>Variables are distinct from variable names: many variables may have the same name</li>
<li>A variable has a scope in a program: a region where it corresponds to a particular box</li>
<li>Variables do not correspond to data statements: they are created and destroyed dynamically as a program runs</li>
<li><p>Initialising a variable is not the same as assigning a value to it</p></li>
</ul>
<h3 id="review-of-procedures-call-with-jal-return-with-jump">Review of procedures: Call with jal, return with jump</h3>
<ul>
<li><p>To call a procedure : </p>
<ul>
<li>The address of the instruction  the jal is placed in R13</li>
<li>The program jumps to the effective address, and the procedure starts executing</li>
</ul></li>
<li><p>To return when the procedure has finished: </p></li>
<li>The effective address is 0 + the address of the instruction after the jal</li>
<li><p>The program jumps there and the main program resumes</p></li>
</ul>
<p>Review: Basic calls with jal</p>
<ul>
<li><p>The simplest kind of procedure</p>
<ul>
<li>Call it with </li>
<li>It returns by executing </li>
</ul></li>
</ul>
<h3 id="review-activation-records-a.k.a.-stack-frames">Review: Activation records, a.k.a. stack frames</h3>
<ul>
<li>There is a  or  that maintains complete information about all procedure calls and returns</li>
<li>Every ``activation’’ of a procedure pushes a </li>
<li>When the procedure returns, its stack frame is popped (removed) from the stack</li>
<li>R14 contains the address of the current (top) stack frame</li>
<li><p>The stack frame contains:</p></li>
<li>A pointer to the previous stack frame (this is required to make the pop work)</li>
<li>The return address (saved value of R13)</li>
<li>The saved registers (so the procedure can use the registers without destroying information)</li>
<li><p>Local variables (so the procedure can have some memory of its own to use)</p></li>
</ul>
<p>empty; push a; push b, push c, pop returns c, push d, push e, pop returns e, pop returns d, <span class="math inline">…</span></p>
<h2 id="linked-lists">Linked lists</h2>
<p>Review of pointers</p>
<ul>
<li>p := &amp;x p is a pointer to x</li>
</ul>
<pre><code>    lea   R5,x[R0]   ; R5 := &amp;x</code></pre>
<ul>
<li>y := *p y is the value that p points to</li>
</ul>
<pre><code>    load   R6,0[R5]   ; R6 := *R5</code></pre>
<p>Nodes</p>
<ul>
<li>A linked list consists of a linear chain of </li>
<li><p>A node is a </p></li>
<li> is a word containing useful information, the  of the node. May be an integer, character, or even a pointer to something else.</li>
<li><p> is a word containing a pointer to the next node in the list</p></li>
<li>The last node in the list has a special value  in the  field</li>
<li><p> is represented by 0 (so you can’t have a pointer to memory location 0, but normally that’s where the program will be so you wouldn’t want that anyway)</p></li>
</ul>
<p>Accessing the fields of a node</p>
<ul>
<li>Suppose p is a pointer to a node</li>
<li>load R1,p[R0] ; R1 := p</li>
<li>load R2,0[R1] ; R2 := (*p).value</li>
<li>load R3,1[R1] ; R3 := (*p).next</li>
</ul>
<p>Representing a linked list</p>
<p>Basic operations on lists</p>
<ul>
<li><p>Three key operations:</p>
<ul>
<li>Is a list p empty?</li>
<li>What’s the value in a node?</li>
<li>What’s the next node</li>
</ul></li>
<li>The following code assumes that all the pointer variables (p, q) are in memory, so they must be loaded and stored</li>
<li><p>In practice, we often keep the pointers in registers so you don’t need all those loads and stores</p></li>
</ul>
<h3 id="is-list-p-empty">Is list p empty?</h3>
<ul>
<li>Nil is 0, so the list that p points at is empty iff p=0</li>
<li>Generally it is unsafe to perform an action on a list p unless p actually points to a node, so this test is commonly needed</li>
</ul>
<pre><code>    load   R1,p[R0]
    cmpeq  R2,R1,R0
    jumpt  R2,pIsEmpty[R0]
; No, p is not empty
 ...
 ...
pIsEmpty
; Yes, p is empty</code></pre>
<h3 id="get-value-in-node-that-p-points-at-x-p.value">Get value in node that p points at: x := *p.value</h3>
<ul>
<li>x := *p.value</li>
<li>This is safe to do only if p is not empty</li>
<li>The value field of a node is at offset 0 in the node record</li>
</ul>
<pre><code>   load   R1,p[R0]    ; R1 := p
   load   R2,0[R1]    ; R2 := *p.value
   store  R2,x[R0]    ; x := *p.value</code></pre>
<h3 id="get-pointer-to-next-node-in-a-list-q-p.next">Get pointer to next node in a list: q := *p.next</h3>
<ul>
<li>q := *p.next</li>
<li>This is safe to do only if p is not empty</li>
<li>The next field of a node is at offset 1 in the node record</li>
</ul>
<pre><code>   load   R1,p[R0]    ; R1 := p
   load   R2,1[R1]    ; R2 := *p.next
   store  R2,q[R0]    ; q := *p.next</code></pre>
<h3 id="traversing-a-list">Traversing a list</h3>
<p>A while loop is the best looping construct for traversing a list</p>
<p>ListSum (p) { sum := 0; while p /= nil do { x := (<em>p).value; sum := sum + x; p := (</em>p).next; }</p>
<h3 id="search-a-list-p-for-a-value-x">Search a list p for a value x</h3>
<p>Again, the best looping construct is a while loop</p>
<pre><code>ListSearch (p, x)
  { found := False;
    while p /= nil &amp;&amp; not found do
      { found := x = (*p).value;
        p := (*p).next;
      }
    return found;
  }</code></pre>
<p>This is a good example of the proper use of a while loop</p>
<ul>
<li>The condition checks for end of data, and also for early completion</li>
<li>There is no break statement or goto</li>
<li>The loop works even if the original list p is nil</li>
</ul>
<h3 id="cons-constructing-a-list-be-consing-a-value-to-the-front">cons — constructing a list be consing a value to the front</h3>
<ul>
<li>Suppose p = [23, 81, 62]</li>
<li>q := cons (56, p)</li>
<li><p>After computing q, we have</p></li>
<li>q = [56, 23, 81, 62] </li>
<li><p>p = [23, 81, 62] </p></li>
</ul>
<p>Implementing cons</p>
<pre><code>cons (x, p)
  { q := newnode ();
    (*q).value := x;
    (*q).next := p;
    return q;
  }</code></pre>
<ul>
<li>No change is made to p, or to the node p points to</li>
<li>A new node is allocated and set to point to p</li>
<li>A pointer to the new node is returned</li>
<li>A function like cons — which produces a new result but does not modify its arguments — is called a </li>
</ul>
<p>Getting a new node from avail list</p>
<pre><code>if avail = nil
  then { error &quot;fatal error: out of heap&quot; }
  else { newnode := avail;
         avail := (*avail).next;
         return newnode;
       }</code></pre>
<p>Inserting a node with x where p points</p>
<pre><code>r := newnode ();
(*r).value := x;
(*r).next := (*p).next;
(*p).next := r;</code></pre>
<ul>
<li>Notice that we can insert x  the node that p points to</li>
<li>But we cannot insert x  that node</li>
<li>It’s common, in list algorithms, to have two pointers moving along through the list, one lagging an element behind the other, to make insertion possible</li>
</ul>
<h3 id="list-header">List header</h3>
<ul>
<li>Suppose we have a list p and a value x</li>
<li>We want to insert x into the list p at an arbitrary point</li>
<li>Another pointer q points to the insertion position</li>
<li><p>A slightly awkward problem: the code to insert x at the front of the list is slightly different from the code to insert x after some element (*q)</p></li>
<li>If somewhere in the middle, we can insert x  the node that q points to</li>
<li>The insertion algorithm will change (*q).next</li>
<li><p>But if we need to insert x at the beginning of the list, we cannot do that; instead the pointer p needs to be changed</p></li>
<li><p>Solution: don’t use an ordinary variable for p; make a  whose next field points to the list</p></li>
</ul>
<h3 id="deleting-a-node">Deleting a node</h3>
<ul>
<li>Need a pointer p into the list; the node  p will be deleted</li>
<li>Just change (*p).next to skip over the next node, and point to the one after</li>
<li>The node being deleted should be returned to the avail list, so it can be reused</li>
</ul>
<p>If p points to a node, delete the node after that, assuming it exists</p>
<pre><code>delete (p)
  { if p /= nil
    then { q := (*p).next;
           if q /= nil
             then { (p*).next := (*q).next;
                    (*q).next := avail;
                    avail := q;
                  }
         }
  }</code></pre>
<ul>
<li>We can’t delete the node p points to, we can only delete the following node, which q points at</li>
<li>If you know that p cannot be nil, the first test can be omitted</li>
<li>We do need to check whether q = nil; if it is, there’s no node to delete</li>
<li>It doesn’t matter whether (*q).next is nil</li>
<li>It’s important to check whether the operation we’re performing is actually possible!</li>
</ul>
<h3 id="memory-management">Memory management</h3>
<ul>
<li>If you return a deleted node to the avail list, it can be reused</li>
<li>If you don’t, this node becomes inaccessible: it doesn’t hold useful data, yet it can’t be allocated</li>
<li></li>
<li><p>Over time, as a program runs, more and more nodes may become inaccessible: a </p></li>
<li>It’s a bug if you delete a node that contains useful data</li>
<li>It’s a bug if you don’t delete a node that doesn’t contain useful data</li>
<li>With complicated data structures, this can be difficult</li>
<li><p>A common solution is </p></li>
<li>The program doesn’t explicitly return nodes to the avail list</li>
<li>Periodically, the  traverses all data structures and marks the nodes it finds</li>
<li><p>Then the GC adds all unmarked nodes to the avail list</p></li>
</ul>
<h3 id="sharing-and-side-effects">Sharing and side effects</h3>
<ul>
<li>Suppose p = [6, 2, 19, 37, 41]</li>
<li>Traverse a few elements, and set q to point to the 19 node</li>
<li>Now q = [19, 37, 41] and p is unchanged</li>
<li><p>Then delete the second element of q. The result is</p></li>
<li>q = [19, 41]</li>
<li><p>p = [6, 2, 19, 41] </p></li>
<li>This is called a </li>
<li><p>Sometimes you want this to happen, sometimes not, so it’s important to be careful about it!</p></li>
</ul>
<h2 id="comparing-lists-and-arrays">Comparing lists and arrays</h2>
<ul>
<li>Lists and arrays are two different kinds of data structure that contain a sequence of data values</li>
<li>How do you decide which to use?</li>
<li>Consider the properties of lists and arrays, and the needs of your program</li>
<li>And there are many other data structures to choose from, which you’ll encounter as you learn computer science</li>
</ul>
<p>Accessing elements</p>
<ul>
<li><p>Direct access to an element</p>
<ul>
<li>Array: gives direct access (``random access’’) to element with arbitrary index <span class="math inline"><em>i</em></span></li>
<li>List: gives direct access only to an element you have a pointer to; random access is inefficient</li>
</ul></li>
<li><p>Traversal</p></li>
<li>Array: initialise <span class="math inline"><em>i</em></span> to 0; repeatedly set ; terminate when <span class="math inline"><em>i</em> ≥ <em>n</em></span> (that’s the purpose of a  loop)</li>
<li><p>List: initialize <span class="math inline"><em>p</em></span> to point to the list; repeatedly set ; terminate when </p></li>
</ul>
<h2 id="example-ordered-lists-program">Example: Ordered lists program</h2>
<p>Concepts used in the program:</p>
<p>Array of records, Representing a command as a records, Traversing an array of records, Case statement and jump table</p>
<p>Traversing a list to print its elements, Insertion in list keeping the elements in ascending order, Deletion from a list, Searching a list</p>
<p>Ordered lists</p>
<p>There is an array of lists, initially empty. There are nlists of them.</p>
<pre><code>list[0] = [ ]
list[1] = [ ]
...
list[nlists-1] = [ ]</code></pre>
<p>At all times as the program runs, the lists are ordered: their elements are increasing</p>
<pre><code>list[0] = [4, 9, 23, 51 ]
list[1] = [7, 102, 238 ]
...
list[nlists-1] = [2, 87, 89, 93, 103, 195 ]</code></pre>
<p>Commands</p>
<p>The program executes commands:</p>
<ul>
<li>Terminate — the program finishes</li>
<li>Insert into list i the value x — modify list[i] so it contains x, while maintaining the ascending order</li>
<li>Delete from list i the value x — modify list[i] so x is removed, but don’t do anything if x isn’t in the list</li>
<li>Search list i for x — print Yes if x is in the list, No otherwise</li>
<li>Print i — the numbers in list[i] are printed</li>
</ul>
<p>Example</p>
<ul>
<li>Insert into list[3] the value 23 </li>
<li>Insert into list[3]the value 6 </li>
<li>Insert into list[3] the value 67 </li>
<li>Insert into list[3] the value 19 </li>
<li>Print list[3] </li>
</ul>
<p>Why are ordered lists useful?</p>
<ul>
<li>This is one way to arrange a database: think of the elements as persons’ names, or matriculation numbers</li>
<li>Sometimes you want to process all the data in a container in a specified order</li>
<li>If the data is ordered, it’s faster to find a particular item (on average you only have to check half of the items)</li>
<li>An ordered list can be used to represent a set</li>
</ul>
<p>Where do the commands come from? * In a real application, we would read the commands from input * But in this program, each command is represented as a record * The entire input is a static array of records defined with  statements * This is easier because</p>
<ul>
<li>If you read from an input device, it’s necessary to convert the input character string to numbers
<ul>
<li>In testing a program, it’s convenient to have input data that is </li>
<li>Don’t want to have to type in the same input every time you run the program!</li>
</ul></li>
</ul>
<p>Representing a command</p>
<ul>
<li><p>Each command is a record with three fields</p>
<ul>
<li>A code indicating which kind of command</li>
<li>A number i indicating which list we’re operating on</li>
<li>A value x which might be inserted etc</li>
</ul></li>
<li>Each record must have these three fields</li>
<li>Some commands don’t use them all (e.g. Print just needs i, not</li>
</ul>
<ol start="24" type="a">
<li></li>
</ol>
<ul>
<li>The main program uses a  statement to handle each command, and implements this with a </li>
</ul>
<p>Reading a program before writing</p>
<ul>
<li><p>You should  the program before modifying it</p>
<ul>
<li>Reading a program is an important skill you will need throughout your career</li>
<li>The program is filled with examples so it is excellent revision material</li>
<li><p>You need to understand a program before you’ll be able to make changes to it</p></li>
<li><p>One of the aims of the exercise is to get experience with reading a longer program—don’t skip this!</p></li>
</ul></li>
</ul>
<h2 id="testing-and-debugging">Testing and debugging</h2>
<ul>
<li>Debugging has two phases:
<ul>
<li>The most important point: don’t just make random changes to the code and hope for the best—instead, find out what the error is and fix it cleanly</li>
</ul></li>
</ul>
<p>Reading and testing a program</p>
<ul>
<li>A good way to understand a section of assembly language instructions is to step through it, one instruction at a time
<ul>
<li>Coverage \begin{enumerate}</li>
<li>You don’t need to step through a set of instructions a huge number of times</li>
<li>If there’s a loop, step through two or three iterations</li>
<li>If possible, arrange test data so the loop will terminate after just a few iterations</li>
<li>But try to step through as much of the program as possible</li>
<li>This is called : try to cover all of the program with your testing \end{enumerate}</li>
</ul></li>
</ul>
<h3 id="breakpoints">Breakpoints</h3>
<ul>
<li>It’s a good idea to step through a program one instruction at a time, so you understand clearly what each instruction is doing
<ul>
<li><p>However, in a longer program this isn’t always feasible</p></li>
<li><p>The OrderedLists program has to build the heap when it starts; this may take several thousand instructions before it even really gets going!</p></li>
<li><p>Solution: </p></li>
<li>Find the address of an instruction where you want to start single stepping</li>
<li>Enter this address as a breakpoint</li>
<li>Click Run to execute the program at full speed; when it reaches the breakpoint it will stop</li>
<li><p>Then you can single step to examine what the instructions are doing</p></li>
</ul></li>
</ul>
<p>How to set a breakpoint</p>
<p>(Revise - this refers to an older version of Sigma16, the current version is a little different.)</p>
<p>On the Processor pane, click Breakpoint. It will say `Breakpoint is off’‘. Enter the breakpoint command and click Set Breakpoint. BPeq BPpc (BPhex “01a6”). It will say ``Breakpoint is on’’. Click Close. On Processor, click Run. It will stop when the pc register gets the value you specified</p>
<h2 id="trees">Trees</h2>
<p>Usage of memory</p>
<ul>
<li><p>Memory needed per element</p>
<ul>
<li>Array: need just the memory required for the element itself (typically a word)</li>
<li>List: need a node for each element, which also requires space for the next pointer (typically a word)</li>
<li>So typically, an array with <span class="math inline"><em>n</em></span> elements needs <span class="math inline"><em>n</em></span> words, while a list requires <span class="math inline">2 × <em>n</em></span> words</li>
</ul></li>
<li><p>Flexibility</p></li>
<li>An array has fixed size and needs to be allocated fully</li>
<li><p>A list has variable size and needs only enough memory to hold its nodes</p></li>
</ul>
<p>More general data structures</p>
<ul>
<li>We can put several pointer fields in each node, and produce an enormous variety of data structures, tailored for the needs of an application program</li>
<li><p>Just a few examples</p></li>
<li>Doubly linked list: each node contains two pointers, one to the previous node and one to the next. Allows traversal both directions.</li>
<li><p>Circular list: there is no <code>last'' node where next=nil;     instead, \emph{every} node points to the next node, and the list     loops back to itself.  There is no</code>first’’ or ``last’’ node.</p></li>
</ul>
<h2 id="abstract-data-type">Abstract data type</h2>
<ul>
<li><p>A stack is an </p>
<ul>
<li>The idea: define the type by the  it supports, not by the code that implements it</li>
<li></li>
</ul></li>
<li>The stack ADT is defined by the  it supports: push, pop</li>
<li><p>There are several completely different ways to implement a stack</p></li>
<li>We have already seen how to implement a stack with an array</li>
<li><p>We can also do it with a linked list</p></li>
</ul>
<p>Linked list implementation of stack</p>
<ul>
<li>A linked list gives easy access to the front of the list, and a stack gives easy access to the top of the stack.</li>
<li>Represent Empty stack as nil</li>
<li>Push x is implemented by stack := cons (x, stack)</li>
<li>Pop x is implemented by stack := (*stack).next</li>
</ul>
<h3 id="array-implementation-of-stack">Array implementation of stack</h3>
<ul>
<li>We can implement a stack using an array</li>
<li>There is a variable  which gives the size of the array — this is the limit on the maximum number of elements that can be pushed</li>
<li>There is a variable  that gives the current number of elements in the stack</li>
</ul>
<p>Relationship between arrays and stacks</p>
<ul>
<li><p>Array</p>
<ul>
<li>A container that holds many elements</li>
<li>Each element has an index (which is an integer)</li>
<li>You can access any element x[i]</li>
<li>You can access the elements in any order</li>
</ul></li>
<li><p>Stack</p></li>
<li>A container that holds many elements</li>
<li>You can only access the top element, and you don’t need to know its index</li>
<li><p>You can (and must) access the elements in  order</p></li>
</ul>
<p>Pushing x onto a stack</p>
<pre><code>; push the x onto the stack
; stack[stTop] := R1; stTop := stTop + 1

push   load  R1,x[R0]       ; R1 := x
       load  R2,stTop[R0]   ; R2 := stTop
       store R1,stack[R2]   ; stack[stTop] := x
       lea   R3,1[R0]       ; R3 := constant 1
       add   R2,R2,R3       ; R2 := stTop + 1
       store R2,stTop[R0]   ; stTop := stTop + 1</code></pre>
<p>Pop a stack, returning x</p>
<pre><code>; pop the stack, store top element into x
; stTop := stTop - 1; x := stack[stTop]

pop    load  R2,stTop[R0]   ; R2 := stTop
       lea   R3,1[R0]       ; R3 := constant 1
       sub   R2,R1,R3       ; R2 := stTop - 1
       load  R1,stack[R2]   ; R1 := stack[stTop-1]
       store R1,x[R0]       ; x := stack[stTop-1]
       store R2,stTop[R0]   ; stTop := stTop - 1</code></pre>
<h2 id="error-checking">Error checking</h2>
<p>Issues with simplest implementation</p>
<ul>
<li><p>It doesn’t check for errors!</p>
<ul>
<li>If push is called when stack is full, data will be written outside the array</li>
<li>If pop is called when stack is empty, a garbage result will be returned</li>
</ul></li>
<li><p>Either of these errors may cause the program to get wrong answers or to crash</p></li>
</ul>
<p>Robust software</p>
<ul>
<li>Fragile software will respond to a minor problem by going haywire: might crash, or produce wrong answers</li>
<li> checks for all errors and does something appropriate; a minor problem doesn’t turn into a major one</li>
</ul>
<p>Error checking and error handling</p>
<ul>
<li><p>Software should not assume everything is ok — it should check for errors</p>
<ul>
<li>push (x) when the stack is full</li>
<li>x := pop () when the stack is empty</li>
</ul></li>
<li>If an error is detected, the error must be </li>
<li><p>There are many approaches</p></li>
<li>Produce a message and terminate the program</li>
<li>Return an error code to the calling program and let it decide what to do</li>
<li><p>Throw an exception, which will interrupt the calling program, and invoke its error handler</p></li>
</ul>
<p>For simplicity, we will terminate the program if an error occurs.</p>
<p>Error checking: push</p>
<p>If the stack is full, there is no space to store the new element, so push fails</p>
<pre><code>; push (v)
; if stTop &gt;= stLim
;     then
;        terminate because the stack is full: cannot push
;     else
;        stack[stTop] := v
;        stTop := stTop + 1
;        return ()</code></pre>
<p>Error checking: pop</p>
<p>If the stack is empty, there is no element to return, so pop fails</p>
<pre><code>; v = pop ()
;   if stTop == 0
;     then
;       terminate because the stack is empty: cannot pop
;     else
;       stTop := stTop - 1
;       v := stack[stTop]
;       return (v)</code></pre>
<h2 id="programming-techniques">Programming techniques</h2>
<ul>
<li>Compound Boolean expressions: ``short circuit’’ evaluation</li>
<li>The condition code and ``cmp jumpgt’’ style comparisons</li>
<li>loops: for loop, while loop, repeat until loop</li>
<li>Input/Output: write characters, not numbers</li>
</ul>
<h3 id="compound-boolean-expressions">Compound Boolean expressions</h3>
<p>Notation: various programming languages use several slightly different notations are used for Boolean operators</p>
<pre><code>i&lt;n and x[i]&gt;0      i&lt;n &amp;&amp; x[i]&gt;0     i&lt;n &amp; x[i]&gt;0
i&lt;n or  j&lt;n         i&lt;n || j&lt;n        i&lt;n | x[i]&gt;0</code></pre>
<h3 id="short-circuit-expressions">``Short circuit’’ expressions</h3>
<ul>
<li>Suppose  is an array with  elements</li>
<li>Consider </li>
<li>If the first expression  is False, then the whole expression is False</li>
<li>In that case, there is no need to evaluate the second expression </li>
<li>We can ``short circuit’’ the evaluation</li>
<li>Big advantage: if  is False, then  does not exist and evaluating it could cause an error</li>
<li>So it is  not to evaluate the second expression if the first one is false</li>
</ul>
<p>Implementing a compound boolean expression</p>
<pre><code>while i&lt;n &amp;&amp; x[i]&gt;0 do S

; if not (i&lt;n &amp;&amp; x[i]&gt;0) then goto loopDone
    load   R1,i[R0]          ; R1 := i
    load   R2,n[R0]          ; R2 := n
    cmplt  R3,R1,R2          ; R3 := i&lt;n
    jumpf  R3,loopDone[R0]   ; if not (i&lt;n) then goto loopDone
    load   R3,x[R1]          ; R3 := x[i]   safe because i&lt;n
    cmpgt  R4,R3,R0          ; R4 := x[i]&gt;0
    jumpf  R4,loopDone[R0]   ; if not (x[i]&gt;0) then goto loopDone</code></pre>
<p>This is better than evaluating both parts of the expression and calculating logical and</p>
<h3 id="condition-code">Condition code</h3>
<ul>
<li>We have seen one style for comparison and conditional jump</li>
</ul>
<pre><code>   cmplt  R3,R8,R4
   jumpt  R3,someplace[R0]</code></pre>
<ul>
<li>There is also another way you can do it</li>
</ul>
<pre><code>   cmp    R8,R4           ; no destination register
   jumplt someplace[R0]   ; jump if less than</code></pre>
<ul>
<li>The cmp instruction sets a result (less than, equal, etc) in R15 which is called the </li>
<li>There are conditional jumps for all the results: jumpeq, jumplt, jumple (jump if less than or equal), etc</li>
<li>An advantage is that you don’t need to use a register for the boolean result</li>
</ul>
<h4 id="repeat-until-loop">Repeat-until loop</h4>
<p>This is similar to a while loop, except you decide whether to continue at the end of the loop</p>
<pre><code>repeat
  {S1; S2; S3}
until i&gt;n;</code></pre>
<p>This is equivalent to</p>
<pre><code>S1; S2; S3;
while not (i&gt;n) do
  {S1; S2; S3}</code></pre>
<p>The while loop is used far more often, but if you need to go through the loop at least one time, the repeat-until is useful</p>
<h2 id="inputoutput">Input/Output</h2>
<ul>
<li><p>A character is represented by a code using ASCII or Unicode</p>
<ul>
<li>http://www.asciitable.com/</li>
<li>https://unicode-table.com/en/</li>
</ul></li>
<li><p>digit characters 0..9 have codes (in decimal) 48..57</p></li>
<li><p>Example: ‘3’ is represented by the number 51, not by the number 3</p></li>
<li>lower case a..z have codes (in decimal) 97..122</li>
<li>upper case A..Z have codes (in decimal) 65..90</li>
<li><p>To print a number, we need to convert it to a string of characters</p></li>
</ul>
<h3 id="converting-a-number-to-a-string">Converting a number to a string</h3>
<ul>
<li>We actually need to do arithmetic to convert a binary number to decimal, and to a string of decimal digits</li>
<li>The lab exercise gives the algorithm to do this</li>
<li>It needs to divide the number by 10 to get the quotient and the remainder</li>
<li><p>div R1,R2,R3</p></li>
<li>Divides R2/R3</li>
<li>The quotient goes into R1 (the destination register)</li>
<li><p>The remainder goes into R15 (always R15, you cannot change this)</p></li>
<li><p>The algorithm repeatedly divides the number by 10; the remainder is used to get a digit character</p></li>
</ul>
<h3 id="arrays-and-pointers">Arrays and pointers</h3>
<p>We have seen how to access an array element using an index register</p>
<pre><code>; R5 := x[i]
    load   R2,i[R0]    ; R2 := i
    load   R5,x[R2]    ; R5 := x[i]</code></pre>
<h3 id="sum-of-an-array-x-using-index-high-level">Sum of an array x using index: high level</h3>
<p>Suppose x is an array of numbers, and sizeX is the number of elements. We want to add up all the elements of x.</p>

<p>A for loop is convenient (the whole purpose of the for loop is for writing this kind of loop):</p>
<pre><code>   sum := 0;
   for i := 0 to sizeX do
     { sum := sum + x[i]; }</code></pre>
<p>You can also use a while loop:</p>
<pre><code>   sum := 0;
   i := 0;
   while i &lt; sizeX do
     { sum := sum + x[i];
       i := i + 1; }</code></pre>
<h3 id="arrays-and-pointers-1">Arrays and pointers</h3>
<ul>
<li>There is also another way to access an array element, </li>
<li>To do this, we will perform </li>
</ul>
<h3 id="accessing-an-array-element-using-a-pointer">Accessing an array element using a pointer</h3>
<ul>
<li>Create a pointer p to the beginning of the array x, so p is pointing to x[0]\ </li>
<li>To access the current element, follow p:\ </li>
<li>To move on to the next element of the array, increment p\ </li>
<li>Notice that we are doing </li>
</ul>
<pre><code>x   data  34   ; first element of x
    data  82
    data  91
    data 29    ; last element of x
xEnd           ; address of first word after array x</code></pre>
<h3 id="sum-of-an-array-x-using-pointers-high-level">Sum of an array x using pointers: high level</h3>
<pre><code>   sum := 0;
   p := &amp;x;
   q := &amp;xEnd;
   while p&lt;q do
     { sum := sum + *p;
       p := p + 1; }</code></pre>
<ul>
<li>In assembly language, we can use lea to increment the pointer.</li>
<li>Suppose p is in R1, then\ </li>
<li>We are incrementing p by the size of an array element</li>
</ul>
<h3 id="sum-of-an-array-x-using-pointers-assembly-language">Sum of an array x using pointers: assembly language</h3>
<pre><code>;   R1 = p = pointer to current element of array x
;   R2 = q = pointer to end of array x
;   R3 = sum of elements of array x

    lea   R1,x[R0]      ; p := &amp;x
    lea   R2,xEnd[R0]   ; q := %xEnd
    add   R3,R0,R0      ; sum := 0
sumLoop
    cmplt R4,R1,R2      ; R4 := p&lt;q
    jumpf sumLoopDone   ; if not p&lt;q then goto sumLoopDone
    load  R4,0[R1]      ; R4 := *p  (this is current element of x)
    add   R3,R3,R4      ; sum := sum + *p
    lea   R1,1[R1]      ; p := p+1  (point to next element of x)
    jump  sumLoop[R0]   ; goto sumLoop
sumLoopEnd

x   data  23   ; first element of x
    data  42   ; next element of x
    data 19    ; last element of x
xEnd</code></pre>
<p>}</p>
<h3 id="comparing-the-two-approaches">Comparing the two approaches</h3>
<ul>
<li><p>Accessing elements of an array using index</p>
<ul>
<li>Get x[i] with load R5,x[R1] where R1=i</li>
<li>Move to next element of array by i := i+1</li>
<li>Determine end of loop with </li>
<li>Know in advance how many iterations: xSize</li>
<li>A for loop is convenient</li>
</ul></li>
<li><p>Accessing elements of an array using pointer</p></li>
<li>Initialize p with lea R1,x[R0]</li>
<li>Get x[i] with load R5,0[R1] where R1=p</li>
<li>Move to next element of array by </li>
<li>Determine end of loop with  (q points to end of array)</li>
<li>Don’t need to know in advance how many iterations</li>
<li><p>Need to use a while loop</p></li>
<li>Both techniques are important</li>
<li><p></p></li>
</ul>
<h3 id="records-2">Records</h3>
<pre><code>program Records
 { x, y :
     record
       { fieldA : int;
         fieldB : int;
         fieldC : int; }
   x.fieldA := x.fieldB + x.fieldC;
   y.fieldA := y.fieldB + y.fieldC;
 }</code></pre>
<p>Suppose we have an array of these records, and want to</p>
<ul>
<li>set fieldA := fieldB + fieldC in every record in the array</li>
<li>Calculate the sum of the fieldA in every record</li>
</ul>
<h3 id="traverse-array-of-records-with-indexing">Traverse array of records with indexing</h3>
<pre><code>sum := 0;
for i := 0 to nrecords do
  { RecordArray[i].fieldA :=
       RecordArray[i].fieldB + RecordArray[i].fieldC;
    sum := RecordArray[i].fieldA; }</code></pre>
<ul>
<li>This is ok</li>
<li>But it is a little awkward</li>
</ul>
<h3 id="traverse-array-of-records-with-pointers-high-level">Traverse array of records with pointers: high level</h3>
<pre><code>sum := 0;
p := &amp;RecordArray;
q := &amp;RecordArrayEnd;
while p &lt; q do
  { *p.fieldA := *p.fieldB + *p.fieldC;
    sum := sum + *p.fieldA;
    p := p + RecordSize; }</code></pre>
<p>In professional programming, this is often preferred because accessing the elements of the records is easier (it’s easier to access an ``element of an element’’ via pointer)</p>
<h3 id="traverse-array-of-records-with-pointers-low-level">Traverse array of records with pointers: low level</h3>
<pre><code>;    sum := 0;
;    p := &amp;RecordArray;
;    q := &amp;RecordArrayEnd;
; RecordLoop
;    if (p&lt;q) = False then goto recordLoopDone;
;    *p.fieldA := *p.fieldB + *p.fieldC;
;    sum := sum + *p.fieldA;
;    p := p + RecordSize;
;    goto recordLoop;
; RecordLoopDone</code></pre>
<h3 id="traverse-array-of-records-with-pointers-assembly-language">Traverse array of records with pointers: assembly language</h3>
<pre><code>;   R1 = sum
;   R2 = p (pointer to current element)
;   R3 = q (pointer to end of array)
;   R4 = RecordSize

    lea    R1,0[R0]                 ; sum := 0
    lea    R2,RecordArray[R0]       ; p := &amp;RecordArray;
    lea    R3,RecordArrayEnd[R0]    ; q := &amp;RecordArray;
    load   R4,RecordSize[R0]        ; R4 := RecordSize
RecordLoop
    cmplt  R5,R2,R3                 ; R5 := p&lt;q
    jumpf  R5,RecordLoopDone[R0]    ; if (p&lt;q) = False then goto RecordLoopDone
    load   R5,1[R2]                 ; R5 := *p.fieldB
    load   R6,2[R2]                 ; R6 := *p.fieldC
    add    R7,R5,R6                 ; R7 := *p.fieldB + *p.fieldC
    store  R7,0[R2]                 ; *p.fieldA := *p.fieldB + *p.fieldC
    add    R1,R1,R7                 ; sum := sum + *p.fieldA
    add    R2,R2,R4                 ; p := p + RecordSize
    jump   RecordLoop[R0]           ; goto RecordLoop
RecordLoopDone</code></pre>
<p>}</p>
<h3 id="stack-overflow">Stack overflow</h3>
<ul>
<li>The mechanism for calling a procedure and returning is fairly complicated</li>
<li>Rather than introducing all the details at once, we have looked at several versions, introducing the concepts one at a time</li>
<li><p>Now we introduce the next level:</p></li>
<li>Simplify calling a procedure</li>
<li><p>The procedure checks for stack overflow</p></li>
<li><p>We need two more registers dedicated to procedures</p></li>
<li>R12 holds stack top (the highest address in current stack frame)</li>
<li><p>R11 holds stack limit (the stack is not allowed to grow beyond this address)</p></li>
</ul>
<p>Register usage</p>
<p>See the PrintIntegers program for examples</p>
<pre><code>; Global register usage
;   R0 = constant 0
;   R1, R2, R3 are used for parameters and return values
;   R4 - R10 are available for local use in a procedure
;   R11 = stack limit
;   R12 = stack top
;   R13 = return address
;   R14 = stack pointer
;   R15 is transient condition code</code></pre>
<p>Initialize the stack</p>
<pre><code>; Structure of stack frame for main program, frame size=1
;    0[R14]  dynamic link is nil

; Initialize the stack
    lea    R14,CallStack[R0]  ; initialise stack pointer
    store  R0,0[R14]          ; main program dynamic link = nil
    lea    R12,1[R14]         ; initialise stack top
    load   R1,StackSize[R0]   ; R1 := stack size
    add    R11,R14,R1         ; StackLimit := &amp;CallStack + StackSize</code></pre>
<p>Calling a procedure</p>
<ul>
<li><p>To call a procedure PROC:</p>
<ul>
<li>Place any parameters you’re passing to PROC in R1, R2, R3</li>
<li>jal R13,PROC[R0]</li>
</ul></li>
</ul>
<p>Structure of Procedure stack frame</p>
<p>(This is procedure PrintInt, see lab exercise)</p>
<pre><code>; Arguments
;   R1 = x         = two&#39;s complement number to print
;   R2 = FieldSize = number of characters for print field
;        require FieldSize &lt; FieldSizeLimit

; Structure of stack frame, frame size = 6
;    5[R14]  save R4
;    4[R14]  save R3
;    3[R14]  save R2 = argument fieldsize
;    2[R14]  save R1 = argument x
;    1[R14]  return address
;    0[R14]  dynamic link points to previous stack frame</code></pre>
<p>Called procedure creates its stack frame</p>
<pre><code>PrintInt
; Create stack frame
    store  R14,0[R12]          ; save dynamic link
    add    R14,R12,R0          ; stack pointer := stack top
    lea    R12,6[R14]          ; stack top := stack ptr + frame size
    cmp    R12,R11             ; stack top ~ stack limit
    jumpgt StackOverflow[R0]   ; if top&gt;limit then goto stack overflow
    store  R13,1[R14]          ; save return address
    store  R1,2[R14]           ; save R1
    store  R2,3[R14]           ; save R2
    store  R3,4[R14]           ; save R3
    store  R4,5[R14]           ; save R4</code></pre>
<p>Procedure finishes and returns</p>
<pre><code>; return
    load   R1,2[R14]        ; restore R1
    load   R2,3[R14]        ; restore R2
    load   R3,4[R14]        ; restore R3
    load   R13,1[R14]       ; restore return address
    load   R14,0[R14]       ; pop stack frame
    jump   0[R13]           ; return</code></pre>
<p>Stack overflow</p>
<p>If the stack is full and a procedure is called, this is a fatal error</p>
<pre><code>StackOverflow
    lea    R1,2[R0]
    lea    R2,StackOverflowMessage[R0]
    lea    R3,15[R0]   ; string length
    trap   R1,R2,R3    ; print &quot;Stack overflow\n&quot;
    trap   R0,R0,R0    ; halt

StackOverflowMessage
    data    83   ; &#39;S&#39;
    data   116   ; &#39;t&#39;
    data    97   ; &#39;a&#39;
    data    99   ; &#39;c&#39;
    data   107   ; &#39;k&#39;
...</code></pre>
<h3 id="blocks">Blocks</h3>
<ul>
<li>You’ll need to learn many programming languages, eventually</li>
<li>There are concepts that appear in most languages</li>
<li>It’s useful to focus on the general concept</li>
<li>One important concept is a block</li>
<li>A  or  is a single statement that contains several statements</li>
<li>The purpose is to let you have a group of statements in a loop, or controlled by a conditional</li>
<li><p>The  is the detailed punctuation used to indicate a block, and this varies in different languages</p></li>
<li>There are lots of small syntax differences between languages</li>
<li>Some languages use := to mean assign, = to mean equals</li>
<li><p>Some languages use = to mean assign, == to mean equals</p></li>
</ul>
<h3 id="python-syntax-style-for-blocks-layout">Python syntax style for blocks: layout</h3>
<p>The layout (the indentation) determines what is inside the if statement</p>
<pre><code>a = 1
if  x &lt; y :
  b = 2
  c = 3
d = 4</code></pre>
<p>If you change the indentation, you change the meaning of the program</p>

<p>In Python, you write  to mean , and  to mean </p>
<h3 id="algolpascal-style-for-blocks-beginend">Algol/Pascal style for blocks: begin—end</h3>
<pre><code>a := 1;
if x&lt;y
  then begin b := 2;
             c := 3
       end
  else begin d := 4;
             e := 5
       end;
f := 6;</code></pre>
<p>You write  to mean , and  to mean </p>

<p>Statements must be separated by semicolon ;</p>
<h3 id="c-style-for-blocks-braces">C style for blocks: braces</h3>
<pre><code>a = 1;
if (x &lt; y) b = 2;
else
   { d = 4;
     e = 5; }
f = 6;</code></pre>
<p>In C you don’t write  at all, but this means the condition  must be enclosed in parentheses so the compiler can tell where the condition ends and the then-statement begins</p>
<h3 id="block-structured-style-for-blocks-matching-keywords">Block structured style for blocks: matching keywords</h3>
<pre><code>a := 1;
if x&lt;y
  then b := 2;
       while i&lt;n do
           sum := sum+x[i];
          i := i+1
       endwhile
  else d := 4
       e := 5
endif;
f := 6;</code></pre>
<p>This style introduces a lot of keywords (endif, endwhile, endfor, endrepeat) but you don’t need braces around a block. It makes code more readable and enables the compiler to produce better error messages</p>
<h3 id="enter-at-beginning-exit-at-end">Enter at beginning, exit at end</h3>
<ul>
<li><p>A common programming style is to require</p>
<ul>
<li>Each block enters only at the beginning of the block</li>
<li>Each block exits only at the end of the block</li>
</ul></li>
<li>This style is helpful in some programming languages, but in some languages it sometimes makes code less readable</li>
<li>In assembly language, and for compilation patterns, it is necessary to follow this style</li>
<li><p>In high level languages this style is sometimes helpful, but not always</p></li>
</ul>
<h3 id="single-entranceexit-for-compilation-patterns">Single entrance/exit for compilation patterns</h3>
<ul>
<li>It is straightforward to translate high level control constructs using the compilation patterns</li>
<li>These  that the blocks of code always start at the beginning and finish at the end</li>
<li><p>It’s bad to jump into the middle of a block, or exit out of the middle because</p></li>
<li>The compilation patterns won’t work correctly</li>
<li>You’ll have to duplicate a lot of code</li>
<li>Example: returning from a procedure requires restoring the registers, resetting the stack pointer, loading the return address</li>
<li><p>That code should not be duplicated in several places in a procedure</p></li>
</ul>
<h3 id="systematic-approach-to-programming">Systematic approach to programming?</h3>
<ul>
<li>Start by understanding what your program should do</li>
<li>Express the algorithm using high level language notation (and it’s ok to mix in some English too)</li>
<li><p>Translate the high level to the low level</p></li>
<li>Assignment statements: x := expression</li>
<li>I/O statements: Write string</li>
<li>goto L</li>
<li><p>if boolean then goto L</p></li>
<li>Translate the low level to assembly language</li>
<li>Retain the high and low level code as comments</li>
<li><p>Do hand execution at every level</p></li>
</ul>
<p>Why use this systematic approach to programming?</p>
<ul>
<li>It enables you to write correct code at the outset, and minimise debugging</li>
<li>If there is a bug, it helps you to catch it early (e.g. in translation to goto form)</li>
<li><p>If there’s a bug in an instruction, the comments enable you to find it quickly</p></li>
<li>A common error is to use a wrong register number: add R9,R3,R4</li>
<li>Poor comments don’t help: </li>
<li>Good comments help a lot: </li>
<li><p>Look at the register usage comments (oops, x is in R8, not R9, now I know how to fix it and I don’t have to read the entire program)</p></li>
<li><p>Professional software needs to be maintained; the comments make the software easier to read and more valuable</p></li>
</ul>
<h2 id="nested-conditionals">Nested conditionals</h2>
<p>Nested if-then-else</p>
<p>Conditional statements can be nested deeply</p>
<pre><code>if b1
  then S1
       if b2
         then S3
         else S4
       S5
  else S6
       if b3
         then S7
       S8</code></pre>
<p>Special case of nested if-then-else</p>
<p>Often the nesting isn’t random, but has this specific structure:</p>
<pre><code>if b1
  then S1
  else if b2
         then S2
         else if b3
                then S3
                else if b4
                       then S4
                       else if b5
                              then S5
                              else S6</code></pre>
<p>(Some languages require punctuation to avoid ambiguity)</p>
<p>Another way to write it</p>
<p>To avoid running off the right side of the window, it’s usually indented like this:</p>
<pre><code>if b1
  then S1
else if b2
  then S2
else if b3
  then S3
else if b4
  then S4
else if b5
  then S5
else S6</code></pre>
<p>Some programming languages have elsif or elif</p>
<pre><code>if b1 then S1
  elif b2 then S2
  elif b3 then S3
  elif b4 then S4
  eleif b5 then S5
  else S6</code></pre>
<ul>
<li>It avoids ambiguity</li>
<li>It signals to the compiler and to a human programmer that this specific construct is being used</li>
<li>It allows good indentation layout without violating the basic principle of indentation</li>
<li>Some languages have this, some don’t</li>
</ul>
<p>Case and jump tables</p>
<p>A common application: numeric code</p>
<p>Nested if-then-else but the boolean conditions are not arbitrary: they are checking the value of a code:</p>
<pre><code>if code = 0
  then S1
else if code = 1
  then S2
else if code = 2
  then S3
else if code = 3
  then S4
else if code = 4
  then S5</code></pre>
<p>The case statement</p>
<pre><code>case n of
   0 -&gt; Stmt
   1 -&gt; Stmt
   2 -&gt; Stmt
   3 -&gt; Stmt
   4 -&gt; Stmt
   5 -&gt; Stmt
   else -&gt; Stmt // handle error</code></pre>
<p>This means: execute the statement corresponding to the value of n</p>
<p>Many programming languages have this; the syntax varies a lot but that isn’t what’s important</p>
<p>Example: numeric code specifies a command</p>
<pre><code>; The input data is an array of records, each specifying an operation
;    Command : record
;       code : Int     ; specify which operation to perform
;       i    : Int     ; index into array of lists
;       x    : Int     ; value of list element

; The meaning of a command depends on the code:
;    0  terminate the program
;    1  insert x into set[i]
;    2  delete x from set[i]
;    3  return 1 if set[i] contains x, otherwise 0
;    4  print the elements of set[i]</code></pre>
<p>Selecting the command with a case statement</p>
<pre><code>; Initialize
;    BuildHeap ()

; Execute the commands in the input data
;    finished := 0
;    while InputPtr &lt;= InputEnd &amp;&amp; not finished
;       CurrentCode := (*InputPtr).code
;       p := set[*InputPtr]     ; linked list
;       x := (*InputPtr).x      ; value to insert, delete, search

;       case CurrentCode of
;          0 : &lt;CmdTerminate&gt;
;          1 : &lt;CmdInsert&gt;
;          2 : &lt;CmdDelete&gt;
;          3 : &lt;CmdSearch&gt;
;          4 : &lt;CmdPrint&gt;
;          else : &lt;&gt;
;       InputPtr := InputPtr + sizeof(Command)
; Terminate the program
;    halt</code></pre>
<p>Finding a numeric code</p>
<ul>
<li>It’s tedious and inefficient to go through the possible values of a numeric code in sequence</li>
<li>If you’re looking up Dr Zhivago in the phone book, do you look at Arnold Aardvark, and Anne Anderson, on on and on?</li>
<li>You go straight to the end of the book</li>
<li>We want to find the statement corresponding to a numeric code directly, without checking all the other values</li>
</ul>
<p>A problem with efficiency</p>
<p>The problem</p>
<ul>
<li>There are many applications of case statements</li>
<li>They are executed frequently</li>
<li>The number of cases can be large (not just 4 or 5; can be hundreds)</li>
<li>The implementation of the if-then-else requires a separate compare and jump for each condition</li>
</ul>
<p>The solution: a technique called jump tables</p>
<p>Jump tables: the basic idea</p>
<p>For each target statement (S1, S2, S3, etc) in the conditional, introduce a jump to it: jump S1[R0], jump S2[R0], etc. Make an  ``jt’’ of these jump instructions</p>
<pre><code>   jt[0] = jump S0[R0]
   jt[1] = jump S1[R0]
   jt[2] = jump S2[R0]
   jt[3] = jump S3[R0]
   jt[4] = jump S4[R0]</code></pre>
<p>Given the , Jump to jt[code], Each element of the array is an instruction that requires two words. So jump to jt + 2 * code.</p>
<p>Jump table</p>
<pre><code>; Jump to operation specified by code
    add    R4,R4,R4            ; code := 2*code
    lea    R5,CmdJumpTable[R0] ; R5 := pointer to jump table
    add    R4,R5,R4            ; address of jump to operation
    jump   0[R4]               ; jump to jump to operation
CmdJumpTable
    jump   CmdTerminate[R0]    ; code 0: terminate the program
    jump   CmdInsert[R0]       ; code 1: insert
    jump   CmdDelete[R0]       ; code 2: delete
    jump   CmdSearch[R0]       ; code 3: search
    jump   CmdPrint[R0]        ; code 4: print

CmdDone
    load   R5,InputPtr[R0]
    lea    R6,3[R0]
    add    R5,R5,R6
    store  R5,InputPtr[R0]
    jump   CommandLoop[R0]</code></pre>
<p>We have to be careful!</p>
<p>What if code is negative, or larger than the number of cases? The jump to the jump table could go anywhere! It might not even go to an instruction. But whatever is in memory at the place it goes to, will be interpreted as an instruction that will be executed. The program will go haywire. Debugging it will be hard: the only way to catch the error is to read the code and/or to single step. Solution: before jumping into the jump table, check to see if code is invalid (too big or too small)</p>
<p>Checking whether the code is invalid</p>
<pre><code>CommandLoop
    load   R5,InputPtr[R0]     ; R1 := InputPtr
    load   R4,0[R5]            ; R4 := *InputPtr.code
; Check for invalid code    
    cmp    R4,R0               ; compare (*InputPtr).code, 0
    jumplt CmdDone[R0]         ; skip invalid code (negative)
    lea    R6,4[R0]            ; maximum valid code
    cmp    R4,R6               ; compare code with max valid code
    jumpgt CmdDone[R0]         ; skip invalid code (too large)

...
    
CmdDone
    load   R5,InputPtr[R0]
    lea    R6,3[R0]
    add    R5,R5,R6
    store  R5,InputPtr[R0]
    jump   CommandLoop[R0]</code></pre>
<h2 id="privileged-instructions">Privileged instructions</h2>
<p>What’s the significance of root?</p>
<ul>
<li>Many  are running in the computer</li>
<li>Each has its own set of privileges</li>
<li>There is one special user ``root’’ which has  privileges: </li>
<li><p>The effect of this change to the source code (a change of  is</p></li>
<li><p>If a user program calls this obscure function with just the right set of obscure options, </p></li>
<li><p>Don’t worry — </p></li>
</ul>
<h2 id="trees-1">Trees</h2>
<p>A node doesn’t have to have two fields named  and  — it’s normal to define a specific node type for an application program. Nodes with  and  can be connected into a linked list.</p>
<p>Nodes can also have with several fields containing data, not just one ``value’’ field. And a node can have several pointer fields. Common case: a  has two pointers in each node, named  and . Each of these can either contain nil, or point to another node.</p>
<pre><code>  Node : record
    value    ; the actual data in the node
    left     ; left subtree is a pointer to a Node
    right   ;  right subtree is a pointer to a Node</code></pre>
<ul>
<li>Similar to a node for a linked list, but with two pointers</li>
<li>There can also be several fields for data, not just one `value field</li>
<li>And we could have more than just two pointers</li>
</ul>
<p>A binary tree</p>
<pre><code>    root
   /   \
  /     \
 a       b
        / \
       c   d</code></pre>
<p>In computer science, for some reason we draw trees upside down, with the leaves down on the ground and the root up in the sky.</p>
<p>Suppose p is a pointer to the tree</p>
<ul>
<li>(*p).left is the pointer to the left subtree</li>
<li>(*p).right is the pointer to the right subtree</li>
</ul>
<p>Applications of trees</p>
<p>Trees are used everywhere in programming. They can hold structured data and they can often make programs run faster than with linear data structures like arrays and linked lists.</p>
<p>Holding structured data</p>
<ul>
<li>A compiler reads in program text, which is just a character string: a sequence of characters.</li>
<li>It needs to represent the deep structure underlying that sequence of characters.</li>
<li>This is done by building a tree (the part of a compiler that takes a character string and produces a tree is called the parser.</li>
</ul>
<p>Parse trees</p>
<pre><code>x := a + b * c</code></pre>
<pre><code>   :=
  x   +
     a  *
       b  c</code></pre>
<p>Another application of jump tables!</p>
<p>In some programs, trees normally have several different types of node. Examples: operations with 1 operand; operations with 2 operands; control constructs with a boolean expression and two statements, etc.</p>
<p>So there are several different kinds of record. Each record has a  in the first word. The value of the code determines how many more words there are in the record, and what they mean. When a program has a pointer to a node, it needs to examine the code and take different actions depending on what the code is. This is done with a jump table</p>
<h2 id="binary-search-trees">Binary search trees</h2>
<p>Suppose we have a large number of records (e.g. a database). We want to search the database for an entry where a field has a certain value (e.g. search for a record where the MatricNumber field is 123456). If you just have these records in an array, or a linked list, you have to search them one by one. On average, you have to look at half the entries in the database to find the one you want. If you double the size of the database, you double the average time to look up an entry. Terminology: this is called  or <span class="math inline"><em>O</em>(<em>n</em>)</span> complexity</p>
<p>You can search the database much faster using a binary search tree.</p>
<p>Consider that linear search is silly if you can place the records in order. Suppose you’re trying to find the telephone number of John Smith in the phone book. Would you do this?</p>
<ul>
<li>It isn’t Aardvark, Aaron</li>
<li>It isn’t Acton, Rebecca</li>
<li>It isn’t Anderson, Susan</li>
<li>It isn’t Atwater, James</li>
<li>… 8 million more unsuccsessful searches because this is the directory for a large city</li>
</ul>
<p>That’s silly! * Open the book to the middle, notice that S is in the second half * Open the book to the middle of the second half… * Each time you look at an entry in the book, you discard half of the remaining possibilities</p>
<p>Example of a Binary search tree</p>
<pre><code>  \node {31}
  child {node {7}
    child {node {5}}
    child {node {9}}}
  child {node {56}
    child {node {41}}
    child {node {78}}};</code></pre>
<p>At every level: if a node contains x, then</p>
<ul>
<li>Every node in the left subtree is less than x, and</li>
<li>Every node in the right subtree is greater than x.</li>
<li>You can search the tree by starting at the root, and at every step you can easily determine whether to go left or right</li>
</ul>
<p>Algorithmic Complexity</p>
<ul>
<li>Complexity is concerned with </li>
<li>This is expressed as a function of the input size <span class="math inline"><em>n</em></span></li>
<li><p>Normally we don’t care about the  function, and we use O-notation. Instead of a funciton like <span class="math inline"><em>f</em>(<em>n</em>) = 4.823 × <em>n</em></span>, we just write <span class="math inline"><em>f</em>(<em>n</em>) = <em>O</em>(<em>n</em>)</span></p></li>
<li>O(1) — if input grows, the execution time remains unchanged. This is unrealistic: the program cannot even look at the input!</li>
<li>O(n) — if the input is 5 times bigger, the execution time is 5 times bigger. This is the best you can hope for</li>
<li><p>O(n^2) — if the input is 5 times bigger, the time is 25 times bigger</p></li>
</ul>
<p>Finding a good algorithm is more important than small optimisations in the code. Some programmers spend lots of effort trying to save one or two instructions in a piece of a program. But it doesn’t matter much whether a program takes 2.00032 seconds or 2.00031 seconds. It’s much more important to use a suitable . On small data it doesn’t make much differnce, but on large (realistic) data, a better algorithm makes a huge difference</p>
<h3 id="complexity-of-search">Complexity of search</h3>
<p>Ordered lists</p>
<ul>
<li>The Ordered Lists program has an operation to search a list for a value x</li>
<li>On average, you need to look through half of the data to find out whether x is present</li>
<li>If the list were  ordered, you would need to look through  of the data to determine whether x is present</li>
<li>So the ordered list makes the search about twice as fast</li>
<li>But in either case, this is <span class="math inline"><em>O</em>(<em>n</em>)</span> — if you double the data size, the average time is doubled</li>
</ul>
<p>In a binary search tree, the number of comparisons needed is roughly the height of the tree. If the tree is balanced, the time complexity is O(n)</p>
<h3 id="how-much-faster">How much faster?</h3>
<p>With a linear data structure (array, linked list)</p>
<ul>
<li>Each time you compare a database entry with your key, you eliminate one possibility</li>
<li>The time is proportional to the size of the database</li>
<li>It’s called  — time = <span class="math inline"><em>O</em>(<em>n</em>)</span></li>
<li></li>
</ul>
<p>With a binary search tree</p>
<ul>
<li>Each time you compare a database entry with your key, you eliminate (on average) half of the possibilities</li>
<li>The time is proportional to  of the database</li>
<li>It’s called  — time = O(n).</li>
<li>For 2 million records, you need 21 comparisons.</li>
</ul>
<p>There’s a saying: <em>logs come from trees</em>.</p>
<p>A common pitfall: When you’re writing a program, it’s natural to test it with small data. Even if the algorithm has bad complexity, the testing may be fast But then, when you run the program on real data, the execution time is intolerable That means going back and starting over again So it’s a good idea to be aware of the complexity of your algorithm from the beginning</p>
<h3 id="how-bad-can-complexity-be">How bad can complexity be?</h3>
<p>Order of magnitude estimate of time for input of size <span class="math inline"><em>n</em></span></p>

<p>Lots of real problems have data size larger than 1,000. Lots of algorithms have exponential complexity: <span class="math inline">2<sup><em>n</em></sup></span>.</p>
<h2 id="interrupts">Interrupts</h2>
<p>Another kind of control is <em>losing</em> control! Control constructs built on goto and if-then-goto let the program decide what to do next. Sometimes we want something else — not the program — to decide what to do next.</p>
<ul>
<li>The hardware provides  which are used to implement processes</li>
<li>An interrupt is an </li>
<li>It goes either to the operating system or to an error handler</li>
<li>But it is not the result of a jump instruction — it happens automatically when an external event occurs</li>
<li>The program that was running never jumped to the OS - the processor just stops executing its instructions, and starts executing the OS instead</li>
<li>It’s like talking to a group of people, and suddenly you get interrupted!</li>
</ul>
<p>Several kinds of event can cause an interrupt. These include</p>
<ul>
<li>An error in a user program: e.g. overflow (result of arithmetic is too large to fit in a registers)</li>
<li>A trap: this is an explicit jump to the operating system, but the program doesn’t specify the address</li>
<li>An external event: a disk drive needs attention , or the timer goes off</li>
</ul>
<p>How interrupts are implemented</p>
<p>The computer is a digital circuit. Without interrupts, it repeats forever:</p>
<ul>
<li>Fetch the instruction at the address in the pc register</li>
<li>Execute the instruction</li>
</ul>
<p>With interrupts, it repeats this forever:</p>
<ul>
<li>Check to see if there is an interrupt request</li>
<li>If there is, savepc := pc, pc := address of code in operating system</li>
<li>Fetch the instruction at the address in the pc register</li>
<li>Execute the instruction</li>
</ul>
<p>Since the pc has been modified, the next instruction will not be part of the program that was interrupted — it will be the operating system.</p>
<p>Saving state</p>
<p>An interrupt is a jump to the OS. This requires setting the address of OS in the pc register. But if we simply assign a value to pc, the computer has forgotten where the interrupted program was. Therefore the hardware must ``save state’’: savepc := pc. The OS has a special instruction that enables it to get the value of savepc</p>
<p>How interrupts are used</p>
<ul>
<li>Interrupts can be used to  in a program, e.g. arithmetic overflow (the result is too big to fit in a register)</li>
<li>If an overflow occurs (or divide by zero, or some other error) we want the program to jump to an error handler</li>
<li>Trap is similar to an interrupt, and is used to  from the operating system</li>
<li>User program can’t halt the machine, but uses trap to ask the OS to stop running the program</li>
<li>They can be used to provide  to an Input/Output device</li>
<li>A disk drive may generate an interrupt when the spinning platter reaches a certain point, and it needs service right away — within a tight deadline</li>
<li>Interrupts are used to implement </li>
<li>The operating system gives each process a  in round-robin order, so each process makes progress</li>
</ul>
<p>Interrupts and programming languages</p>
<ul>
<li>Most programming languages don’t provide the ability to work directly with interrupts</li>
<li>But many programming language provide </li>
<li>Without an exception handler, a division by 0 might terminate the program</li>
<li>In the program, you can set an exception handler: a procedure to execute if a division by 0 occurs</li>
<li>The compiler might implement this in several different ways:</li>
<li>It could put in explicit comparison and conditional jumps to check each division</li>
<li>Or it could set up an interrupt handler (this requires negotiation with the operating system)</li>
</ul>
<p>Using interrupts to catch errors</p>
<p>As a program runs, it may accidentally produce an error</p>
<ul>
<li>An arithmetic instruction produces a result that’s too large to fit in a register: this is called </li>
<li>A divide instruction attempted to divide by 0</li>
</ul>
<p>It’s better to detect the error and do something about it, than just to proceed with incorrect results. This makes software robust. If the program just keeps going, it’s likely to produce wrong results. Two approaches for catching errors (use one or the other): Explicit error checking, and Interrupts</p>
<p>Explicit error checking</p>
<ul>
<li>Most computers have a  with a bit indicating each kind of error</li>
<li>Sigma16 uses R15, and a bit in R15 indicates whether overflow occurred</li>
<li>Every time you do an add (or other arithmetic instruction), that bit is set to 0 if it was ok, and 1 if there was overflow</li>
<li>You can check for this with a conditional jump, and then take appropriate action</li>
<li>Of course, you have to decide what the appropriate action is!</li>
</ul>
<pre><code>   add      R2,R5,R4     ; x := a + b
   jumpovfl TooBig[R0]   ; if overflow then goto TooBig</code></pre>
<p>Problems with explicit error checking</p>
<ul>
<li>You have to put in the jumpovfl </li>
<li>This makes the program considerably longer</li>
<li>It’s also inefficient: those conditional jumps take time</li>
<li>It is ``fragile’’: if you forget the jumpovfl  in a big program, that program can malfunction</li>
</ul>
<p>A better approach: interrupts!</p>
<ul>
<li>Most computers (including Sigma16) can also perform an interrupt if an overflow (or other error) occurs</li>
<li>The digital circuit checks for overflow (or other error) after every arithmetic operation</li>
<li>If the error occurred, the circuit performs an interrupt</li>
<li>The OS then decides what to do</li>
<li>User program can tell the OS in advance “in case of overflow, don’t kill me, but jump to this address: TooBig”</li>
<li>There is a special trap code for making this request</li>
<li>In some programming languages, this is called setting an exception handler or catching exceptions</li>
<li>There is a special control register with a bit that specifies whether overflow should trigger an interrupt</li>
</ul>
<p>Why are interrupts better than explicit checking?</p>
<ul>
<li>Interrupts guarantee that  operation is checked</li>
<li>It is faster: the circuit can do this checking with essentially zero overhead</li>
<li>It is easier: the programmer doesn’t have to worry about it</li>
<li>The program is shorter: don’t need a jump after every arithmetic instruction</li>
</ul>
<h3 id="concurrent-processes">Concurrent processes</h3>
<ul>
<li><p>One of the central features provided by an operating system is </p></li>
<li>A process is a running program</li>
<li>Think of a program as a document: it’s just sitting there</li>
<li>A process is all the action that happens when a program is executed: it has its variables, the variables change over time, Input/Output happens, <span class="math inline">…</span></li>
<li>Several different processes may be running on the same program (e.g. multiple tabs on a web browser)</li>
<li><p>Each process has its own variables</p></li>
<li>Processes are implemented using interrupts</li>
<li>The idea: the OS gives a user program a </li>
<li><p>The user is interrupted, and the OS can then run a different program</p></li>
</ul>
<p>Waiting for I/O = wasted time</p>
<ul>
<li>Motivation for processes comes from I/O</li>
<li><p>The problem:</p></li>
<li>Instructions execute quickly — typically about 0.3ns (about <span class="math inline">3 × 10<sup>9</sup></span> per second)</li>
<li>Input/output is much slower, especially if mechanical devices are involved</li>
<li>An I/O operation runs slower than an instruction by a factor ranging from <span class="math inline">10<sup>4</sup></span> to <span class="math inline">10<sup>8</sup></span></li>
<li><p>For comparison, a supersonic jet fighter is only <span class="math inline">10<sup>3</sup></span> times faster than a turtle.</p></li>
<li><p>If a program does  <span class="math inline">⋯</span>  <span class="math inline">⋯</span>  <span class="math inline">⋯</span> it is likely to spend a lot of time waiting for the I/O</p></li>
</ul>
<p>A process must sometimes wait</p>
<p>Don’t wait — switch to another process</p>
<ul>
<li><p>When a program needs to perform I/O, it</p></li>
<li>Requests the operating system to do the I/O</li>
<li>The OS  the I/O but doesn’t wait for it to finish</li>
<li>The OS then allows a  to run for a while</li>
<li><p>Eventually, when the I/O operation finishes, the OS allows the original program to resume</p></li>
<li>This leads to an operating system running a large number of separate programs</li>
<li><p>Each running program is called a </p></li>
</ul>
<p>Concurrent processes</p>
<ul>
<li>A  is a running program</li>
<li>At an instant of time, the computer is physically executing just one instruction (which belongs to one process)</li>
<li>From time to time (around 100 or more times per second), the system will transfer control from one process to another one — this is called a </li>
</ul>
<p>Time scale:</p>
<ul>
<li>At the scale of a nanosecond (<span class="math inline">10<sup> − 9</sup></span> second) the computer ` is executing just one instruction belonging to a process; all other processes are doing nothing</li>
<li>At the scale of human perception (<span class="math inline">10<sup> − 2</sup></span> second) it appears that  the processes are making smooth processes</li>
<li>A motion picture is just a sequence of still photographs but displaying them rapidly gives the impression of continuous motion</li>
</ul>
<p>Operating system kernel</p>
<ul>
<li>A process does not transfer control to another process</li>
<li>How could it? When you write a program, you don’t know what other programs will be running when this one is!</li>
<li><p>A process break means</p></li>
<li>Running process jumps to the operating system kernel</li>
<li>The kernel is the innermost, core, central part of the OS</li>
<li>The kernel has a table of all the processes</li>
<li>(On Windows: right-click the toolbar, launch the Task Manager, click Processes tab)</li>
<li><p>The kernel chooses another process to run and jumps to it</p></li>
</ul>
<p>Events that can trigger an interrupt</p>
<ul>
<li>There is a timer that ``bings’’ periodically — each time it goes off it generates an interrupt</li>
<li>When an Input/Output device has competed a read or write, it generates an interrupt</li>
</ul>
<p>Preemptive scheduling</p>
<ul>
<li>When the operating system jumps to a user process, it sets a  which will ``go off’’ after a set amount of time (e.g. 1ms — <span class="math inline">10<sup> − 3</sup></span> second)</li>
<li>When does a running process jump to the operating system?</li>
<li>When the timer goes off</li>
<li>When the process makes an I/O request</li>
<li>This guarantees that the process won’t run forever and  even if it goes into an infinite loop</li>
</ul>
<p>The Scheduler</p>
<ul>
<li>The core of an operating system is the scheduler</li>
<li>It maintains a list of all the processes</li>
<li>When an interrupt occurs:</li>
<li>The process that was running stops executing instructions: it has been interrupted</li>
<li>The OS takes any necessary action (e.g. service the I/O device)</li>
<li>Then the OS jumps to the scheduler</li>
<li>The scheduler chooses a different process to run</li>
<li>It sets the timer and jumps to that process</li>
</ul>
<p>Mouse</p>
<p>The mouse isn’t connected to the cursor on the screen! When you move the mouse, it generates an interrupt The OS reads the mouse movement Then it calculates where the cursor should be and redraws it This happens many times per second, giving the illusion of mooth movement</p>
<h3 id="how-interrupts-are-implemented">How interrupts are implemented</h3>
<ul>
<li>Interrupts cannot be implemented in software!</li>
<li>The processor (the CPU) repeatedly goes through a sequence of steps to execute instructions</li>
<li>This is the  and it’s performed by a digital circuit in the processor (the )</li>
<li>Interrupts are implemented by the control circuit</li>
</ul>
<p>Control</p>
<p>the control registers: pc, ir, adr are used to keep track of what the processor is doing.</p>
<p>The Control Algorithm</p>
<ul>
<li>The behaviour of the entire processor is defined by a </li>
<li><p>We can describe this using a special notation (which looks like a simple programming language, but it is not a program)</p></li>
<li>Notations</li>
<li><p>The control algorithm</p></li>
<li><p>We can implement the control algorithm using flip flops and logic gates</p></li>
</ul>
<h3 id="registers">Registers</h3>
<ul>
<li>pc (program counter) contains address of the next instruction</li>
<li>ir (instruction register) contains the current instruction (or first word of an RX instruction)</li>
<li>adr (address register) holds the effective address for RX instructions</li>
<li>reg[a] (register file) contains 16 registers for use by user program</li>
</ul>
<p>Notation</p>
<ul>
<li>pc, ir, adr — contents of these 16-bit registers</li>
<li>ir_op,ir_d, ir_a, ir_d — 4-bit fields in the ir</li>
<li>reg[x] — the register in the register file with address x</li>
<li>mem[x] — the memory location with address x</li>
</ul>
<h3 id="infinite-loop">Infinite loop</h3>
<ul>
<li>In hardware, we  infinite loops</li>
<li>The computer should never stop executing instructions!</li>
</ul>
<pre><code>repeat forever
  action
  action
  ...
  action</code></pre>
<h3 id="case-dispatch">Case dispatch</h3>
<ul>
<li>We often have an  — a binary number, with <span class="math inline"><em>k</em></span> bits (e.g. 4 bits)</li>
<li>There are <span class="math inline">2<sup><em>k</em></sup></span> alternative actions to take, depending on the value of the code</li>
</ul>
<pre><code>case opcode
  0: action
  1: action
  ...
  15: action</code></pre>
<h3 id="control-algorithm">Control algorithm</h3>
<pre><code>repeat forever
  if interrupt_request
    then savepc := pc
         pc := 0  ; address of interrupt handler in OS
    else ir := mem[pc],  pc := pc + 1            ; fetch instruction
         case ir_op
         0: reg[ir_d] := reg[ir_a] + reg[ir_b]   ; add
         1: reg[ir_d] := reg[ir_a] - reg[ir_b]   ; sub
         2: reg[ir_d] := reg[ir_a] * reg[ir_b]   ; mul
         ... more RRR instructions are similar
         ...
         15: adr := mem[pc], pc := pc + 1        ; displacement
             adr := adr + reg[ir_a]              ; effective address
             case ir_b
               0: reg[ir_d] := adr               ; lea
               1: reg[ir_d] := mem[adr]          ; load
               2: mem[adr] := reg[ir_d]          ; store
               3: pc := adr                      ; jump
               ... more RX instructions are similar
               ...</code></pre>
<h2 id="languages-and-systems">Languages and systems</h2>
<h3 id="advice-on-software-engineering">Advice on software engineering</h3>
<p>What should a software engineer study if they want to learn how to write efficient code?</p>
<p>Hyde, R. (2009). The Fallacy of Premature Optimization. , Association for Computing Machinery, February 2009. </p>
<h3 id="what-should-a-software-engineer-study">What should a software engineer study?</h3>
<p>Hyde says (quotation):</p>
<ul>
<li><p>The first subject to master is . Because all real programs execute on real machines, you need to understand how real machines operate if you want to write efficient code for those machines.</p></li>
<li><p>The second subject to study is . Though few programmers use assembly language for application development, assembly language knowledge is critical if you want to make the connection between a high-level language and the low-level CPU. <span class="math inline">…</span> It doesn’t really matter which assembly language you learn nor does it matter which CPU’s instruction set you study. What you really need to learn are the basic operational costs of computation.</p></li>
<li><p>The third important subject a software engineer should study is basic compiler construction, to learn .</p></li>
</ul>
<h3 id="low-level-list-manipulation">Low level list manipulation</h3>
<ul>
<li>You can assign pointers: if a is a list, b = a makes b point to the same node a points to</li>
</ul>
<pre><code>; b = a,   where a is a list
   load   R1,a[R0]    ; R1 = a
   store  R1,b[R0]    ; b := a</code></pre>
<ul>
<li>You can write expressions that create a new list, but don’t modify any existing lists: 
<ul>
<li><p>You can modify an existing list structure</p></li>
<li>a.copy()</li>
<li>a.append(b)</li>
<li><p>a.extend(b)</p></li>
<li><p>All of these are implemented with while loops that traverse a</p></li>
</ul></li>
</ul>
<h3 id="b-a.copy">b = a.copy()</h3>
<p>Traverse a and make a new node for each node in a; link the new nodes together to form the result. The nodes in b have the same values as the nodes in a, but they are distinct nodes</p>
<pre><code>   p := a
   b := nil
   while p /= nil do
       nn := newnode()
       *nn.value := *p.value
       *nn.next := nil
       *b.next := nn
       p := *p.next</code></pre>
<p>(It’s a little more complicated, you have to remember the beginning of b — using a header node is helpful.) Now if you modify one of the lists (a, b) the other list is not affected</p>
<h4 id="for-loops">for loops</h4>
<h3 id="for-loops-in-algol-and-descendants">for loops in Algol and descendants</h3>
<pre><code>sum := 0
for i := 0 to n-1 do sum := sum+i
print (sum)</code></pre>
<p>The translation needs 4 machine language instructions for the loop control</p>
<pre><code>           sum := 0
           i := 0
avacodo    if i&gt;= n then goto avacododone
           S
           i := i + 1
           goto avacado
avacododone
           print (sum)</code></pre>
<h3 id="write-programs-at-a-high-level">Write programs at a high level</h3>
<p>Every rule has some rare exceptions, but almost always these are good principles:</p>
<ul>
<li>Write conditionals using if-then or if-then-else</li>
<li><p>Write loops using the most appropriate construct</p></li>
<li>Often, a while loop is best</li>
<li><p>To traverse an array, a for loop is best</p></li>
<li>Avoid goto statements (and if your language has break statements, avoid those)</li>
<li><p>Use a straightforward style that’s easy to read</p></li>
</ul>
<p></p>
<h3 id="use-patterns-to-translate-to-low-level">Use patterns to translate to low level</h3>
<ul>
<li><p>Low level algorithm contains just</p>
<ul>
<li>Assignment statements</li>
<li>goto label</li>
<li>if b then goto label</li>
</ul></li>
<li><p>Each high level construct is translated to low level using a fixed pattern</p></li>
</ul>
<p></p>
<h3 id="translate-low-level-to-assembly-language">Translate low level to assembly language</h3>
<ul>
<li><p>Each low level statement should be a full line comment, followed by the instructions needed to implement that statement</p>
<ul>
<li> <span class="math inline"> ⇒ </span>\</li>
</ul>
<pre><code>; x := y + z
 load    R1,y[R0]    ; R1 := y
 load    R2,z[R0]    ; R2 := z
 add     R1,R1,R2    ; R1 := y + z
 store   R1,x[R0]    ; x := y + z</code></pre>
<ul>
<li> <span class="math inline"> ⇒ </span>\</li>
</ul>
<pre><code>; goto phase2
 jump    phase2[R0]  ; goto phase2</code></pre>
<ul>
<li> <span class="math inline"> ⇒ </span></li>
</ul>
<pre><code>; if x&lt;y then goto phase3
 load    R1,x[R0]    ; R1 := x
 load    R2,y[R0]    ; R2 := y
 cmp     R1,R2       ; compare x, y
 jumpge  phase3[R0]  ; if x&lt;y then goto phase3</code></pre></li>
</ul>
<h3 id="practical-programming-tip">Practical programming tip</h3>

<h3 id="example-writevalchar">Example: WriteValChar</h3>
<h3 id="a-simple-procedure-writevalchar">A simple procedure: WriteValChar</h3>
<ul>
<li>The procedure takes an argument—a character—and prints it.</li>
<li>To use the procedure: Load a character into R1</li>
<li>This is a word, and it should be a valid printing Unicode character</li>
<li>Call the WriteValChar procedure, and it will print this character</li>
</ul>
<h3 id="calling-writevalchar">Calling WriteValChar</h3>
<ul>
<li>Suppose R5 contains p, a pointer to a node</li>
<li>We want to print the value in that node</li>
<li>We are in a procedure where the stack frame has size 1 (the main program)</li>
</ul>
<pre><code>   load   R1,0[R5]              ; R1 := (*p).value (to be written)
   store  R14,1[R14]            ; point to current frame
   lea    R14,1[R14]            ; push stack frame
   jal    R13,WriteValChar[R0]  ; write character</code></pre>
<ul>
<li>If the call is made from a procedure with 23 words in the stack frame, then the store and lea instructions would use 23[R14]</li>
</ul>
<h3 id="definition-of-writevalchar-1">Definition of WriteValChar (1)</h3>
<pre><code>WriteValChar
; Write a character in R1
; Structure of stack frame
;    6[R14]  origin of next frame
;    5[R14]  local variable c
;    4[R14]  save R3
;    3[R14]  save R2
;    2[R14]  save R1
;    1[R14]  return address
;    0[R14]  pointer to previous stack frame

; Create stack frame
    store   R13,1[R14]           ; save return address
    store   R1,2[R14]            ; save R1
    store   R2,3[R14]            ; save R2
    store   R3,4[R14]            ; save R3</code></pre>
<p>}</p>
<h3 id="definition-of-writevalchar-2">Definition of WriteValChar (2)</h3>
<pre><code>    store   R1,5[R14]        ; local c := R1 = char to write
    lea     R1,2[R0]         ; trap write code
    lea     R2,5[R14]        ; address of character to write
    lea     R3,1[R0]         ; one char
    trap    R1,R2,R3         ; trap write

    load    R1,2[R14]        ; restore R1
    load    R2,3[R14]        ; restore R2
    load    R3,4[R14]        ; restore R3
    load    R13,1[R14]       ; restore return address
    load    R14,0[R14]       ; pop stack frame
    jump    0[R13]           ; return</code></pre>
<p>}</p>
<h3 id="static-variables-in-a-data-segment">Static variables in a data segment</h3>
<ul>
<li>The variables are not placed in memory right after the instructions</li>
<li>The program makes a request to the operating system to allocate a block of memory for data (the static data segment)</li>
<li>A register is dedicated to point to the static data segment</li>
<li>Variables are accessed using the static data segment register</li>
</ul>
<h3 id="implementing-static-data-segment">Implementing static data segment</h3>
<pre><code>     ... set up registers to request a
          data block of n words...

     trap  R1,R2,R3
     ... R3 is set to the address of the data block
     add   R12,R0,R3    ; R12 = address of static data segment

   ...
     load  R2,n[R12]    ; R2 := n (access static variable)

     segment            ; subsequent labels will access segment
n    data
x    data</code></pre>
<p>}</p>
<h3 id="practical-tip---editing">Practical tip - editing</h3>
<ul>
<li>Recommend that you use Notepad to edit program; copy and paste it into Sigma16 editor pane</li>
<li>The assembly language program should contain ASCII characters (the characters on your keyboard)</li>
<li>Don’t edit your program using Word (it will use lots of non-ASCII characters)</li>
<li>If you click Run to run a program at full speed, you need to click Refresh (otherwise the memory display won’t be correct). Remember: Run, then Refresh.</li>
<li>But it’s recommended that you execute the program by clicking Step repeatedly, and each instruction check that it did what you intend.</li>
</ul>
<h2 id="linking">Linking}</h2>
<h3 id="subroutines">Subroutines</h3>
<p>There are many programming language variations</p>
<ul>
<li>Reentrant code</li>
<li>Recursion</li>
<li>Coroutines</li>
</ul>
<p>Architecture support</p>
<ul>
<li>Ability to jump to a location and save return address</li>
<li>Ability to save all the state of caller</li>
<li>Support for efficient stack access</li>
</ul>
<h3 id="calling-conventions">Calling conventions</h3>
<ul>
<li>Software comes from many authors, written in many languages</li>
<li>To be able to work, standard calling conventions are needed</li>
<li>These are specified by the OS, and used by OS libraries</li>
</ul>
<h3 id="linking-1">Linking</h3>
<ul>
<li>Large programs are written in many modules, compiled separately</li>
<li>They need to communicate via : names of subroutines, names of global variables.</li>
<li>Compiling a source module (in any language) produces an object module (in a fixed notation specified by OS)</li>
<li>Object module contains machine code, definitions of exported global names, and relocation information</li>
<li> (part of OS) combines multiple object modules, replaces global names by their values, and (maybe) relocates code</li>
</ul>
<h3 id="interrupts-an-unrequested-jump">Interrupts — an unrequested jump</h3>
<ul>
<li>A jump (to the operating system) initiated by an event other than a jump instruction</li>
<li>Provide a mechanism for a program to request OS services</li>
<li>Prevent user program from executing prohibited instructions</li>
<li>Foundation for implementation by OS of concurrent processes and threads</li>
</ul>
<h3 id="implementing-interrupts">Implementing interrupts</h3>
<ul>
<li>The control algorithm implements interrupts</li>
<li><p>At the beginning of the instruction fetch/execute loop, the control checks the interrupt request (an input to the processor)</p></li>
<li>If 0 (no interrupt request) the control algorithm executes the next instruction normally</li>
<li><p>If 1, the control algorithm saves the PC and updates the PC with the address of the interrupt handler. The next instruction to execute will then be the beginning of the interrupt handler.</p></li>
</ul>
<h3 id="basic-interrupt-control">Basic interrupt control</h3>
<p>Control algorithm without interrupts:</p>
<pre><code>repeat forever
   ir := mem[pc], pc++;
   case ir_op of
     0 -&gt; -- add instruction
     ...</code></pre>
<p>}</p>
<p>With interrupt_request signal</p>
<pre><code>repeat forever
   case interrupt_request of
     1 -&gt;
       savepc := pc, pc := handler_address
     0 -&gt; -- normal instruction execution follows...
        ir := mem[pc], pc++;
        case ir_op of
           0 -&gt; -- add instruction
     ...</code></pre>
<p>}</p>
<h3 id="saving-the-pc">Saving the PC</h3>
<ul>
<li>A principle of interrupts is that </li>
<li>The essence of an interrupt is to assign a new value to the PC</li>
<li>Therefore the PC must be saved before its old value is destroyed</li>
<li>The hardware has to do this! It is absolutely impossible to do it in software</li>
</ul>
<h3 id="where-to-save-the-pc">Where to save the PC?</h3>
<p>There are several possibilities, many of which have been tried in real computers</p>
<ul>
<li>Have a special register whose sole purpose is to save the PC during an interrupt. The interrupt handler needs to copy that register someplace more permanent before another interrupt can occur!</li>
<li>Store the PC into memory, at a fixed address. Again, the interrupt handler would need to copy it to a permanent place before another interrupt.</li>
<li>Push the PC into a stack in memory. This requires either a fixed location for the stack, or a register pointing to the stack. What happens if there is a stack overflow?</li>
</ul>
<h3 id="saving-state-1">Saving state</h3>
<ul>
<li>All the registers that hold state belonging to the user program need to be saved.</li>
<li><p>Two approaches to this:</p></li>
<li>Require the interrupt handler to do it (i.e. use software instructions to save the state). Flexible, requires instructions that can access all of the state.</li>
<li><p>Save all state in the control algorithm (OS doesn’t need to do it). Simple, reliable.</p></li>
</ul>
<h3 id="disabling-interrupts">Disabling interrupts</h3>
<ul>
<li>If any state-saving is done by software, the interrupt handler is  for a number of clock cycles while it is executing the instructions to save state.</li>
<li>If another interrupt occurs while the handler is vulnerable, the state of the first interrupted process will be lost. At best the process has been destroyed; if the process is an OS service, the entire system may crash.</li>
<li>To prevent this, interrupts are  while the handler is vulnerable.</li>
<li>The datapath contains a flip flop , which is normally 0.</li>
<li>The control algorithm performs an interrupt if </li>
<li>When an interrupt occurs, the control sets enable to 0</li>
<li>There is an instruction that sets enable to 1</li>
</ul>
<h3 id="missing-interrupts">Missing interrupts</h3>
<ul>
<li>If a new interrupt request is made while interrupts are disabled, the interrupt simply has to wait</li>
<li><p>Some external events are  — there is an absolute deadline by which they must be processed</p></li>
<li>In some systems, a disk generates an interrupt request when the data is about to pass under the read head. If an interrupt is delayed too long, the disk must rotate fully before the data can be accessed</li>
<li><p>The time of day clock is implemented by counting timer interrupts; if one of these is missed, the clock will run slow</p></li>
<li>It is the responsibility of the interrupt handler (OS) to save state quickly and enable interrupts</li>
<li><p>Some operating systems (e.g. Linux) organise interrupt handlers in two parts</p></li>
<li>A short part that saves state, and saves an indication in memory of what work needs to be done</li>
<li><p>A longer part that does the actual work, but this can be delayed until other interrupts are processed</p></li>
</ul>
<h2 id="data-types">Data types</h2>
<ul>
<li>A word of memory contains a string of bits</li>
<li>The hardware has no idea what data type this string of bits has</li>
<li>If you execute an instruction that treats the bits as an integer, then it’s an integer </li>
<li>The same holds for all other data types</li>
<li>If the machine executes a word (i.e. the pc register points to that word), it will be interpreted as an instruction</li>
<li>It is the responsibility of the programmer to use each word consistently</li>
<li>Programming languages and compilers help by associating a  with every data value</li>
<li>A common error: accidentally executing a variable (e.g. jumping into the area of memory where your variables reside)</li>
</ul>
<h3 id="many-kinds-of-procedure">Many kinds of procedure</h3>
<ul>
<li><p>Many related programming constructs:</p>
<ul>
<li>Procedures</li>
<li>Subroutines</li>
<li>Functions</li>
<li>Coroutines</li>
<li>Methods</li>
</ul></li>
<li>They are , perform some computation, and  to the caller.</li>
<li><p>Many variations: how parameters are passed, how variables are allocated, whether there are restrictions on usage</p></li>
</ul>
<h3 id="about-those-jumps-call-and-return">About those jumps (call and return)</h3>
<ul>
<li><p>There is a minor issue that often isn’t worth worrying about:</p>
<ul>
<li>It costs an extra jump to call, and an extra jump to return</li>
<li>These jumps take a (very small) amount of execution time</li>
</ul></li>
<li>If a procedure is very small, it may be worthwhile plug in in its code wherever it’s called — this is a compiler optimisation called </li>
<li><p>But usually the space you save by having just one copy of the procedure’s instructions in memory is more important than the time required for the call and return</p></li>
</ul>
<h3 id="characters">Characters</h3>
<ul>
<li>‘a’, ‘b’, and so on</li>
<li>Some computers represent characters using ASCII — an 8-bit code for each character</li>
<li><p>Sigma16 uses Unicode</p></li>
<li>Each character has a 16-bit code</li>
<li>Each possible 16-bit word corresponds to some character</li>
<li><p>Lots of characters are available: "u  "o <span class="math inline"><em>α</em></span></p></li>
<li><p>There are tables giving the codes for all the characters</p></li>
</ul>
<h3 id="calling-conventions-1">Calling conventions</h3>
<ul>
<li>The machine architecture doesn’t force any particular way to pass arguments to a function, or to pass the result back to the caller</li>
<li>The program just has to do this in a consistent way</li>
<li>It’s good practice to establish  — standard ways for functions and procedures to operate</li>
</ul>
<h3 id="programming-tips-1">Programming tips</h3>
<h3 id="how-to-program-efficiently">How to program efficiently</h3>
<p>If you don’t want to spend forever getting your program working, but prefer to go out for a pizza with your friends, here’s how:</p>

<h3 id="how-to-waste-time">How to waste time</h3>
<p>If you want to drag out a program, so it takes a  to get it working:</p>

<p>A tip! Write the comments before the code!</p>
<h2 id="using-the-instruction-set">Using the instruction set</h2>
<ul>
<li>You need to know what each instruction does, and how to use it</li>
<li>A table of the instruction set helps to get an overview</li>
</ul>
<h3 id="part-of-the-instruction-set">Part of the instruction set</h3>
<p>Soon we will see some changes in this table, as well as some new instructions.</p>
<pre><code>load   R1,x[R0]     ; R1 := x
lea    R1,123[R0]   ; R1 := 123
store  R1,x[R0]     ; x := R1
jumpf  R1,x[R0]     ; if R1=0 then goto x
jumpt  R1,x[R0]     ; if R1/=0 then goto x

add    R1,R2,R3     ; R1 := R2+R3
sub    R1,R2,R3     ; R1 := R2-R3
mul    R1,R2,R3     ; R1 := R2*R3
cmplt  R1,R2,R3     ; R1 := R2&lt;R3
cmpeq  R1,R2,R3     ; R1 := R2=R3
cmpgt  R1,R2,R3     ; R1 := R2&gt;R3</code></pre>
<h3 id="closed-source-open-source-free">Closed source, open source, free</h3>
<ul>
<li> — the software is proprietary, the company doesn’t publish it (you can get the machine language code but not the high level language code)</li>
<li> — the source code is published, although the owner has control</li>
<li> — You can make a copy of the code and modify it</li>
<li><p>Much controversy!</p></li>
<li>One view: a large company can ensure high quality, and needs to ensure it gets paid for its work</li>
<li><p>Another view: ``with many eyes studying code, every bug is visible’’ — open source and free software can be more reliable</p></li>
</ul>
<h2 id="operating-systems">Operating Systems</h2>
<ul>
<li>An operating system provides </li>
<li><p>An OS is organised in layers, like an onion</p></li>
<li>Kernel: essential services without which no program can execute (e.g. calling conventions, memory protection, processes)</li>
<li>Intermediate level: networking (e.g. TCP/IP)</li>
<li><p>Higher level: optional services for convenience (e.g. graphical user interfaces, browsers, media players)</p></li>
</ul>
<h3 id="essential-services">Essential services</h3>
<ul>
<li><p>Procedures</p>
<ul>
<li>Standard rules for which register to use as , which register to use for </li>
<li>These conventions are sometimes defined by the Operating System, sometimes by the compiler</li>
</ul></li>
<li><p>Preparing and starting programs</p></li>
<li> separate modules into an executable program</li>
<li><p> a program</p></li>
<li><p>Services for a running program</p></li>
<li>Input/Output and memory allocation</li>
<li>Concurrency</li>
<li><p>Virtual memory</p></li>
</ul>
<h3 id="requests-to-the-os">Requests to the OS</h3>
<ul>
<li>Many operations cannot be performed directly by a user program.</li>
<li>The program requests the operating system to perform them</li>
<li>An OS request is performed by executing a  instruction, such as </li>
<li>The  is a number, placed in R1, and  (if any) are in R2, R3</li>
<li>The specific codes used to make a request are defined by the operating system, not by the hardware</li>
<li>This is a major reason why compiled programs run only on one operating system</li>
</ul>
<h3 id="the-trap-instruction">The trap instruction</h3>
<ul>
<li>trap R1,R2,R3</li>
<li>It doesn’t matter which registers you use; all that matters is the content of the first, second, and third operand</li>
<li>R1 contains a code indicating which request</li>
<li>R2, R3 contain additional information depending on the type of request</li>
</ul>
<h3 id="trap-is-like-jump-but-different">trap is like jump, but different</h3>
<ul>
<li> causes the machine to jump to the operating system, so it’s similar to </li>
<li>The OS has a way to jump back to the user program later, so trap is analogous to </li>
<li><p>But trap is different from jump/jal:</p></li>
<li>A trap does not specify the address to jump to: this is defined by the hardware</li>
<li><p>A trap also sets the computer into ; this is needed for system security (we’ll discuss it later)</p></li>
</ul>
<h3 id="typical-os-requests">Typical OS requests</h3>
<ul>
<li>Terminate execution of the program</li>
<li>Read from a file</li>
<li>Write to a file</li>
<li>Allocate a block of memory</li>
</ul>
<h3 id="memory-allocation">Memory allocation</h3>
<ul>
<li>The operating system maintains a map of the entire memory, organised as a set of blocks</li>
<li>A running program often needs to allocate a block of memory dynamically</li>
<li>When a program requests memory, it asks for a  of block that it needs, and the operating system returns with the  of a block</li>
</ul>
<h3 id="adding-a-character-to-a-string">Adding a character to a string</h3>
<ul>
<li>Use a variable <span class="math inline"><em>k</em></span> that gives the current length of the string </li>
<li><span class="math inline"><em>k</em></span> is also the index into  where we can insert another character</li>
</ul>
<pre><code>; out[k] = &#39;*&#39;
     load   R8,k[R0]          ; R8 = k
     load   R10,star[R0]      ; R10 = &#39;*&#39;
     store  R10,out[R8]       ; out[k] = &#39;*&#39;
; k = k + 1
     lea    R4,1[R0]          ; R4 = 1
     add    R8,R8,R4          ; R8 = k + 1
     store  R8,k[R0]          ; k = k + 1

star data   $002a             ; code for &#39;*&#39;</code></pre>
<h3 id="memory-allocation-1">Memory allocation</h3>
<ul>
<li>The operating system maintains a map of the entire memory, organised as a set of blocks</li>
<li>A running program often needs to allocate a block of memory dynamically</li>
<li>When a program requests memory, it asks for a  of block that it needs, and the operating system returns with the  of a block</li>
</ul>
<h3 id="part-of-the-instruction-set-1">Part of the instruction set</h3>
<pre><code>load   R1,x[R2]   R1 := mem[x+R2]
lea    R1,x[R2]   R1 := x+R2
store  R1,x[R2]   mem[x+R2] := R1
jump   x[R2]      pc := x+R2
jumpf  R1,x[R2]   if R1=0 then pc := x+R2
jumpt  R1,x[R2]   if R1/=0 then pc := x+R2
jal    R1,x[R2]   R1 := pc, pc := x+R2

add    R1,R2,R3   R1 := R2+R3
sub    R1,R2,R3   R1 := R2-R3
cmplt  R1,R2,R3   R1 := R2&lt;R3
cmpeq  R1,R2,R3   R1 := R2=R3
cmpgt  R1,R2,R3   R1 := R2&gt;R3</code></pre>
<h2 id="pointers-2">Pointers</h2>
<ul>
<li>We often need a variable that contains the </li>
<li>This is called a </li>
<li><p>Example: to write a string with trap R1,R2,R3:</p></li>
<li>R1 contains the code indicating a write request</li>
<li>R2 contains a  (address of the first character in the string)</li>
<li><p>R3 contains the length of the string</p></li>
</ul>
<h3 id="three-key-instructions-lea-load-store">Three key instructions: lea, load, store</h3>
<p>These are the most important instructions dealing with memory and memory addresses</p>
<ul>
<li><p>lea (load effective address) calculates the effective address and loads that into the destination register</p>
<ul>
<li></li>
</ul></li>
<li><p>load calulates the effective address, fetches the word from memory at that address, and loads it into the destination register</p></li>
<li></li>
<li><p>store is the opposite of load: copies a word from the destination register into memory at the effective address</p></li>
<li></li>
</ul>
<h3 id="a-computer-is-a-digital-circuit">A computer is a digital circuit!}</h3>
<ul>
<li>It isn’t a magic box with a little man inside!</li>
<li>A computer is a  constructed from  and </li>
</ul>
<h3 id="philosophical-question-finding-the-ultimate-cause">Philosophical question: finding the ultimate cause}</h3>
<ul>
<li><p>A computer does lots of different things</p>
<ul>
<li>Arithmetic</li>
<li>Sequences of calculations</li>
<li>Decisions</li>
<li>Goto</li>
</ul></li>
<li>Yet it’s just a digital circuit made of logic gates and flip flops, which </li>
<li><p>The interesting behaviours  from the way the basic components are connected</p></li>
</ul>
<h3 id="some-examples-of-emergent-ultimate-causes">Some examples of emergent ``ultimate causes’’}</h3>
<ul>
<li><p>Arithmetic</p>
<ul>
<li>Full adder uses logic gates to calculate sum and carry</li>
<li>Ripple carry adder transfers carry bits to get binary sum</li>
</ul></li>
<li><p>Sequences of calculations</p></li>
<li><p>The pc register points to next instruction, and is incremented as each instruction is executed</p></li>
<li><p>Decisions</p></li>
<li>If statements are translated to </li>
<li><p>Control algorithm uses a multiplexer to take different actions based on cond</p></li>
<li><p>Goto</p></li>
<li><p>Goto is just loading the pc with the effective address</p></li>
</ul>
<h3 id="summary">Summary</h3>
<ul>
<li>Register circuits hold the state of a processor</li>
<li>Combinational logic circuits perform calculations</li>
<li>Multiplexers allow control over where data moves</li>
<li>A control algorithm sets the multiplexers, determining what register changes will occur at the next clock tick</li>
<li>Everything (address calculation, jumps, etc.) is implemented by loading the right value into a register</li>
<li>The control algorithm is an  for the instruction set</li>
</ul>
<h4 id="booleans">Booleans</h4>
<ul>
<li>A Boolean is a data type with two values:  and </li>
<li>A Boolean expression has the value True or False: </li>
<li>Conditional control structures use a Boolean to decide what to do</li>
<li><p>In assembly language, we will</p></li>
<li>Calculate a Boolean value in a register</li>
<li><p>Use it to control a ``conditional goto’’ (called a )</p></li>
</ul>
<h3 id="booleans-in-machine-language">Booleans in machine language</h3>
<ul>
<li>A Boolean is represented as a word (16 bits)</li>
<li>The canonical representation is False=0 and True=1 (these are 16 bit integers).</li>
<li>Comparison instructions produce Booleans in the canonical representation</li>
<li>Conditional jumps treat , and </li>
</ul>
<h3 id="example-program-findmax">Example: program findmax}</h3>
<p>The program searches an array of natural numbers for the maximal element, and the loop terminates when a negative element is encountered.</p>
<pre><code>{-
Register usage:
  R0 = constant 0
  R1 = maximum value found so far
  R2 = loop index i
  R3 = constant -1, indicates end of list
  R4 = x[i]
  R5 = constant 1, for incrementing i
  R6 = temp Bool value
-}</code></pre>
<p>}</p>
<p>%———————————————————————–</p>
<p>{ ~~~~ load R1,x[R0] ; max := x[0] lea R2,1[R0] ; i := 1 lea R3,-1[R0] ; R3 := -1 lea R5,1[R0] ; R5 := 1 (for counter) loop load R4,x[R2] ; R4 := x[i] cmpgt R6,R4,R3 ; R6 := (x[i] &gt;= -1) jumpf R6,done ; goto done if not cmpgt R6,R4,R1 ; R6 := (x[i] &gt; max) jumpf R6,skip[R0] ; goto skip if not add R1,R4,R0 ; max := x[i] skip add R2,R2,R5 ; i := i+1 jump loop[R0] ; goto loop done store R1,max[R0] ; save max trap R0,R0,R0 ; terminate execution</p>
<p>x data 2 data 42 data 224 data 19 data 4 data -1 max data $0000 ; 0 ~~~~ }</p>
<h3 id="trap-1">Trap</h3>
<ul>
<li>The trap instruction has three register operands (it’s an RRR instruction)
<ul>
<li>Trap R2,R3,R5</li>
<li>It requests the operating system to perform a service, such as input/output</li>
<li>The first register contains a  that tells the operating system what the program is requesting; the other registers may contain further data</li>
<li>A trap code of 0 terminates the program</li>
<li>You can stop a program by executing trap R0,R0,R0</li>
</ul></li>
</ul>
<h2 id="addresses">Addresses</h2>
<ul>
<li>An address is specified in two parts: an  and a .</li>
<li>The constant is a 16 bit integer which constitutes a second word of the instruction.</li>
<li><p>The machine calculates an , which is the sum of the constant and the index register</p></li>
<li>lea R1,const[R2]  R1 := const+R2</li>
<li>load R1,const[R2] R1 := mem[const+R2]</li>
<li><p>store R1,const[R2] mem[const+R2] := R1</p></li>
</ul>
<p>The lea instruction is ``load effective address’’; the load and store instructions use to effective address to fetch/update a word in memory</p>
<h3 id="accessing-data">Accessing data</h3>
<p>The index-constant scheme offers several ways to access data , which simplifies the hardware:</p>
<ul>
<li> gives the address of a scalar <span class="math inline"><em>x</em></span> (because R0 contains 0)</li>
<li> uses a variable address in the register</li>
<li><p> gives the element of the array, <span class="math inline"><em>a</em><sub><em>i</em></sub></span> where <span class="math inline"><em>i</em></span> is the index in R2.</p></li>
<li><p>Unassessed exercise: Complete the truth table for the mux1 circuit, by simulating it for all input combinations. Try to describe, at a more abstract and intuitive level, how it works.</p></li>
</ul>
<h2 id="hexadecimal-numbers">Hexadecimal Numbers</h2>
<ul>
<li>Base-16 numbers</li>
<li>Don’t worry! Hexadecimal numbers are used only when they are easier than binary!</li>
<li>Used as a notation to make it easier to read and write bytes and words</li>
<li>A small investment in learning Hex will save lots of time later</li>
<li>Used routinely in  and </li>
</ul>
<h3 id="hexadecimal-digits">Hexadecimal Digits</h3>

<h3 id="hexadecimal-numbers-hex-numbers">Hexadecimal numbers (``hex numbers’’)</h3>
<ul>
<li>Hex is used to write bit strings more concisely</li>
<li>The bit string needs to have a multiple of 4 bits</li>
<li>Modern computers use ``nibbles’’ (4 bits), bytes (8 bits), short words (16 bits), full words (32 bits), long words (64 bits), and sometimes 128-bit words</li>
<li>Break up the word into groups of 4 bits</li>
<li>Replace each group with the corresponding hex digit</li>
</ul>

<h3 id="hexadecimal-is-easier-to-read-than-bits">Hexadecimal is easier to read than bits</h3>
<ul>
<li>Like binary, hex is for nonnegative integers</li>
<li>But we can write out any word as hex digits</li>
<li>Each hex digit corresponds to 4 bits: Hex is 4 times more concise</li>
<li>Long strings of bits are hard to read: it’s hard to keep your place</li>
</ul>
<h2 id="jumping">Jumping</h2>
<p>All jumps refer to effective addresses.</p>
<ul>
<li>jumpf R1,const[R2] \ If R1 false then goto mem[R2+const]</li>
<li>jumpt R1,const[R2] \ If R1 true then goto mem[R2+const]</li>
</ul>
<h3 id="instruction-set-1">Instruction set</h3>
<pre><code>load   R1,x[R2]   R1 := mem[x+R2]
lea    R1,x[R2]   R1 := x+R2
store  R1,x[R2]   mem[x+R2] := R1
jumpf  R1,x[R2]   if R1=0 then pc := x+R2
jumpt  R1,x[R2]   if R1/=0 then pc := x+R2
jal    R1,x[R2]   R1 := pc, pc := x+R2

add    R1,R2,R3   R1 := R2+R3
sub    R1,R2,R3   R1 := R2-R3
cmplt  R1,R2,R3   R1 := R2&lt;R3
cmpeq  R1,R2,R3   R1 := R2=R3
cmpgt  R1,R2,R3   R1 := R2&gt;R3</code></pre>
<h3 id="what-can-we-learn-from-this">What can we learn from this?</h3>
<ul>
<li><p>To be a good programmer you need to</p>
<ul>
<li>Know your programming language</li>
<li>Be meticulous</li>
<li> your code carefully</li>
</ul></li>
<li><p>Do thorough testing</p></li>
<li><p>It was very helpful that Apple published the source code for this bug</p></li>
</ul>
<h3 id="structure-of-the-control-algorithm">Structure of the control algorithm</h3>
<pre><code>repeat forever
  ir := mem [pc],  pc := pc+1
  case ir.op of
    0 -&gt; reg [ir.d] := reg [ir.sa] + reg [ir.sb]    ; add
    1 -&gt; reg [ir.d] := reg [ir.sa] - reg [ir.sb]    ; sub
       ...
    4 -&gt; reg [ir.d] := reg [ir.sa] &lt; reg [ir.sb]     ; cmplt
       ...
   15 -&gt; case ir.sb of
               0 -&gt; adr := mem [pc],  pc = pc + 1    ; lea
                       adr := adr + reg [ir.sa]
                       reg [ir.d] := adr
               1 -&gt; adr := mem [pc],  pc = pc + 1    ; load
                       adr := adr + reg [ir.sa]
                       dat := mem [adr]
                       reg [ir.d] := dat</code></pre>
<h3 id="a-closer-look-at-lea">A closer look at lea</h3>
<ul>
<li>Fetch the second word of the instruction (the displacement) and put it in adr; also increment the pc</li>
<li>Calculate the effective address: displacement + index register</li>
<li>Load the effective address into the destination register \end{enumerate}</li>
</ul>
<pre><code>        0 -&gt; adr := mem [pc],  pc = pc + 1    ; lea
             adr := adr + reg [ir.sa]
             reg [ir.d] := adr</code></pre>
<h3 id="lea-and-load-similar-but-not-identical">Lea and Load: similar but not identical!</h3>
<ul>
<li>Load starts the same as lea: it calculates the effective address</li>
<li>Then it  and loads that into the destination register</li>
<li>The difference is that lea just loads the effective address into the destination register</li>
</ul>
<pre><code>        0 -&gt; adr := mem [pc],  pc = pc + 1    ; lea
             adr := adr + reg [ir.sa]
             reg [ir.d] := adr

        1 -&gt; adr := mem [pc],  pc = pc + 1    ; load
             adr := adr + reg [ir.sa]
             dat := mem [adr]
             reg [ir.d] := dat</code></pre>
<h3 id="a-jump-is-just-a-load">A jump is just a load!</h3>
<ul>
<li>Calculate the effective address</li>
<li>Load the effective address into the pc</li>
<li>The next instruction to be executed is whatever is at that address</li>
</ul>
<pre><code>        3 -&gt; adr := mem [pc],  pc = pc + 1    ; jump
             adr := adr + reg [ir.sa]
             pc := adr</code></pre>
<h3 id="programming-guidelines">Programming Guidelines</h3>
<ul>
<li>The program file should contain the following, in this order:</li>
</ul>
<h3 id="identify-the-program">Identify the program</h3>
<pre><code>; Program Max (Sigma16 assembly language)
; Author: John O&#39;Donnell, 2017

; Max: find the maximum element of an array
;
; The program is given
;   *  a natural number n, assume n&gt;0
;   *  an n-element array x[0], x[1], ..., x[n-1]
;  It calculates
;   * max = the maximum element of x</code></pre>
<p>Write this first, and put it at the start of the file, as full ine comments. Say what the program is and what it does.</p>
<h3 id="high-level-algorithm-as-pseudocode">High level algorithm as pseudocode</h3>
<pre><code>; Since n&gt;0, the array x contains at least one element,
; and a maximum element is guaranteed to exist.
;
;   max := x[0]
;   for i := 1 to n-1
;       if x[i] &gt; max
;         then max := x[i]</code></pre>
<p>}</p>
<p>Put this after the program identification comments.</p>
<h3 id="middle-level-the-goto-form">Middle level: the ``goto form’’</h3>
<ul>
<li><p>The algorithm is written in high level language notation</p>
<ul>
<li>It just uses variables, without specifying whether they are currently in registers or memory</li>
<li>It doesn’t need instructions like load, store, lea</li>
<li>It can use expressions like  which would require several instructions to implement</li>
</ul></li>
</ul>
<p>It may use</p>
<ul>
<li>Assignment statements, e.g 
<ul>
<li>goto statements, e.g. </li>
<li>if - then - goto, e.g. </li>
</ul></li>
<li>It does not contain complex control constructs: while, for, if-then-else</li>
<li>In an  statement, only a goto is allowed after </li>
</ul>
<h3 id="translate-high-level-code-to-low-level-goto-form">Translate high level code to low level ``goto form’’</h3>
<pre><code>;         i = 1
;         max = x[0]
; 
; loop:   if not (i&lt;n) then goto done
;         if x[i] &lt;= max then goto next
;         max = x[i]
; next:   i = i + 1
;         goto loop
; 
; done:   terminate</code></pre>
<p></p>
<h3 id="specify-how-the-registers-are-used">Specify how the registers are used</h3>
<p>If you keep any variables or constants in registers, document this in comments</p>
<pre><code>; Register usage
;   R1 = constant 1
;   R2 = n
;   R3 = i
;   R4 = max</code></pre>
<p>}</p>
<p>\alert{</p>
<ul>
<li>This makes it easier to check that you used the right register.</li>
<li>A bug like  is easy to spot: just compare the instruction with the register usage.</li>
<li>Without the register usage comments, you have to read a large part of the program to catch this one little bug. }</li>
</ul>
<h3 id="lowest-level-commented-assembly-language">Lowest level: Commented assembly language</h3>
<ul>
<li>The code should be organised in sections.</li>
<li>Separate the sections with a blank line - makes it easier to read</li>
<li>Each section corresponds to one statement in the goto-form algorithm</li>
<li>That statement appears as a full line comment before the instructions</li>
<li>Each instruction has a comment explaining what that instruction does, at the highest level possible (e.g. i := i + 1, not R3 := R3 + R7)</li>
</ul>
<h3 id="block-of-statements-to-initialise-registers">Block of statements to initialise registers</h3>
<pre><code>; Initialise

       lea   R1,1[R0]          ; R1 = constant 1
       load  R2,n[R0]          ; R2 = n
       lea   R3,1[R0]          ; R3 = i = 1
       load  R4,x[R0]          ; R4 = max = x[0]</code></pre>
<p>}</p>
<p>These instructions implement what the Register Usage comments say</p>
<h3 id="assembly-language-code">Assembly language code</h3>
<pre><code>; Top of loop, determine whether to remain in loop
; if not (i&lt;n) then goto done
loop
       cmp    R3,R2            ; compare i, n
       jumpge R5,done[R0]      ; if i&gt;=n then goto done

; if x[i] &lt;= max  then goto next
       load   R5,x[R3]         ; R5 = x[i]
       cmp    R5,R4            ; compare x[i], max
       jumple next[R0]         ; if x[i] &lt;= max then goto next

; max := x[i]
       add   R4,R5,R0          ; max := x[i]</code></pre>
<p>}</p>
<h3 id="assembly-language-continued">Assembly language, continued</h3>
<pre><code>; Bottom of loop, increment loop index
;   i = i + 1
;   goto loop

next   add   R3,R3,R1          ; i = i + 1
       jump  loop[R0]          ; go to top of loop

; Store max and terminate
done   store R4,max[R0]        ; max = R4
       trap  R0,R0,R0          ; terminate</code></pre>
<p>}</p>
<h3 id="data-definitions">Data definitions</h3>
<pre><code>; Data area
n        data   6
max      data   0
x        data  18
         data   3
         data  21
         data  -2
         data  40
         data  25</code></pre>
<p>}</p>
<h3 id="static-variables-in-a-data-segment-1">Static variables in a data segment</h3>
<ul>
<li>The variables are not placed in memory right after the instructions</li>
<li>The program makes a request to the operating system to allocate a block of memory for data (the static data segment)</li>
<li>A register is dedicated to point to the static data segment</li>
<li>Variables are accessed using the static data segment register</li>
</ul>
<h3 id="implementing-static-data-segment-1">Implementing static data segment</h3>
<pre><code>     ... set up registers to request a
          data block of n words...

     trap  R1,R2,R3
     ... R3 is set to the address of the data block
     add   R12,R0,R3    ; R12 = address of static data segment

   ...
     load  R2,n[R12]    ; R2 := n (access static variable)

     segment            ; subsequent labels will access segment
n    data
x    data</code></pre>
<p>}</p>
<h2 id="assembly-language-2">Assembly language</h2>
<p>This section describes the syntax rules for assembly language</p>
<h3 id="assembly-language-notation">Assembly language notation</h3>
<ul>
<li>Each statement has four fields</li>
<li>The assembler uses a very simple rule: it just looks for groups of non-space characters, separated by spaces</li>
</ul>
<h3 id="fields-separated-by-spaces">Fields separated by spaces</h3>
<ul>
<li><p>An assembly language statement has </p>
<ul>
<li>label (optional) – if present, must begin in leftmost character</li>
<li>operation load, add, etc.</li>
<li>operands: R1,R2,R3 or R1,x[R0]</li>
<li>comments: ; x = 2 * (a+b)</li>
</ul></li>
<li><p></p></li>
<li>R1,R12,R5 is ok</li>
<li><p>R1, R12,R5 is wrong</p></li>
</ul>
<p>{ ~~~~ loop load R1,count[R0] ; R1 = count add R1,R1,R2 ; R1 = R1 + 1 ~~~~ }</p>
<p>The assember first breaks each statement into the four fields; then it looks at the operation and operands.</p>
<h3 id="correct-form-of-operand-field">Correct form of operand field</h3>
<ul>
<li><p>RRR</p>
<ul>
<li>Exactly three registers separated by commas</li>
<li>Example: </li>
</ul></li>
<li><p>RX</p></li>
<li>Two operands: first is a register, second is an address</li>
<li>Address is a name or constant followed by [register]</li>
<li><p>Example: </p></li>
</ul>
<h3 id="each-of-these-statements-is-wrong">Each of these statements is wrong!</h3>
<pre><code>    add   R2, R8, R9     Spaces in the operand field
    store x[R0],R5       First operand must be register, second is address
  loop load R1,x[R0]     Space before the label
    jumpt R6,loop        Need register after address:  loop[R0]
    jal   R14, fcn[R0]   Space in operand field</code></pre>
<p>}</p>
<p>If you forget some detail, look at one of the example programs</p>
<h3 id="writing-constants">Writing constants</h3>
<ul>
<li><p>In assembly language, you can write constants in either decimal or hexadecimal</p>
<ul>
<li> 50</li>
<li> $0032</li>
</ul></li>
</ul>
<p>Examples:</p>
<pre><code>   lea   R1,40[R0]      ; R1 = 40
   lea   R2,$ffff[R0]   ; R2 = -1

x  data  25
y  data  $2c9e</code></pre>
<h3 id="good-style">Good style</h3>
<ul>
<li>It isn’t enough just to get the assembler to accept your program without error messages</li>
<li>Your program should be </li>
<li>This requires good style</li>
<li></li>
<li>A sloppy program looks unprofessional</li>
</ul>
<h3 id="comments-1">Comments</h3>
<ul>
<li>In Sigma16, a semicolon  indicates that the rest of the line is a comment</li>
<li>You can have a full line comment: just put ; at the beginning</li>
<li>You should use good comments in all programs, regardless of language</li>
<li>But they are even more important in machine language, because the code needs more explanation</li>
<li>At the beginning of the program, use comments to give the name of the program and to say what it does</li>
<li>Use a comment on every instruction to explain what it’s doing</li>
</ul>
<h3 id="indent-your-code-consistently">Indent your code consistently</h3>
<p>Each field should be lined up vertically, like this:</p>
<pre><code>    load   R1,three[R0]  ; R1 = 3
    load   R2,x[R0]      ; R2 = x
    mul    R3,R1,R2      ; R3 = 3*x
    store  R3,y[R0]      ; y = 3*x
    trap   R0,R0,R0      ; stop the program</code></pre>
<p>}</p>
<p>Not like this:</p>
<pre><code>    load   R1,three[R0]     ; R1 = 3
  load  R2,x[R0] ; R2 = x
       mul R3,R1,R2           ; R3 = 3*x
 store         R3,y[R0]      ; y = 3*x
   trap  R0,R0,R0      ; stop the program</code></pre>
<p>}</p>
<p>{The exact number of spaces each field is indented isn’t important; what’s important is to }</p>
<h3 id="use-spaces-not-tabs">Use spaces, not tabs</h3>
<ul>
<li>To indent your code, always use spaces</li>
<li>Don’t use tabs!</li>
<li><p>In general,  except in the (rare) cases they are actually required</p></li>
<li>The tab character was introduced to try to mimic the tab key on old mechanical typewriters</li>
<li>But </li>
<li><p>If you use tabs, your can look good in one application and a mess in another</p></li>
<li><p>It’s easy to indent with spaces, and it works everywhere!</p></li>
</ul>
<h2 id="programming-techniques-1">Programming techniques</h2>
<p>Notes on how to use the instructions effectively</p>
<h3 id="programming-tip-copying-one-register-to-another-1">Programming tip: Copying one register to another</h3>
<ul>
<li>Here’s a useful tip — a standard programming technique</li>
<li><p>Sometimes you want to copy a value from one register to another</p></li>
<li><p>R3 := R12</p></li>
<li><p>There’s a standard way to do it:</p></li>
<li><p></p></li>
<li>The idea is that R12 + 0 = R12!</li>
<li><p>Why do it this way? </p></li>
</ul>
<h3 id="using-load-and-store-1">Using load and store</h3>
<ul>
<li>A common error is to confuse load and store</li>
<li><p>The main points to remember:</p></li>
<li>We need to keep variables in memory (most of the time) because memory is big — there aren’t enough registers to hold all your variables</li>
<li>The computer hardware can do arithmetic on data in registers, but it cannot do arithmetic on data in memory</li>
<li>Therefore, to do arithmetic on variables, you must</li>
</ul>
<h3 id="a-useful-convention">A useful convention</h3>
<ul>
<li><p>The instruction set is designed to be regular, and to follow consistent conventions</p>
<ul>
<li>This makes programming easier</li>
<li>It also helps with the hardware design!</li>
</ul></li>
<li><p>For most instructions, the operands follow the pattern of an assignment statement: information goes right to left</p></li>
<li>Assignment statement: </li>
<li>Add instruction: </li>
<li>The two operands on the right (R2, R3) are added, and placed in the destination on the left (R1)</li>
<li><p>Load instruction:  means </p></li>
<li><p></p></li>
<li> means x := R1: the information goes from left to right</li>
<li><p>Why? Doing it this way makes the digital circuit (the processor) a little bit faster</p></li>
</ul>
<h3 id="development-by-transformation">Development by transformation}</h3>
<ul>
<li>In typical ``real world’’ situations a programmer just uses a high level language</li>
<li>To produce assembly language, a typical programmer is tempted to hack out code randomly and debug it randomly</li>
<li><p>We are insisting on a systematic approach</p></li>
<li>Start with algorithm in a high level language</li>
<li>Transform it to low level via systematic patterns</li>
<li>Transform that to assembly language</li>
<li>Test each stage by hand execution</li>
<li><p>The worst bugs usually appear in the high to low transformation</p></li>
</ul>
<h3 id="high-level">High level</h3>
<pre><code>   sum := 0;
   p := &amp;RecordArray;
   q := &amp;RecordArrayEnd;
   while p &lt; q do
     { *p.fieldA := *p.fieldB + *p.fieldC;
       sum := sum + *p.fieldA;
       p := p + RecordSize; }</code></pre>
<h3 id="low-level">Low level</h3>
<pre><code>   sum := 0;
   p := &amp;RecordArray;
   q := &amp;RecordArrayEnd;
RecordLoop
   if (p&lt;q) = False then goto recordLoopDone;
   *p.fieldA := *p.fieldB + *p.fieldC;
   sum := sum + *p.fieldA;
   p := p + RecordSize;
   goto recordLoop;
RecordLoopDone</code></pre>
<p>Assembly</p>
<pre><code>    lea    R1,0[R0]                 ; sum := 0
    lea    R2,RecordArray[R0]       ; p := &amp;RecordArray;
    lea    R3,RecordArrayEnd[R0]    ; q := &amp;RecordArray;
    load   R4,RecordSize[R0]        ; R4 := RecordSize
RecordLoop
    cmplt  R5,R2,R3                 ; R5 := p&lt;q
    jumpf  R5,RecordLoopDone[R0]    ; if (p&lt;q) = False then goto RecordLoopDone
    load   R5,1[R2]                 ; R5 := *p.fieldB
    load   R6,2[R2]                 ; R6 := *p.fieldC
    add    R7,R5,R6                 ; R7 := *p.fieldB + *p.fieldC
    store  R7,0[R2]                 ; *p.fieldA := *p.fieldB + *p.fieldC
    add    R1,R1,R7                 ; sum := sum + *p.fieldA
    add    R2,R2,R4                 ; p := p + RecordSize
    jump   RecordLoop[R0]           ; goto RecordLoop
RecordLoopDone</code></pre>
<h3 id="basic-expressions-and-statements">Basic expressions and statements</h3>
<ul>
<li><p>Expressions</p>
<ul>
<li>integer and natural</li>
<li>boolean</li>
</ul></li>
<li><p>assignments</p></li>
<li><p>lhs := expression</p></li>
</ul>
<h3 id="exposing-the-architecture">Exposing the architecture</h3>
<ul>
<li>Low level language constructs expose the architecture</li>
<li>The lowest level language constructs correspond directly to instructions</li>
<li><p>Registers</p></li>
<li><p>Register variables R0, R1, <span class="math inline">…</span>, R15</p></li>
<li><p>Instructions</p></li>
<li>load </li>
<li>store </li>
<li>add </li>
<li>jump </li>
<li>jumpt </li>
<li><p>jumpf </p></li>
<li><p>Interface to operating system</p></li>
</ul>
<p>Relations between the levels</p>
<ul>
<li>We could have completely separate high and low level languages</li>
<li>Hypothesis: it’s better to allow mixing where the semantics is clear</li>
<li><p>This allows you to</p></li>
<li>Transform from high to low level in stages, rather than in one gigantic leap</li>
<li><p>Focus on the low level for a particularly interesting part of the program, while keeping the boilerplate at a high level</p></li>
<li><p>Disallow mixing levels where semantics is unclear</p></li>
<li><p>R4 := R2 - (x*y)</p></li>
</ul>
<h4 id="data-types-and-data-structures">Data types and data structures</h4>
<h3 id="data-types-1">Data types</h3>
<ul>
<li><p>Basic types</p>
<ul>
<li>integer, natural, pointer, boolean, character</li>
</ul></li>
<li><p>Compound types</p></li>
<li>array, record, linked lists, trees</li>
<li>Call stack, stack frame</li>
<li><p>Static variables, local variables, heap variables</p></li>
</ul>
<h3 id="records-3">Records</h3>
<pre><code>program Records
 { x, y :
     record
       { fieldA : int;
         fieldB : int;
         fieldC : int; }
   x.fieldA := x.fieldB + x.fieldC;
   y.fieldA := y.fieldB + y.fieldC;
 }</code></pre>
<h3 id="traverse-array-of-records-with-indexing-1">Traverse array of records with indexing</h3>
<pre><code>sum := 0;
for i := 0 to nrecords do
  { RecordArray[i].fieldA :=
       RecordArray[i].fieldB + RecordArray[i].fieldC;
    sum := RecordArray[i].fieldA; }</code></pre>
<h3 id="traverse-array-of-records-with-pointers">Traverse array of records with pointers</h3>
<pre><code>sum := 0;
p := &amp;RecordArray;
q := &amp;RecordArrayEnd;
while p &lt; q do
  { *p.fieldA := *p.fieldB + *p.fieldC;
    sum := sum + *p.fieldA;
    p := p + RecordSize; }</code></pre>
<h3 id="high-level-control-structures">High level control structures</h3>
<ul>
<li>if bexp then S
<ul>
<li>if bexp then S else S</li>
<li>if bexp then S elsif bexp then S elsif … else S</li>
<li>case exp of {S; S; …}</li>
<li>while bexp do S</li>
<li>repeat S until bexp</li>
<li>procedure P (var:type, …)</li>
<li>function F (var:type, …) : type</li>
</ul></li>
</ul>
<h3 id="low-level-control-structures">Low level control structures</h3>
<ul>
<li>goto label</li>
<li>if bexp then goto label</li>
<li>if not bexp then goto label</li>
</ul>
<h3 id="compilation-patterns-2">Compilation patterns</h3>
<ul>
<li>Each programming construct can be translated according to a standard pattern</li>
<li><p>It’s useful to translate in two steps:</p></li>
<li>First, translate complex statements to simple high level statements (go to label, if b then goto label)</li>
<li>The ``goto form’’ of the algorithm corresponds closely to machine instructions</li>
<li><p>Then it’s straightforward to complete the translation to assembly language</p></li>
<li>Assignment statements — loads, then arithmetic, then store</li>
<li>goto label — jump label[R0]</li>
<li>if b then goto label — jumpt R5,label[R0] where R5 contains b</li>
<li><p>if not b then goto label — jumpf R5,label[R0] where R5 contains b</p></li>
<li><p>This approach clarifies how the algorithm works</p></li>
</ul>
<h3 id="if-bexp-then-s">if bexp then S</h3>
<pre><code>if x&lt;y
  then {statement 1;}
statement 2;</code></pre>
<p></p>
<pre><code>   R7 := (x &lt; y)
   jumpf R7,skip[R0]
   instructions for statement 1
skip
   instructions for statement 2 </code></pre>
<h3 id="if-bexp-then-s1-else-s2">if bexp then S1 else S2</h3>
<pre><code>if x&lt;y
  then { S1 }
  else { S2 }
S3</code></pre>
<p>Compiled into: ~~~~ R5 := (x&lt;y) jumpf R5,else[R0] ; then part of the statement instructions for S1 jump done[R0] ; else part of the statement else instructions for S2 done instructions for statement S3 ~~~~</p>
<h3 id="while-b-do-s">while b do S</h3>
<pre><code>while i&lt;n do
  { S1 }
S2</code></pre>
<p>Compiled into: ~~~~ loop R6 := (i&lt;n) jumpf R6,done[R0] … instructions for the loop body S1 … jump loop[R0] done instructions for S2 ~~~~</p>
<h3 id="implementing-compilation-patterns">Implementing compilation patterns</h3>
<ul>
<li>All the language constructs correspond to constructors in an algebraic data type</li>
<li>Use pattern matching definitions, here’s a sketch</li>
</ul>
<pre><code>transform (IfThenElse b s1 s2) = do
  elseLabel &lt;- newlabel
  doneLabel &lt;- newlabel
  bcode &lt;- transform b
  testJump &lt;- ifnot bcode elseLabel
  thenCode &lt;- transform s1
  elseCode &lt;- transform s2
  return $
     bcode &lt;+&gt; testJump
       &lt;+&gt; thenCode &lt;+&gt; skipelse
       &lt;+&gt; elseLabel &lt;+&gt; elseCode
       &lt;+&gt; doneLabel</code></pre>
<h3 id="some-interesting-points">Some interesting points</h3>
<p>%———————————————————————</p>
<h3 id="opportunities">Opportunities</h3>
<ul>
<li>Normally we think of a machine language as being limited in expressiveness</li>
<li><p>But few programming languages expose some very important techniques that are available in a well-designed machine language</p></li>
<li>multiple word arithmetic</li>
<li>jump tables</li>
<li>arithmetic on data addresses</li>
<li><p>arithmetic on instruction addresses</p></li>
</ul>
<h3 id="opportunity-for-multiple-execution-models">Opportunity for multiple execution models</h3>
<ul>
<li><p>There are several ways to handle procedure calls</p>
<ul>
<li>Call stack vs. heap</li>
<li>Caller saves vs. callee saves</li>
<li>General recursion vs. tail recursion</li>
</ul></li>
<li><p>Plan to explore some of these</p></li>
<li>This requires transforming procedure calls into statements at the level of instructions</li>
<li><p>Some support by compiler analysis is needed</p></li>
</ul>
<h3 id="tricky-issues">Tricky issues</h3>
<ul>
<li><p>Syntax</p>
<ul>
<li>Explicit or implicit compound statements?</li>
<li> b  {S; S;}  {S; S;}</li>
<li> b  S; S  S; S </li>
<li>Also affects scoping rules</li>
<li>Could be interesting to allow/illustrate both styles</li>
<li>Prefix operators:  or  or </li>
</ul></li>
<li><p>Semantics</p></li>
<li>Some low level statements have side effects</li>
<li><p>Interrupts cause unexpected jumps</p></li>
</ul>
<h2 id="stacks-1">Stacks</h2>
<p>A stack is represented as a block of words with consecutive addresses sb, sb+1, sb+2, …, sl. There are three instructions that operate on stacks: push, pop, and top. Each of these instructions checks to ensure that the operation is valid, and indicates an error condition of not. Four variables are needed to use a stack:</p>
<ul>
<li><p>sb (stack base) = address of the first word in the block</p></li>
<li><p>sl (stack limit) = address of the last word in the block; for the stack to function properly it is necessary that sb &lt; sl.</p></li>
<li><p>st (stack top) = pointer to the top element. There are three cases. If the stack contains at least one element, then st is its address and sb &lt;= st &lt;= sl. If the stack is empty, then st=sb-1. If the stack is full, then st=sl.</p></li>
<li><p>x (data) = value to be pushed onto the stack, or result of a pop or top operation</p></li>
</ul>
<p>There are three instructions that operate on stacks: push, pop, and top. Push inserts the value in the destination register at the top of the stack, pop removes the top of the stack and loads it into the destination register, and top loads the top element into the destination register without removing it from the stack. For all three instructions, if the operation is impossible then an error is signaled in the condition code register and the interrupt request register.</p>
<h1 id="circuit">Circuit</h1>
<ul>
<li><p>Download Hydra and save it in your workspace. Suppose its location is /c/Users/me/a/b/c/Hydra.</p></li>
<li><p>Open a shell and enter circuit/M1. Run a test program, e.g. ArrayMax.hs, as follows:</p></li>
</ul>
<pre><code>ghci -i/c/Users/me/a/b/c/Hydra/src/haskell/ ArrayMaxRun</code></pre>
<p>The command can be simplified by defining a .ghci file, which will be loaded automatically when you invoke ghci. You can put the .ghci file in your $HOME directory. See the GHC User Guide for more details about configuring ghci.</p>
<pre><code>:set -i/c/Users/a/b/c/Hydra/src/haskell/</code></pre>
<p>On development machine (Spectre) use this path:</p>
<pre><code>ghci -i/c/Users/johnt/OneDrive/home/docs/research/Hydra/current/Hydra/src/haskell/
ArrayMaxRun</code></pre>
<p>$HOME/.ghci contains:</p>
<pre><code>:set -iC:\Users\johnt\OneDrive\home\docs\research\Hydra\current\Hydra\src\haskell</code></pre>
<h2 id="m1-circuit">M1 circuit</h2>
<p>M1 is a relatively simple digital circuit that implements a subset of the Sigma16 instruction set architecture. M1 uses sequential control and does not have instruction level parallelism. The circuits comprising M1 are defined in <strong>circuit/M1</strong>.</p>
<p>A few Sigma16 machine language programs, prepared to run on M1, are defined in <strong>circuit/examples/M1examples</strong>. To run these, you need to ensure that both Hydra and M1 are in the ghci search path. See above for making Hydra available. The M1 circuit is placed on the search path by including the following file circuit/examples/M1examples/.ghci:</p>
<p>:set -i../../M1</p>
<p>Enter the directory and enter these commands:</p>
<p>ghci :load ArrayMaxRun :main</p>
<p>These will execute the ArrayMax program on the digital circuit, and that will produce a lot of detailed simulation output showing the values in key registers, flip flops, and signals.</p>
<h1 id="installation">Installation</h1>
<p>The application currently works with Chrome and Firefox, and possible Edge.</p>
<p>The software is available on the Internet at the <a href="https://jtod.github.io/home/Sigma16/">Sigma16 home page</a>, which contains a link to the latest version, some previous versions, related documents, and more information about the project.</p>
<h2 id="how-to-run-sigma16">How to run Sigma16</h2>
<p>There are a number of ways to run the software, but it’s recommended that you try the easiest way.</p>
<h3 id="the-easiest-way-just-click-a-link">The easiest way: just click a link</h3>
<p>Run the app with two clicks:</p>
<ol type="1">
<li>Visit the <a href="https://jtod.github.io/home/Sigma16/">Sigma16 homepage</a></li>
<li>Click on <em>Launch the latest release</em></li>
</ol>
<p>This will run the app in your browser, and you don’t need to download or install anything. For most users this is the recommended method.</p>
<h3 id="download-and-open-file-in-browser">Download and open file in browser</h3>
<p>If you don’t always have Internet access, you can download the files and ope the app in your browser. This is easy to do and allows you to run Sigma16 even when you don’t have access to the Internet. However, it is a little more awkward to run the example programs.</p>
<p>You can also download the software onto your computer and run it locally. This exactly like the first method, except the web pages are coming from your computer’s files rather than the Internet.</p>
<p>Visit the <a href="https://jtod.github.io/Sigma16/index.html">Sigma16 home page</a> and download the zip file for the latest release. Unzip and click on index.html in the folder and follow the directions.</p>
<p>You might also be able to launch it by <a href="../../Sigma16.html">clicking this link</a> although that might not work; it depends on whether all the necessary files are accessible.</p>
<h3 id="run-locally-with-npm-and-electron">Run locally with npm and electron</h3>
<p>The previous methods run the app in a browser. There are some security restrictions on what a browser can do, and these make it slightly awkward for the program to read and write files. You can perform a local installation which will run Sigma16 as a standalone app on your computer, rather than in a browser, and this makes it a little more convenient to use.</p>
<p>If you don’t want to bother with downloading some software tools and running an installation script, you can skip to the next method, which is to download a precompiled executable for your platform. But it’s straightforward to build Sigma16 on your computer:</p>
<ul>
<li><p>You need a shell such as bash or Windows PowerShell. Every computer will have one.</p>
<ul>
<li><p>Install the npm package manager for JavaScript, available at <a href="https://www.npmjs.com/get-npm">https://www.npmjs.com/get-npm</a>. Download the installer and follow the instructions.</p></li>
<li><p>Install the <em>electron</em> package. In your shell, enter <em>npm install electron –save-dev</em>. (Why is it called “electron”? Originally, there was a text editor named <em>Atom</em> written in JavaScript, and it needed a shell. So it’s the electron shell for atom…</p></li>
<li><p>Download the source for Sigma16. Unzip it, and cd into the app directory. Enter <em>make all</em>.</p></li>
<li><p>To launch Sigma16, enter <em>npm run start</em>. Now you’ll have enhanced file access, as well as a few other minor enhancements, and you don’t need Internet access.</p></li>
</ul></li>
</ul>
<h3 id="compiling-a-standalone-executable">Compiling a standalone executable</h3>
<p>First install npm, which also gives you Node.js. Use npm to install electron.</p>
<p>cd src npm install npm start</p>
<p>Clone this repository, then enter the repository, install dependencies, and run the program:</p>
<p>git clone https://github.com/electron/electron-quick-start cd electron-quick-start npm install npm start</p>
<p>To build standalone version using Node.hs and electron. In the src/app directory, use the following commands. They create a file package-lock.json and a directory node_modules, both in src/app.</p>
<p>npm install npm start</p>
<p>The pkg program can generate a native executable which doesn’t require the user to have npm installed.</p>
<p>npm install -g pkg pkg –help pkg main.js</p>
<p>Maybe the bin entry in package.json would allow the command to be just pkg . ? In src directory tried this:</p>
<p>$ pkg -t win-x64 app</p>
<p>Lots of warnings:</p>
<blockquote>
<p>Warning Cannot include directory %1 into executable. The directory must be distributed with executable as %2. app_modules path-to-executable/electron/dist</p>
</blockquote>
<blockquote>
<p>Warning Cannot include file %1 into executable. The file must be distributed with executable as %2. app_modules.js path-to-executable/node_modules/sliced/index.js</p>
</blockquote>
<blockquote>
<p>Warning Cannot include file %1 into executable. The file must be distributed with executable as %2. app_modules-defaults.js path-to-executable/node_modules/deep-defaults/index.js</p>
</blockquote>
<p>Turns out that to build an app with electron one of the following specific tools is needed:</p>
<p>electron-forge electron-builder electron-packager</p>
<p>Trying electron-builder</p>
<p>npm install electron-builder –save-dev in src/app npm run mkdist</p>
<h3 id="version-number">Version number</h3>
<p>The version number is needed in several places. To keep it consistent, there is only one primary place where it should be specified manually: in the version property in app/package.json.</p>
<p>The makefile extracts the version number from that file, and (1) defines a make variable; (2) writes the Sigma16/VERSION file with just the version number, and (3) writes Sigma16/app/version.js which is just defines the version number as a global constant.</p>
<h3 id="running-in-a-browser.">Running in a browser.</h3>
<h3 id="running-a-standalone-pre-compiled-executable">Running a standalone pre-compiled executable</h3>
<h1 id="about-sigma16">About Sigma16</h1>
<p>This program is experimental software, and is under development.</p>
<h2 id="author">Author</h2>
<p>The architecture, software tools, and documentation were designed, implemented, and written by John O’Donnell. Contact: john.t.odonnell9@gmail.com</p>
<h2 id="license">License</h2>
<p>See the files Sigma16/LICENSE.txt and Sigma16/NOTICE.txt.</p>
<p>Copyright (c) 2019 John T. O’Donnell. john.t.odonnell9@gmail.com License: GNU GPL Version 3 or later. Sigma16/LICENSE.txt,NOTICE.txt</p>
<p>This file is part of Sigma16. Sigma16 is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. Sigma16 is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with Sigma16. If not, see <a href="https://www.gnu.org/licenses/" class="uri">https://www.gnu.org/licenses/</a>.</p>
<h2 id="implementation">Implementation</h2>
<p>Sigma16 consists of several components:</p>
<ul>
<li><p>The Integrated Development Environment (IDE) is written in JavaScript, and normally uses a web browser to display the graphical user interface.</p></li>
<li><p>The circuits that implement Sigma16 are defined using the Hydra hardware description language, which is an embedded domain specific language implemented in Haskell.</p></li>
<li><p>The User Guide is written in markdown and prepared for a web browser using pandoc.</p></li>
</ul>
<h1 id="reference">Reference</h1>
<h2 id="index-of-notation">Index of notation</h2>
<ul>
<li><p>ea</p></li>
<li><p>mem[ea]</p></li>
<li><p>reg[d]</p></li>
<li><p>reg[a]</p></li>
<li><p>reg[b]</p></li>
<li><p>reg[d]</p></li>
<li><p>lsb q</p></li>
</ul>
</body>
</html>
